// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: interface.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_interface_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_interface_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_interface_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_interface_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[62]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_interface_2eproto;
namespace dan {
class APPNP;
class APPNPDefaultTypeInternal;
extern APPNPDefaultTypeInternal _APPNP_default_instance_;
class AdjacentList;
class AdjacentListDefaultTypeInternal;
extern AdjacentListDefaultTypeInternal _AdjacentList_default_instance_;
class AdjacentListResult;
class AdjacentListResultDefaultTypeInternal;
extern AdjacentListResultDefaultTypeInternal _AdjacentListResult_default_instance_;
class Binary;
class BinaryDefaultTypeInternal;
extern BinaryDefaultTypeInternal _Binary_default_instance_;
class Code;
class CodeDefaultTypeInternal;
extern CodeDefaultTypeInternal _Code_default_instance_;
class CreateGraph;
class CreateGraphDefaultTypeInternal;
extern CreateGraphDefaultTypeInternal _CreateGraph_default_instance_;
class CreateIndex;
class CreateIndexDefaultTypeInternal;
extern CreateIndexDefaultTypeInternal _CreateIndex_default_instance_;
class CreateTable;
class CreateTableDefaultTypeInternal;
extern CreateTableDefaultTypeInternal _CreateTable_default_instance_;
class DefineVertex;
class DefineVertexDefaultTypeInternal;
extern DefineVertexDefaultTypeInternal _DefineVertex_default_instance_;
class Double;
class DoubleDefaultTypeInternal;
extern DoubleDefaultTypeInternal _Double_default_instance_;
class DoubleVec;
class DoubleVecDefaultTypeInternal;
extern DoubleVecDefaultTypeInternal _DoubleVec_default_instance_;
class EdgeList;
class EdgeListDefaultTypeInternal;
extern EdgeListDefaultTypeInternal _EdgeList_default_instance_;
class Eval;
class EvalDefaultTypeInternal;
extern EvalDefaultTypeInternal _Eval_default_instance_;
class Field;
class FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class Float;
class FloatDefaultTypeInternal;
extern FloatDefaultTypeInternal _Float_default_instance_;
class FloatVec;
class FloatVecDefaultTypeInternal;
extern FloatVecDefaultTypeInternal _FloatVec_default_instance_;
class GAT;
class GATDefaultTypeInternal;
extern GATDefaultTypeInternal _GAT_default_instance_;
class GetVertex;
class GetVertexDefaultTypeInternal;
extern GetVertexDefaultTypeInternal _GetVertex_default_instance_;
class GraphInfo;
class GraphInfoDefaultTypeInternal;
extern GraphInfoDefaultTypeInternal _GraphInfo_default_instance_;
class GraphPartition;
class GraphPartitionDefaultTypeInternal;
extern GraphPartitionDefaultTypeInternal _GraphPartition_default_instance_;
class HostInfo;
class HostInfoDefaultTypeInternal;
extern HostInfoDefaultTypeInternal _HostInfo_default_instance_;
class ImportEdge;
class ImportEdgeDefaultTypeInternal;
extern ImportEdgeDefaultTypeInternal _ImportEdge_default_instance_;
class ImportVertex;
class ImportVertexDefaultTypeInternal;
extern ImportVertexDefaultTypeInternal _ImportVertex_default_instance_;
class IndexSearch;
class IndexSearchDefaultTypeInternal;
extern IndexSearchDefaultTypeInternal _IndexSearch_default_instance_;
class InsertEdge;
class InsertEdgeDefaultTypeInternal;
extern InsertEdgeDefaultTypeInternal _InsertEdge_default_instance_;
class InsertEdgeBatch;
class InsertEdgeBatchDefaultTypeInternal;
extern InsertEdgeBatchDefaultTypeInternal _InsertEdgeBatch_default_instance_;
class InsertEdgeBatchVP;
class InsertEdgeBatchVPDefaultTypeInternal;
extern InsertEdgeBatchVPDefaultTypeInternal _InsertEdgeBatchVP_default_instance_;
class InsertEdgeNaive;
class InsertEdgeNaiveDefaultTypeInternal;
extern InsertEdgeNaiveDefaultTypeInternal _InsertEdgeNaive_default_instance_;
class InsertEdgeVP;
class InsertEdgeVPDefaultTypeInternal;
extern InsertEdgeVPDefaultTypeInternal _InsertEdgeVP_default_instance_;
class InsertRecord;
class InsertRecordDefaultTypeInternal;
extern InsertRecordDefaultTypeInternal _InsertRecord_default_instance_;
class InsertRecordBatch;
class InsertRecordBatchDefaultTypeInternal;
extern InsertRecordBatchDefaultTypeInternal _InsertRecordBatch_default_instance_;
class InsertRecordStr;
class InsertRecordStrDefaultTypeInternal;
extern InsertRecordStrDefaultTypeInternal _InsertRecordStr_default_instance_;
class InsertVertex;
class InsertVertexDefaultTypeInternal;
extern InsertVertexDefaultTypeInternal _InsertVertex_default_instance_;
class InsertVertexBatch;
class InsertVertexBatchDefaultTypeInternal;
extern InsertVertexBatchDefaultTypeInternal _InsertVertexBatch_default_instance_;
class Int;
class IntDefaultTypeInternal;
extern IntDefaultTypeInternal _Int_default_instance_;
class IntVec;
class IntVecDefaultTypeInternal;
extern IntVecDefaultTypeInternal _IntVec_default_instance_;
class LoadGraphFromFolder;
class LoadGraphFromFolderDefaultTypeInternal;
extern LoadGraphFromFolderDefaultTypeInternal _LoadGraphFromFolder_default_instance_;
class Long;
class LongDefaultTypeInternal;
extern LongDefaultTypeInternal _Long_default_instance_;
class LongVec;
class LongVecDefaultTypeInternal;
extern LongVecDefaultTypeInternal _LongVec_default_instance_;
class MemoryStat;
class MemoryStatDefaultTypeInternal;
extern MemoryStatDefaultTypeInternal _MemoryStat_default_instance_;
class MergeInfo;
class MergeInfoDefaultTypeInternal;
extern MergeInfoDefaultTypeInternal _MergeInfo_default_instance_;
class ModelInfo;
class ModelInfoDefaultTypeInternal;
extern ModelInfoDefaultTypeInternal _ModelInfo_default_instance_;
class NodeClassifierInfo;
class NodeClassifierInfoDefaultTypeInternal;
extern NodeClassifierInfoDefaultTypeInternal _NodeClassifierInfo_default_instance_;
class NodeInfo;
class NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class NodeInfoVec;
class NodeInfoVecDefaultTypeInternal;
extern NodeInfoVecDefaultTypeInternal _NodeInfoVec_default_instance_;
class Record;
class RecordDefaultTypeInternal;
extern RecordDefaultTypeInternal _Record_default_instance_;
class RemoteObject;
class RemoteObjectDefaultTypeInternal;
extern RemoteObjectDefaultTypeInternal _RemoteObject_default_instance_;
class RemoteObjectTask;
class RemoteObjectTaskDefaultTypeInternal;
extern RemoteObjectTaskDefaultTypeInternal _RemoteObjectTask_default_instance_;
class RemoteResult;
class RemoteResultDefaultTypeInternal;
extern RemoteResultDefaultTypeInternal _RemoteResult_default_instance_;
class RemoteTask;
class RemoteTaskDefaultTypeInternal;
extern RemoteTaskDefaultTypeInternal _RemoteTask_default_instance_;
class RemoteTaskResult;
class RemoteTaskResultDefaultTypeInternal;
extern RemoteTaskResultDefaultTypeInternal _RemoteTaskResult_default_instance_;
class Str;
class StrDefaultTypeInternal;
extern StrDefaultTypeInternal _Str_default_instance_;
class StrVec;
class StrVecDefaultTypeInternal;
extern StrVecDefaultTypeInternal _StrVec_default_instance_;
class Table;
class TableDefaultTypeInternal;
extern TableDefaultTypeInternal _Table_default_instance_;
class TableInfo;
class TableInfoDefaultTypeInternal;
extern TableInfoDefaultTypeInternal _TableInfo_default_instance_;
class TablePartition;
class TablePartitionDefaultTypeInternal;
extern TablePartitionDefaultTypeInternal _TablePartition_default_instance_;
class TableScan;
class TableScanDefaultTypeInternal;
extern TableScanDefaultTypeInternal _TableScan_default_instance_;
class TestStream;
class TestStreamDefaultTypeInternal;
extern TestStreamDefaultTypeInternal _TestStream_default_instance_;
class TransferBinary;
class TransferBinaryDefaultTypeInternal;
extern TransferBinaryDefaultTypeInternal _TransferBinary_default_instance_;
class VertexExists;
class VertexExistsDefaultTypeInternal;
extern VertexExistsDefaultTypeInternal _VertexExists_default_instance_;
class VertexList;
class VertexListDefaultTypeInternal;
extern VertexListDefaultTypeInternal _VertexList_default_instance_;
class Void;
class VoidDefaultTypeInternal;
extern VoidDefaultTypeInternal _Void_default_instance_;
}  // namespace dan
PROTOBUF_NAMESPACE_OPEN
template<> ::dan::APPNP* Arena::CreateMaybeMessage<::dan::APPNP>(Arena*);
template<> ::dan::AdjacentList* Arena::CreateMaybeMessage<::dan::AdjacentList>(Arena*);
template<> ::dan::AdjacentListResult* Arena::CreateMaybeMessage<::dan::AdjacentListResult>(Arena*);
template<> ::dan::Binary* Arena::CreateMaybeMessage<::dan::Binary>(Arena*);
template<> ::dan::Code* Arena::CreateMaybeMessage<::dan::Code>(Arena*);
template<> ::dan::CreateGraph* Arena::CreateMaybeMessage<::dan::CreateGraph>(Arena*);
template<> ::dan::CreateIndex* Arena::CreateMaybeMessage<::dan::CreateIndex>(Arena*);
template<> ::dan::CreateTable* Arena::CreateMaybeMessage<::dan::CreateTable>(Arena*);
template<> ::dan::DefineVertex* Arena::CreateMaybeMessage<::dan::DefineVertex>(Arena*);
template<> ::dan::Double* Arena::CreateMaybeMessage<::dan::Double>(Arena*);
template<> ::dan::DoubleVec* Arena::CreateMaybeMessage<::dan::DoubleVec>(Arena*);
template<> ::dan::EdgeList* Arena::CreateMaybeMessage<::dan::EdgeList>(Arena*);
template<> ::dan::Eval* Arena::CreateMaybeMessage<::dan::Eval>(Arena*);
template<> ::dan::Field* Arena::CreateMaybeMessage<::dan::Field>(Arena*);
template<> ::dan::Float* Arena::CreateMaybeMessage<::dan::Float>(Arena*);
template<> ::dan::FloatVec* Arena::CreateMaybeMessage<::dan::FloatVec>(Arena*);
template<> ::dan::GAT* Arena::CreateMaybeMessage<::dan::GAT>(Arena*);
template<> ::dan::GetVertex* Arena::CreateMaybeMessage<::dan::GetVertex>(Arena*);
template<> ::dan::GraphInfo* Arena::CreateMaybeMessage<::dan::GraphInfo>(Arena*);
template<> ::dan::GraphPartition* Arena::CreateMaybeMessage<::dan::GraphPartition>(Arena*);
template<> ::dan::HostInfo* Arena::CreateMaybeMessage<::dan::HostInfo>(Arena*);
template<> ::dan::ImportEdge* Arena::CreateMaybeMessage<::dan::ImportEdge>(Arena*);
template<> ::dan::ImportVertex* Arena::CreateMaybeMessage<::dan::ImportVertex>(Arena*);
template<> ::dan::IndexSearch* Arena::CreateMaybeMessage<::dan::IndexSearch>(Arena*);
template<> ::dan::InsertEdge* Arena::CreateMaybeMessage<::dan::InsertEdge>(Arena*);
template<> ::dan::InsertEdgeBatch* Arena::CreateMaybeMessage<::dan::InsertEdgeBatch>(Arena*);
template<> ::dan::InsertEdgeBatchVP* Arena::CreateMaybeMessage<::dan::InsertEdgeBatchVP>(Arena*);
template<> ::dan::InsertEdgeNaive* Arena::CreateMaybeMessage<::dan::InsertEdgeNaive>(Arena*);
template<> ::dan::InsertEdgeVP* Arena::CreateMaybeMessage<::dan::InsertEdgeVP>(Arena*);
template<> ::dan::InsertRecord* Arena::CreateMaybeMessage<::dan::InsertRecord>(Arena*);
template<> ::dan::InsertRecordBatch* Arena::CreateMaybeMessage<::dan::InsertRecordBatch>(Arena*);
template<> ::dan::InsertRecordStr* Arena::CreateMaybeMessage<::dan::InsertRecordStr>(Arena*);
template<> ::dan::InsertVertex* Arena::CreateMaybeMessage<::dan::InsertVertex>(Arena*);
template<> ::dan::InsertVertexBatch* Arena::CreateMaybeMessage<::dan::InsertVertexBatch>(Arena*);
template<> ::dan::Int* Arena::CreateMaybeMessage<::dan::Int>(Arena*);
template<> ::dan::IntVec* Arena::CreateMaybeMessage<::dan::IntVec>(Arena*);
template<> ::dan::LoadGraphFromFolder* Arena::CreateMaybeMessage<::dan::LoadGraphFromFolder>(Arena*);
template<> ::dan::Long* Arena::CreateMaybeMessage<::dan::Long>(Arena*);
template<> ::dan::LongVec* Arena::CreateMaybeMessage<::dan::LongVec>(Arena*);
template<> ::dan::MemoryStat* Arena::CreateMaybeMessage<::dan::MemoryStat>(Arena*);
template<> ::dan::MergeInfo* Arena::CreateMaybeMessage<::dan::MergeInfo>(Arena*);
template<> ::dan::ModelInfo* Arena::CreateMaybeMessage<::dan::ModelInfo>(Arena*);
template<> ::dan::NodeClassifierInfo* Arena::CreateMaybeMessage<::dan::NodeClassifierInfo>(Arena*);
template<> ::dan::NodeInfo* Arena::CreateMaybeMessage<::dan::NodeInfo>(Arena*);
template<> ::dan::NodeInfoVec* Arena::CreateMaybeMessage<::dan::NodeInfoVec>(Arena*);
template<> ::dan::Record* Arena::CreateMaybeMessage<::dan::Record>(Arena*);
template<> ::dan::RemoteObject* Arena::CreateMaybeMessage<::dan::RemoteObject>(Arena*);
template<> ::dan::RemoteObjectTask* Arena::CreateMaybeMessage<::dan::RemoteObjectTask>(Arena*);
template<> ::dan::RemoteResult* Arena::CreateMaybeMessage<::dan::RemoteResult>(Arena*);
template<> ::dan::RemoteTask* Arena::CreateMaybeMessage<::dan::RemoteTask>(Arena*);
template<> ::dan::RemoteTaskResult* Arena::CreateMaybeMessage<::dan::RemoteTaskResult>(Arena*);
template<> ::dan::Str* Arena::CreateMaybeMessage<::dan::Str>(Arena*);
template<> ::dan::StrVec* Arena::CreateMaybeMessage<::dan::StrVec>(Arena*);
template<> ::dan::Table* Arena::CreateMaybeMessage<::dan::Table>(Arena*);
template<> ::dan::TableInfo* Arena::CreateMaybeMessage<::dan::TableInfo>(Arena*);
template<> ::dan::TablePartition* Arena::CreateMaybeMessage<::dan::TablePartition>(Arena*);
template<> ::dan::TableScan* Arena::CreateMaybeMessage<::dan::TableScan>(Arena*);
template<> ::dan::TestStream* Arena::CreateMaybeMessage<::dan::TestStream>(Arena*);
template<> ::dan::TransferBinary* Arena::CreateMaybeMessage<::dan::TransferBinary>(Arena*);
template<> ::dan::VertexExists* Arena::CreateMaybeMessage<::dan::VertexExists>(Arena*);
template<> ::dan::VertexList* Arena::CreateMaybeMessage<::dan::VertexList>(Arena*);
template<> ::dan::Void* Arena::CreateMaybeMessage<::dan::Void>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dan {

enum Code_Status : int {
  Code_Status_OK = 0,
  Code_Status_ARCHIVE_ERROR = 1,
  Code_Status_RECOVERY_ERROR = 2,
  Code_Status_NODE_REIGISTER_ERROR = 3,
  Code_Status_INVALID_TABLE_TYPE = 4,
  Code_Status_CREATE_TABLE_ERROR = 5,
  Code_Status_DROP_TABLE_ERROR = 6,
  Code_Status_LOAD_TABLE_ERROR = 7,
  Code_Status_DUPLICATED_TABLE_NAME = 8,
  Code_Status_TABLE_NOT_FOUND = 9,
  Code_Status_CREATE_INDEX_ERROR = 10,
  Code_Status_TABLE_PARTITION_ERROR = 11,
  Code_Status_TABLE_ALREADY_PARTITIONED = 12,
  Code_Status_INSERT_RECORD_ERROR = 13,
  Code_Status_TABLE_SCAN_ERROR = 14,
  Code_Status_INDEX_SEARCH_ERROR = 15,
  Code_Status_CREATE_GRAPH_ERROR = 16,
  Code_Status_DROP_GRAPH_ERROR = 17,
  Code_Status_DUPLICATED_GRAPH_NAME = 18,
  Code_Status_GRAPH_NOT_FOUND = 19,
  Code_Status_GRAPH_PARTITION_ERROR = 20,
  Code_Status_GRAPH_ALREADY_PARTIONED = 21,
  Code_Status_GRAPH_MERGE_ERROR = 22,
  Code_Status_DEFINE_VERTEX_ERROR = 23,
  Code_Status_IMPORT_VERTEX_ERROR = 24,
  Code_Status_INSERT_VERTEX_ERROR = 25,
  Code_Status_IMPORT_EDGE_ERROR = 26,
  Code_Status_INSERT_EDGE_ERROR = 27,
  Code_Status_ADJACENT_LIST_ERROR = 28,
  Code_Status_GET_VERTEX_ERROR = 29,
  Code_Status_DATA_TRANSFER_ERROR = 30,
  Code_Status_INVALID_PARTITION_TYPE = 31,
  Code_Status_OBJECT_NOT_FOUND = 32,
  Code_Status_SYSTEM_MONITORING_ERROR = 33,
  Code_Status_CAUSAL_DISCOVERY_ERROR = 34,
  Code_Status_Code_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Code_Status_Code_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Code_Status_IsValid(int value);
constexpr Code_Status Code_Status_Status_MIN = Code_Status_OK;
constexpr Code_Status Code_Status_Status_MAX = Code_Status_CAUSAL_DISCOVERY_ERROR;
constexpr int Code_Status_Status_ARRAYSIZE = Code_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Code_Status_descriptor();
template<typename T>
inline const std::string& Code_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Code_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Code_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Code_Status_descriptor(), enum_t_value);
}
inline bool Code_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Code_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Code_Status>(
    Code_Status_descriptor(), name, value);
}
// ===================================================================

class Void PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.Void) */ {
 public:
  inline Void() : Void(nullptr) {}
  virtual ~Void();

  Void(const Void& from);
  Void(Void&& from) noexcept
    : Void() {
    *this = ::std::move(from);
  }

  inline Void& operator=(const Void& from) {
    CopyFrom(from);
    return *this;
  }
  inline Void& operator=(Void&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Void& default_instance();

  static inline const Void* internal_default_instance() {
    return reinterpret_cast<const Void*>(
               &_Void_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Void& a, Void& b) {
    a.Swap(&b);
  }
  inline void Swap(Void* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Void* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Void* New() const final {
    return CreateMaybeMessage<Void>(nullptr);
  }

  Void* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Void>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Void& from);
  void MergeFrom(const Void& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Void* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.Void";
  }
  protected:
  explicit Void(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dan.Void)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class Int PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.Int) */ {
 public:
  inline Int() : Int(nullptr) {}
  virtual ~Int();

  Int(const Int& from);
  Int(Int&& from) noexcept
    : Int() {
    *this = ::std::move(from);
  }

  inline Int& operator=(const Int& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int& operator=(Int&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Int& default_instance();

  static inline const Int* internal_default_instance() {
    return reinterpret_cast<const Int*>(
               &_Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Int& a, Int& b) {
    a.Swap(&b);
  }
  inline void Swap(Int* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Int* New() const final {
    return CreateMaybeMessage<Int>(nullptr);
  }

  Int* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Int>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Int& from);
  void MergeFrom(const Int& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.Int";
  }
  protected:
  explicit Int(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // int32 v = 1;
  void clear_v();
  ::PROTOBUF_NAMESPACE_ID::int32 v() const;
  void set_v(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_v() const;
  void _internal_set_v(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.Int)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class IntVec PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.IntVec) */ {
 public:
  inline IntVec() : IntVec(nullptr) {}
  virtual ~IntVec();

  IntVec(const IntVec& from);
  IntVec(IntVec&& from) noexcept
    : IntVec() {
    *this = ::std::move(from);
  }

  inline IntVec& operator=(const IntVec& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntVec& operator=(IntVec&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntVec& default_instance();

  static inline const IntVec* internal_default_instance() {
    return reinterpret_cast<const IntVec*>(
               &_IntVec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IntVec& a, IntVec& b) {
    a.Swap(&b);
  }
  inline void Swap(IntVec* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntVec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IntVec* New() const final {
    return CreateMaybeMessage<IntVec>(nullptr);
  }

  IntVec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntVec>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntVec& from);
  void MergeFrom(const IntVec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntVec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.IntVec";
  }
  protected:
  explicit IntVec(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated int32 v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_v(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_v() const;
  void _internal_add_v(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_v();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 v(int index) const;
  void set_v(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_v(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:dan.IntVec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > v_;
  mutable std::atomic<int> _v_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class Long PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.Long) */ {
 public:
  inline Long() : Long(nullptr) {}
  virtual ~Long();

  Long(const Long& from);
  Long(Long&& from) noexcept
    : Long() {
    *this = ::std::move(from);
  }

  inline Long& operator=(const Long& from) {
    CopyFrom(from);
    return *this;
  }
  inline Long& operator=(Long&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Long& default_instance();

  static inline const Long* internal_default_instance() {
    return reinterpret_cast<const Long*>(
               &_Long_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Long& a, Long& b) {
    a.Swap(&b);
  }
  inline void Swap(Long* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Long* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Long* New() const final {
    return CreateMaybeMessage<Long>(nullptr);
  }

  Long* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Long>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Long& from);
  void MergeFrom(const Long& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Long* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.Long";
  }
  protected:
  explicit Long(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // int64 v = 1;
  void clear_v();
  ::PROTOBUF_NAMESPACE_ID::int64 v() const;
  void set_v(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_v() const;
  void _internal_set_v(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.Long)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class LongVec PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.LongVec) */ {
 public:
  inline LongVec() : LongVec(nullptr) {}
  virtual ~LongVec();

  LongVec(const LongVec& from);
  LongVec(LongVec&& from) noexcept
    : LongVec() {
    *this = ::std::move(from);
  }

  inline LongVec& operator=(const LongVec& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongVec& operator=(LongVec&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LongVec& default_instance();

  static inline const LongVec* internal_default_instance() {
    return reinterpret_cast<const LongVec*>(
               &_LongVec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LongVec& a, LongVec& b) {
    a.Swap(&b);
  }
  inline void Swap(LongVec* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongVec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LongVec* New() const final {
    return CreateMaybeMessage<LongVec>(nullptr);
  }

  LongVec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LongVec>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LongVec& from);
  void MergeFrom(const LongVec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongVec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.LongVec";
  }
  protected:
  explicit LongVec(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated int64 v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_v(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_v() const;
  void _internal_add_v(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_v();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 v(int index) const;
  void set_v(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_v(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:dan.LongVec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > v_;
  mutable std::atomic<int> _v_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class Float PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.Float) */ {
 public:
  inline Float() : Float(nullptr) {}
  virtual ~Float();

  Float(const Float& from);
  Float(Float&& from) noexcept
    : Float() {
    *this = ::std::move(from);
  }

  inline Float& operator=(const Float& from) {
    CopyFrom(from);
    return *this;
  }
  inline Float& operator=(Float&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Float& default_instance();

  static inline const Float* internal_default_instance() {
    return reinterpret_cast<const Float*>(
               &_Float_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Float& a, Float& b) {
    a.Swap(&b);
  }
  inline void Swap(Float* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Float* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Float* New() const final {
    return CreateMaybeMessage<Float>(nullptr);
  }

  Float* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Float>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Float& from);
  void MergeFrom(const Float& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Float* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.Float";
  }
  protected:
  explicit Float(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // float v = 1;
  void clear_v();
  float v() const;
  void set_v(float value);
  private:
  float _internal_v() const;
  void _internal_set_v(float value);
  public:

  // @@protoc_insertion_point(class_scope:dan.Float)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class FloatVec PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.FloatVec) */ {
 public:
  inline FloatVec() : FloatVec(nullptr) {}
  virtual ~FloatVec();

  FloatVec(const FloatVec& from);
  FloatVec(FloatVec&& from) noexcept
    : FloatVec() {
    *this = ::std::move(from);
  }

  inline FloatVec& operator=(const FloatVec& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatVec& operator=(FloatVec&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FloatVec& default_instance();

  static inline const FloatVec* internal_default_instance() {
    return reinterpret_cast<const FloatVec*>(
               &_FloatVec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FloatVec& a, FloatVec& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatVec* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatVec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FloatVec* New() const final {
    return CreateMaybeMessage<FloatVec>(nullptr);
  }

  FloatVec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FloatVec>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FloatVec& from);
  void MergeFrom(const FloatVec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatVec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.FloatVec";
  }
  protected:
  explicit FloatVec(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated float v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  float _internal_v(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_v() const;
  void _internal_add_v(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_v();
  public:
  float v(int index) const;
  void set_v(int index, float value);
  void add_v(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:dan.FloatVec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > v_;
  mutable std::atomic<int> _v_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class Double PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.Double) */ {
 public:
  inline Double() : Double(nullptr) {}
  virtual ~Double();

  Double(const Double& from);
  Double(Double&& from) noexcept
    : Double() {
    *this = ::std::move(from);
  }

  inline Double& operator=(const Double& from) {
    CopyFrom(from);
    return *this;
  }
  inline Double& operator=(Double&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Double& default_instance();

  static inline const Double* internal_default_instance() {
    return reinterpret_cast<const Double*>(
               &_Double_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Double& a, Double& b) {
    a.Swap(&b);
  }
  inline void Swap(Double* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Double* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Double* New() const final {
    return CreateMaybeMessage<Double>(nullptr);
  }

  Double* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Double>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Double& from);
  void MergeFrom(const Double& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Double* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.Double";
  }
  protected:
  explicit Double(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // double v = 1;
  void clear_v();
  double v() const;
  void set_v(double value);
  private:
  double _internal_v() const;
  void _internal_set_v(double value);
  public:

  // @@protoc_insertion_point(class_scope:dan.Double)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class DoubleVec PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.DoubleVec) */ {
 public:
  inline DoubleVec() : DoubleVec(nullptr) {}
  virtual ~DoubleVec();

  DoubleVec(const DoubleVec& from);
  DoubleVec(DoubleVec&& from) noexcept
    : DoubleVec() {
    *this = ::std::move(from);
  }

  inline DoubleVec& operator=(const DoubleVec& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleVec& operator=(DoubleVec&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DoubleVec& default_instance();

  static inline const DoubleVec* internal_default_instance() {
    return reinterpret_cast<const DoubleVec*>(
               &_DoubleVec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DoubleVec& a, DoubleVec& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleVec* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleVec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DoubleVec* New() const final {
    return CreateMaybeMessage<DoubleVec>(nullptr);
  }

  DoubleVec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DoubleVec>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DoubleVec& from);
  void MergeFrom(const DoubleVec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleVec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.DoubleVec";
  }
  protected:
  explicit DoubleVec(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated double v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  double _internal_v(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_v() const;
  void _internal_add_v(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_v();
  public:
  double v(int index) const;
  void set_v(int index, double value);
  void add_v(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:dan.DoubleVec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > v_;
  mutable std::atomic<int> _v_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class Str PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.Str) */ {
 public:
  inline Str() : Str(nullptr) {}
  virtual ~Str();

  Str(const Str& from);
  Str(Str&& from) noexcept
    : Str() {
    *this = ::std::move(from);
  }

  inline Str& operator=(const Str& from) {
    CopyFrom(from);
    return *this;
  }
  inline Str& operator=(Str&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Str& default_instance();

  static inline const Str* internal_default_instance() {
    return reinterpret_cast<const Str*>(
               &_Str_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Str& a, Str& b) {
    a.Swap(&b);
  }
  inline void Swap(Str* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Str* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Str* New() const final {
    return CreateMaybeMessage<Str>(nullptr);
  }

  Str* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Str>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Str& from);
  void MergeFrom(const Str& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Str* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.Str";
  }
  protected:
  explicit Str(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // string v = 1;
  void clear_v();
  const std::string& v() const;
  void set_v(const std::string& value);
  void set_v(std::string&& value);
  void set_v(const char* value);
  void set_v(const char* value, size_t size);
  std::string* mutable_v();
  std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // @@protoc_insertion_point(class_scope:dan.Str)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class StrVec PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.StrVec) */ {
 public:
  inline StrVec() : StrVec(nullptr) {}
  virtual ~StrVec();

  StrVec(const StrVec& from);
  StrVec(StrVec&& from) noexcept
    : StrVec() {
    *this = ::std::move(from);
  }

  inline StrVec& operator=(const StrVec& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrVec& operator=(StrVec&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StrVec& default_instance();

  static inline const StrVec* internal_default_instance() {
    return reinterpret_cast<const StrVec*>(
               &_StrVec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StrVec& a, StrVec& b) {
    a.Swap(&b);
  }
  inline void Swap(StrVec* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrVec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StrVec* New() const final {
    return CreateMaybeMessage<StrVec>(nullptr);
  }

  StrVec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StrVec>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StrVec& from);
  void MergeFrom(const StrVec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrVec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.StrVec";
  }
  protected:
  explicit StrVec(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated string v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  const std::string& v(int index) const;
  std::string* mutable_v(int index);
  void set_v(int index, const std::string& value);
  void set_v(int index, std::string&& value);
  void set_v(int index, const char* value);
  void set_v(int index, const char* value, size_t size);
  std::string* add_v();
  void add_v(const std::string& value);
  void add_v(std::string&& value);
  void add_v(const char* value);
  void add_v(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& v() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_v();
  private:
  const std::string& _internal_v(int index) const;
  std::string* _internal_add_v();
  public:

  // @@protoc_insertion_point(class_scope:dan.StrVec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class Eval PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.Eval) */ {
 public:
  inline Eval() : Eval(nullptr) {}
  virtual ~Eval();

  Eval(const Eval& from);
  Eval(Eval&& from) noexcept
    : Eval() {
    *this = ::std::move(from);
  }

  inline Eval& operator=(const Eval& from) {
    CopyFrom(from);
    return *this;
  }
  inline Eval& operator=(Eval&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Eval& default_instance();

  enum VCase {
    kL = 1,
    kD = 2,
    kS = 3,
    kB = 4,
    kIl = 5,
    kLl = 6,
    kFl = 7,
    kDl = 8,
    V_NOT_SET = 0,
  };

  static inline const Eval* internal_default_instance() {
    return reinterpret_cast<const Eval*>(
               &_Eval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Eval& a, Eval& b) {
    a.Swap(&b);
  }
  inline void Swap(Eval* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Eval* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Eval* New() const final {
    return CreateMaybeMessage<Eval>(nullptr);
  }

  Eval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Eval>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Eval& from);
  void MergeFrom(const Eval& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Eval* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.Eval";
  }
  protected:
  explicit Eval(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLFieldNumber = 1,
    kDFieldNumber = 2,
    kSFieldNumber = 3,
    kBFieldNumber = 4,
    kIlFieldNumber = 5,
    kLlFieldNumber = 6,
    kFlFieldNumber = 7,
    kDlFieldNumber = 8,
  };
  // int64 l = 1;
  private:
  bool _internal_has_l() const;
  public:
  void clear_l();
  ::PROTOBUF_NAMESPACE_ID::int64 l() const;
  void set_l(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_l() const;
  void _internal_set_l(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double d = 2;
  private:
  bool _internal_has_d() const;
  public:
  void clear_d();
  double d() const;
  void set_d(double value);
  private:
  double _internal_d() const;
  void _internal_set_d(double value);
  public:

  // string s = 3;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  const std::string& s() const;
  void set_s(const std::string& value);
  void set_s(std::string&& value);
  void set_s(const char* value);
  void set_s(const char* value, size_t size);
  std::string* mutable_s();
  std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // bool b = 4;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  bool b() const;
  void set_b(bool value);
  private:
  bool _internal_b() const;
  void _internal_set_b(bool value);
  public:

  // .dan.IntVec il = 5;
  bool has_il() const;
  private:
  bool _internal_has_il() const;
  public:
  void clear_il();
  const ::dan::IntVec& il() const;
  ::dan::IntVec* release_il();
  ::dan::IntVec* mutable_il();
  void set_allocated_il(::dan::IntVec* il);
  private:
  const ::dan::IntVec& _internal_il() const;
  ::dan::IntVec* _internal_mutable_il();
  public:
  void unsafe_arena_set_allocated_il(
      ::dan::IntVec* il);
  ::dan::IntVec* unsafe_arena_release_il();

  // .dan.LongVec ll = 6;
  bool has_ll() const;
  private:
  bool _internal_has_ll() const;
  public:
  void clear_ll();
  const ::dan::LongVec& ll() const;
  ::dan::LongVec* release_ll();
  ::dan::LongVec* mutable_ll();
  void set_allocated_ll(::dan::LongVec* ll);
  private:
  const ::dan::LongVec& _internal_ll() const;
  ::dan::LongVec* _internal_mutable_ll();
  public:
  void unsafe_arena_set_allocated_ll(
      ::dan::LongVec* ll);
  ::dan::LongVec* unsafe_arena_release_ll();

  // .dan.FloatVec fl = 7;
  bool has_fl() const;
  private:
  bool _internal_has_fl() const;
  public:
  void clear_fl();
  const ::dan::FloatVec& fl() const;
  ::dan::FloatVec* release_fl();
  ::dan::FloatVec* mutable_fl();
  void set_allocated_fl(::dan::FloatVec* fl);
  private:
  const ::dan::FloatVec& _internal_fl() const;
  ::dan::FloatVec* _internal_mutable_fl();
  public:
  void unsafe_arena_set_allocated_fl(
      ::dan::FloatVec* fl);
  ::dan::FloatVec* unsafe_arena_release_fl();

  // .dan.DoubleVec dl = 8;
  bool has_dl() const;
  private:
  bool _internal_has_dl() const;
  public:
  void clear_dl();
  const ::dan::DoubleVec& dl() const;
  ::dan::DoubleVec* release_dl();
  ::dan::DoubleVec* mutable_dl();
  void set_allocated_dl(::dan::DoubleVec* dl);
  private:
  const ::dan::DoubleVec& _internal_dl() const;
  ::dan::DoubleVec* _internal_mutable_dl();
  public:
  void unsafe_arena_set_allocated_dl(
      ::dan::DoubleVec* dl);
  ::dan::DoubleVec* unsafe_arena_release_dl();

  void clear_v();
  VCase v_case() const;
  // @@protoc_insertion_point(class_scope:dan.Eval)
 private:
  class _Internal;
  void set_has_l();
  void set_has_d();
  void set_has_s();
  void set_has_b();
  void set_has_il();
  void set_has_ll();
  void set_has_fl();
  void set_has_dl();

  inline bool has_v() const;
  inline void clear_has_v();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union VUnion {
    VUnion() {}
    ::PROTOBUF_NAMESPACE_ID::int64 l_;
    double d_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
    bool b_;
    ::dan::IntVec* il_;
    ::dan::LongVec* ll_;
    ::dan::FloatVec* fl_;
    ::dan::DoubleVec* dl_;
  } v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class Record PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.Record) */ {
 public:
  inline Record() : Record(nullptr) {}
  virtual ~Record();

  Record(const Record& from);
  Record(Record&& from) noexcept
    : Record() {
    *this = ::std::move(from);
  }

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }
  inline Record& operator=(Record&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Record& default_instance();

  static inline const Record* internal_default_instance() {
    return reinterpret_cast<const Record*>(
               &_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Record& a, Record& b) {
    a.Swap(&b);
  }
  inline void Swap(Record* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Record* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Record* New() const final {
    return CreateMaybeMessage<Record>(nullptr);
  }

  Record* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Record>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Record* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.Record";
  }
  protected:
  explicit Record(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated .dan.Eval v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  ::dan::Eval* mutable_v(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Eval >*
      mutable_v();
  private:
  const ::dan::Eval& _internal_v(int index) const;
  ::dan::Eval* _internal_add_v();
  public:
  const ::dan::Eval& v(int index) const;
  ::dan::Eval* add_v();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Eval >&
      v() const;

  // @@protoc_insertion_point(class_scope:dan.Record)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Eval > v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class Table PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.Table) */ {
 public:
  inline Table() : Table(nullptr) {}
  virtual ~Table();

  Table(const Table& from);
  Table(Table&& from) noexcept
    : Table() {
    *this = ::std::move(from);
  }

  inline Table& operator=(const Table& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table& operator=(Table&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Table& default_instance();

  static inline const Table* internal_default_instance() {
    return reinterpret_cast<const Table*>(
               &_Table_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Table& a, Table& b) {
    a.Swap(&b);
  }
  inline void Swap(Table* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Table* New() const final {
    return CreateMaybeMessage<Table>(nullptr);
  }

  Table* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Table>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Table& from);
  void MergeFrom(const Table& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Table* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.Table";
  }
  protected:
  explicit Table(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated .dan.Record v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  ::dan::Record* mutable_v(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Record >*
      mutable_v();
  private:
  const ::dan::Record& _internal_v(int index) const;
  ::dan::Record* _internal_add_v();
  public:
  const ::dan::Record& v(int index) const;
  ::dan::Record* add_v();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Record >&
      v() const;

  // @@protoc_insertion_point(class_scope:dan.Table)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Record > v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class Code PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.Code) */ {
 public:
  inline Code() : Code(nullptr) {}
  virtual ~Code();

  Code(const Code& from);
  Code(Code&& from) noexcept
    : Code() {
    *this = ::std::move(from);
  }

  inline Code& operator=(const Code& from) {
    CopyFrom(from);
    return *this;
  }
  inline Code& operator=(Code&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Code& default_instance();

  static inline const Code* internal_default_instance() {
    return reinterpret_cast<const Code*>(
               &_Code_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Code& a, Code& b) {
    a.Swap(&b);
  }
  inline void Swap(Code* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Code* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Code* New() const final {
    return CreateMaybeMessage<Code>(nullptr);
  }

  Code* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Code>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Code& from);
  void MergeFrom(const Code& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Code* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.Code";
  }
  protected:
  explicit Code(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Code_Status Status;
  static constexpr Status OK =
    Code_Status_OK;
  static constexpr Status ARCHIVE_ERROR =
    Code_Status_ARCHIVE_ERROR;
  static constexpr Status RECOVERY_ERROR =
    Code_Status_RECOVERY_ERROR;
  static constexpr Status NODE_REIGISTER_ERROR =
    Code_Status_NODE_REIGISTER_ERROR;
  static constexpr Status INVALID_TABLE_TYPE =
    Code_Status_INVALID_TABLE_TYPE;
  static constexpr Status CREATE_TABLE_ERROR =
    Code_Status_CREATE_TABLE_ERROR;
  static constexpr Status DROP_TABLE_ERROR =
    Code_Status_DROP_TABLE_ERROR;
  static constexpr Status LOAD_TABLE_ERROR =
    Code_Status_LOAD_TABLE_ERROR;
  static constexpr Status DUPLICATED_TABLE_NAME =
    Code_Status_DUPLICATED_TABLE_NAME;
  static constexpr Status TABLE_NOT_FOUND =
    Code_Status_TABLE_NOT_FOUND;
  static constexpr Status CREATE_INDEX_ERROR =
    Code_Status_CREATE_INDEX_ERROR;
  static constexpr Status TABLE_PARTITION_ERROR =
    Code_Status_TABLE_PARTITION_ERROR;
  static constexpr Status TABLE_ALREADY_PARTITIONED =
    Code_Status_TABLE_ALREADY_PARTITIONED;
  static constexpr Status INSERT_RECORD_ERROR =
    Code_Status_INSERT_RECORD_ERROR;
  static constexpr Status TABLE_SCAN_ERROR =
    Code_Status_TABLE_SCAN_ERROR;
  static constexpr Status INDEX_SEARCH_ERROR =
    Code_Status_INDEX_SEARCH_ERROR;
  static constexpr Status CREATE_GRAPH_ERROR =
    Code_Status_CREATE_GRAPH_ERROR;
  static constexpr Status DROP_GRAPH_ERROR =
    Code_Status_DROP_GRAPH_ERROR;
  static constexpr Status DUPLICATED_GRAPH_NAME =
    Code_Status_DUPLICATED_GRAPH_NAME;
  static constexpr Status GRAPH_NOT_FOUND =
    Code_Status_GRAPH_NOT_FOUND;
  static constexpr Status GRAPH_PARTITION_ERROR =
    Code_Status_GRAPH_PARTITION_ERROR;
  static constexpr Status GRAPH_ALREADY_PARTIONED =
    Code_Status_GRAPH_ALREADY_PARTIONED;
  static constexpr Status GRAPH_MERGE_ERROR =
    Code_Status_GRAPH_MERGE_ERROR;
  static constexpr Status DEFINE_VERTEX_ERROR =
    Code_Status_DEFINE_VERTEX_ERROR;
  static constexpr Status IMPORT_VERTEX_ERROR =
    Code_Status_IMPORT_VERTEX_ERROR;
  static constexpr Status INSERT_VERTEX_ERROR =
    Code_Status_INSERT_VERTEX_ERROR;
  static constexpr Status IMPORT_EDGE_ERROR =
    Code_Status_IMPORT_EDGE_ERROR;
  static constexpr Status INSERT_EDGE_ERROR =
    Code_Status_INSERT_EDGE_ERROR;
  static constexpr Status ADJACENT_LIST_ERROR =
    Code_Status_ADJACENT_LIST_ERROR;
  static constexpr Status GET_VERTEX_ERROR =
    Code_Status_GET_VERTEX_ERROR;
  static constexpr Status DATA_TRANSFER_ERROR =
    Code_Status_DATA_TRANSFER_ERROR;
  static constexpr Status INVALID_PARTITION_TYPE =
    Code_Status_INVALID_PARTITION_TYPE;
  static constexpr Status OBJECT_NOT_FOUND =
    Code_Status_OBJECT_NOT_FOUND;
  static constexpr Status SYSTEM_MONITORING_ERROR =
    Code_Status_SYSTEM_MONITORING_ERROR;
  static constexpr Status CAUSAL_DISCOVERY_ERROR =
    Code_Status_CAUSAL_DISCOVERY_ERROR;
  static inline bool Status_IsValid(int value) {
    return Code_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    Code_Status_Status_MIN;
  static constexpr Status Status_MAX =
    Code_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    Code_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return Code_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return Code_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return Code_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // .dan.Code.Status msg = 1;
  void clear_msg();
  ::dan::Code_Status msg() const;
  void set_msg(::dan::Code_Status value);
  private:
  ::dan::Code_Status _internal_msg() const;
  void _internal_set_msg(::dan::Code_Status value);
  public:

  // @@protoc_insertion_point(class_scope:dan.Code)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.NodeInfo) */ {
 public:
  inline NodeInfo() : NodeInfo(nullptr) {}
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeInfo& default_instance();

  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const final {
    return CreateMaybeMessage<NodeInfo>(nullptr);
  }

  NodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.NodeInfo";
  }
  protected:
  explicit NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 2,
    kIdFieldNumber = 1,
    kPortFieldNumber = 3,
    kHeadFieldNumber = 4,
  };
  // string host = 2;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 port = 3;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool head = 4;
  void clear_head();
  bool head() const;
  void set_head(bool value);
  private:
  bool _internal_head() const;
  void _internal_set_head(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dan.NodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  bool head_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class NodeInfoVec PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.NodeInfoVec) */ {
 public:
  inline NodeInfoVec() : NodeInfoVec(nullptr) {}
  virtual ~NodeInfoVec();

  NodeInfoVec(const NodeInfoVec& from);
  NodeInfoVec(NodeInfoVec&& from) noexcept
    : NodeInfoVec() {
    *this = ::std::move(from);
  }

  inline NodeInfoVec& operator=(const NodeInfoVec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfoVec& operator=(NodeInfoVec&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeInfoVec& default_instance();

  static inline const NodeInfoVec* internal_default_instance() {
    return reinterpret_cast<const NodeInfoVec*>(
               &_NodeInfoVec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(NodeInfoVec& a, NodeInfoVec& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfoVec* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfoVec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeInfoVec* New() const final {
    return CreateMaybeMessage<NodeInfoVec>(nullptr);
  }

  NodeInfoVec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfoVec>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeInfoVec& from);
  void MergeFrom(const NodeInfoVec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfoVec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.NodeInfoVec";
  }
  protected:
  explicit NodeInfoVec(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated .dan.NodeInfo v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  ::dan::NodeInfo* mutable_v(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::NodeInfo >*
      mutable_v();
  private:
  const ::dan::NodeInfo& _internal_v(int index) const;
  ::dan::NodeInfo* _internal_add_v();
  public:
  const ::dan::NodeInfo& v(int index) const;
  ::dan::NodeInfo* add_v();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::NodeInfo >&
      v() const;

  // @@protoc_insertion_point(class_scope:dan.NodeInfoVec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::NodeInfo > v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class Field PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.Field) */ {
 public:
  inline Field() : Field(nullptr) {}
  virtual ~Field();

  Field(const Field& from);
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Field& operator=(Field&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Field& default_instance();

  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }
  inline void Swap(Field* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Field* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Field* New() const final {
    return CreateMaybeMessage<Field>(nullptr);
  }

  Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Field>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Field* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.Field";
  }
  protected:
  explicit Field(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFnameFieldNumber = 1,
    kFtypeFieldNumber = 2,
  };
  // string fname = 1;
  void clear_fname();
  const std::string& fname() const;
  void set_fname(const std::string& value);
  void set_fname(std::string&& value);
  void set_fname(const char* value);
  void set_fname(const char* value, size_t size);
  std::string* mutable_fname();
  std::string* release_fname();
  void set_allocated_fname(std::string* fname);
  private:
  const std::string& _internal_fname() const;
  void _internal_set_fname(const std::string& value);
  std::string* _internal_mutable_fname();
  public:

  // string ftype = 2;
  void clear_ftype();
  const std::string& ftype() const;
  void set_ftype(const std::string& value);
  void set_ftype(std::string&& value);
  void set_ftype(const char* value);
  void set_ftype(const char* value, size_t size);
  std::string* mutable_ftype();
  std::string* release_ftype();
  void set_allocated_ftype(std::string* ftype);
  private:
  const std::string& _internal_ftype() const;
  void _internal_set_ftype(const std::string& value);
  std::string* _internal_mutable_ftype();
  public:

  // @@protoc_insertion_point(class_scope:dan.Field)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ftype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class CreateTable PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.CreateTable) */ {
 public:
  inline CreateTable() : CreateTable(nullptr) {}
  virtual ~CreateTable();

  CreateTable(const CreateTable& from);
  CreateTable(CreateTable&& from) noexcept
    : CreateTable() {
    *this = ::std::move(from);
  }

  inline CreateTable& operator=(const CreateTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTable& operator=(CreateTable&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateTable& default_instance();

  static inline const CreateTable* internal_default_instance() {
    return reinterpret_cast<const CreateTable*>(
               &_CreateTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CreateTable& a, CreateTable& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTable* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTable* New() const final {
    return CreateMaybeMessage<CreateTable>(nullptr);
  }

  CreateTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTable>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateTable& from);
  void MergeFrom(const CreateTable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.CreateTable";
  }
  protected:
  explicit CreateTable(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 5,
    kTnameFieldNumber = 1,
    kTtypeFieldNumber = 2,
    kIncFidFieldNumber = 3,
    kIncStartFieldNumber = 4,
  };
  // repeated .dan.Field schema = 5;
  int schema_size() const;
  private:
  int _internal_schema_size() const;
  public:
  void clear_schema();
  ::dan::Field* mutable_schema(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >*
      mutable_schema();
  private:
  const ::dan::Field& _internal_schema(int index) const;
  ::dan::Field* _internal_add_schema();
  public:
  const ::dan::Field& schema(int index) const;
  ::dan::Field* add_schema();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >&
      schema() const;

  // string tname = 1;
  void clear_tname();
  const std::string& tname() const;
  void set_tname(const std::string& value);
  void set_tname(std::string&& value);
  void set_tname(const char* value);
  void set_tname(const char* value, size_t size);
  std::string* mutable_tname();
  std::string* release_tname();
  void set_allocated_tname(std::string* tname);
  private:
  const std::string& _internal_tname() const;
  void _internal_set_tname(const std::string& value);
  std::string* _internal_mutable_tname();
  public:

  // string ttype = 2;
  void clear_ttype();
  const std::string& ttype() const;
  void set_ttype(const std::string& value);
  void set_ttype(std::string&& value);
  void set_ttype(const char* value);
  void set_ttype(const char* value, size_t size);
  std::string* mutable_ttype();
  std::string* release_ttype();
  void set_allocated_ttype(std::string* ttype);
  private:
  const std::string& _internal_ttype() const;
  void _internal_set_ttype(const std::string& value);
  std::string* _internal_mutable_ttype();
  public:

  // int32 inc_fid = 3;
  void clear_inc_fid();
  ::PROTOBUF_NAMESPACE_ID::int32 inc_fid() const;
  void set_inc_fid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_inc_fid() const;
  void _internal_set_inc_fid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 inc_start = 4;
  void clear_inc_start();
  ::PROTOBUF_NAMESPACE_ID::int32 inc_start() const;
  void set_inc_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_inc_start() const;
  void _internal_set_inc_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.CreateTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field > schema_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ttype_;
  ::PROTOBUF_NAMESPACE_ID::int32 inc_fid_;
  ::PROTOBUF_NAMESPACE_ID::int32 inc_start_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class CreateIndex PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.CreateIndex) */ {
 public:
  inline CreateIndex() : CreateIndex(nullptr) {}
  virtual ~CreateIndex();

  CreateIndex(const CreateIndex& from);
  CreateIndex(CreateIndex&& from) noexcept
    : CreateIndex() {
    *this = ::std::move(from);
  }

  inline CreateIndex& operator=(const CreateIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIndex& operator=(CreateIndex&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateIndex& default_instance();

  static inline const CreateIndex* internal_default_instance() {
    return reinterpret_cast<const CreateIndex*>(
               &_CreateIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateIndex& a, CreateIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateIndex* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateIndex* New() const final {
    return CreateMaybeMessage<CreateIndex>(nullptr);
  }

  CreateIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateIndex>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateIndex& from);
  void MergeFrom(const CreateIndex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIndex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.CreateIndex";
  }
  protected:
  explicit CreateIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTnameFieldNumber = 1,
    kFidFieldNumber = 2,
    kUniqueFieldNumber = 3,
  };
  // string tname = 1;
  void clear_tname();
  const std::string& tname() const;
  void set_tname(const std::string& value);
  void set_tname(std::string&& value);
  void set_tname(const char* value);
  void set_tname(const char* value, size_t size);
  std::string* mutable_tname();
  std::string* release_tname();
  void set_allocated_tname(std::string* tname);
  private:
  const std::string& _internal_tname() const;
  void _internal_set_tname(const std::string& value);
  std::string* _internal_mutable_tname();
  public:

  // int32 fid = 2;
  void clear_fid();
  ::PROTOBUF_NAMESPACE_ID::int32 fid() const;
  void set_fid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fid() const;
  void _internal_set_fid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool unique = 3;
  void clear_unique();
  bool unique() const;
  void set_unique(bool value);
  private:
  bool _internal_unique() const;
  void _internal_set_unique(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dan.CreateIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tname_;
  ::PROTOBUF_NAMESPACE_ID::int32 fid_;
  bool unique_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class TablePartition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.TablePartition) */ {
 public:
  inline TablePartition() : TablePartition(nullptr) {}
  virtual ~TablePartition();

  TablePartition(const TablePartition& from);
  TablePartition(TablePartition&& from) noexcept
    : TablePartition() {
    *this = ::std::move(from);
  }

  inline TablePartition& operator=(const TablePartition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TablePartition& operator=(TablePartition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TablePartition& default_instance();

  static inline const TablePartition* internal_default_instance() {
    return reinterpret_cast<const TablePartition*>(
               &_TablePartition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TablePartition& a, TablePartition& b) {
    a.Swap(&b);
  }
  inline void Swap(TablePartition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TablePartition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TablePartition* New() const final {
    return CreateMaybeMessage<TablePartition>(nullptr);
  }

  TablePartition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TablePartition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TablePartition& from);
  void MergeFrom(const TablePartition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TablePartition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.TablePartition";
  }
  protected:
  explicit TablePartition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTnameFieldNumber = 1,
    kNodesFieldNumber = 3,
    kFidFieldNumber = 2,
  };
  // string tname = 1;
  void clear_tname();
  const std::string& tname() const;
  void set_tname(const std::string& value);
  void set_tname(std::string&& value);
  void set_tname(const char* value);
  void set_tname(const char* value, size_t size);
  std::string* mutable_tname();
  std::string* release_tname();
  void set_allocated_tname(std::string* tname);
  private:
  const std::string& _internal_tname() const;
  void _internal_set_tname(const std::string& value);
  std::string* _internal_mutable_tname();
  public:

  // .dan.StrVec nodes = 3;
  bool has_nodes() const;
  private:
  bool _internal_has_nodes() const;
  public:
  void clear_nodes();
  const ::dan::StrVec& nodes() const;
  ::dan::StrVec* release_nodes();
  ::dan::StrVec* mutable_nodes();
  void set_allocated_nodes(::dan::StrVec* nodes);
  private:
  const ::dan::StrVec& _internal_nodes() const;
  ::dan::StrVec* _internal_mutable_nodes();
  public:
  void unsafe_arena_set_allocated_nodes(
      ::dan::StrVec* nodes);
  ::dan::StrVec* unsafe_arena_release_nodes();

  // int32 fid = 2;
  void clear_fid();
  ::PROTOBUF_NAMESPACE_ID::int32 fid() const;
  void set_fid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fid() const;
  void _internal_set_fid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.TablePartition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tname_;
  ::dan::StrVec* nodes_;
  ::PROTOBUF_NAMESPACE_ID::int32 fid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class TableInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.TableInfo) */ {
 public:
  inline TableInfo() : TableInfo(nullptr) {}
  virtual ~TableInfo();

  TableInfo(const TableInfo& from);
  TableInfo(TableInfo&& from) noexcept
    : TableInfo() {
    *this = ::std::move(from);
  }

  inline TableInfo& operator=(const TableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableInfo& operator=(TableInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TableInfo& default_instance();

  static inline const TableInfo* internal_default_instance() {
    return reinterpret_cast<const TableInfo*>(
               &_TableInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TableInfo& a, TableInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TableInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableInfo* New() const final {
    return CreateMaybeMessage<TableInfo>(nullptr);
  }

  TableInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TableInfo& from);
  void MergeFrom(const TableInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.TableInfo";
  }
  protected:
  explicit TableInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 1,
    kNodesFieldNumber = 2,
    kPartFidFieldNumber = 3,
  };
  // .dan.StrVec fields = 1;
  bool has_fields() const;
  private:
  bool _internal_has_fields() const;
  public:
  void clear_fields();
  const ::dan::StrVec& fields() const;
  ::dan::StrVec* release_fields();
  ::dan::StrVec* mutable_fields();
  void set_allocated_fields(::dan::StrVec* fields);
  private:
  const ::dan::StrVec& _internal_fields() const;
  ::dan::StrVec* _internal_mutable_fields();
  public:
  void unsafe_arena_set_allocated_fields(
      ::dan::StrVec* fields);
  ::dan::StrVec* unsafe_arena_release_fields();

  // .dan.StrVec nodes = 2;
  bool has_nodes() const;
  private:
  bool _internal_has_nodes() const;
  public:
  void clear_nodes();
  const ::dan::StrVec& nodes() const;
  ::dan::StrVec* release_nodes();
  ::dan::StrVec* mutable_nodes();
  void set_allocated_nodes(::dan::StrVec* nodes);
  private:
  const ::dan::StrVec& _internal_nodes() const;
  ::dan::StrVec* _internal_mutable_nodes();
  public:
  void unsafe_arena_set_allocated_nodes(
      ::dan::StrVec* nodes);
  ::dan::StrVec* unsafe_arena_release_nodes();

  // int32 part_fid = 3;
  void clear_part_fid();
  ::PROTOBUF_NAMESPACE_ID::int32 part_fid() const;
  void set_part_fid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_part_fid() const;
  void _internal_set_part_fid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.TableInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::dan::StrVec* fields_;
  ::dan::StrVec* nodes_;
  ::PROTOBUF_NAMESPACE_ID::int32 part_fid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class CreateGraph PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.CreateGraph) */ {
 public:
  inline CreateGraph() : CreateGraph(nullptr) {}
  virtual ~CreateGraph();

  CreateGraph(const CreateGraph& from);
  CreateGraph(CreateGraph&& from) noexcept
    : CreateGraph() {
    *this = ::std::move(from);
  }

  inline CreateGraph& operator=(const CreateGraph& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGraph& operator=(CreateGraph&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateGraph& default_instance();

  static inline const CreateGraph* internal_default_instance() {
    return reinterpret_cast<const CreateGraph*>(
               &_CreateGraph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CreateGraph& a, CreateGraph& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGraph* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGraph* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateGraph* New() const final {
    return CreateMaybeMessage<CreateGraph>(nullptr);
  }

  CreateGraph* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateGraph>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateGraph& from);
  void MergeFrom(const CreateGraph& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGraph* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.CreateGraph";
  }
  protected:
  explicit CreateGraph(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVschemaFieldNumber = 3,
    kEschemaFieldNumber = 6,
    kGnameFieldNumber = 1,
    kVpnameFieldNumber = 2,
    kVptypeFieldNumber = 5,
    kEptypeFieldNumber = 7,
    kNodesFieldNumber = 12,
    kVpfidFieldNumber = 4,
    kIncomingFieldNumber = 8,
    kMergeFieldNumber = 9,
    kIsPartitionFieldNumber = 10,
    kPartTypeFieldNumber = 11,
  };
  // repeated .dan.Field vschema = 3;
  int vschema_size() const;
  private:
  int _internal_vschema_size() const;
  public:
  void clear_vschema();
  ::dan::Field* mutable_vschema(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >*
      mutable_vschema();
  private:
  const ::dan::Field& _internal_vschema(int index) const;
  ::dan::Field* _internal_add_vschema();
  public:
  const ::dan::Field& vschema(int index) const;
  ::dan::Field* add_vschema();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >&
      vschema() const;

  // repeated .dan.Field eschema = 6;
  int eschema_size() const;
  private:
  int _internal_eschema_size() const;
  public:
  void clear_eschema();
  ::dan::Field* mutable_eschema(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >*
      mutable_eschema();
  private:
  const ::dan::Field& _internal_eschema(int index) const;
  ::dan::Field* _internal_add_eschema();
  public:
  const ::dan::Field& eschema(int index) const;
  ::dan::Field* add_eschema();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >&
      eschema() const;

  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // string vpname = 2;
  void clear_vpname();
  const std::string& vpname() const;
  void set_vpname(const std::string& value);
  void set_vpname(std::string&& value);
  void set_vpname(const char* value);
  void set_vpname(const char* value, size_t size);
  std::string* mutable_vpname();
  std::string* release_vpname();
  void set_allocated_vpname(std::string* vpname);
  private:
  const std::string& _internal_vpname() const;
  void _internal_set_vpname(const std::string& value);
  std::string* _internal_mutable_vpname();
  public:

  // string vptype = 5;
  void clear_vptype();
  const std::string& vptype() const;
  void set_vptype(const std::string& value);
  void set_vptype(std::string&& value);
  void set_vptype(const char* value);
  void set_vptype(const char* value, size_t size);
  std::string* mutable_vptype();
  std::string* release_vptype();
  void set_allocated_vptype(std::string* vptype);
  private:
  const std::string& _internal_vptype() const;
  void _internal_set_vptype(const std::string& value);
  std::string* _internal_mutable_vptype();
  public:

  // string eptype = 7;
  void clear_eptype();
  const std::string& eptype() const;
  void set_eptype(const std::string& value);
  void set_eptype(std::string&& value);
  void set_eptype(const char* value);
  void set_eptype(const char* value, size_t size);
  std::string* mutable_eptype();
  std::string* release_eptype();
  void set_allocated_eptype(std::string* eptype);
  private:
  const std::string& _internal_eptype() const;
  void _internal_set_eptype(const std::string& value);
  std::string* _internal_mutable_eptype();
  public:

  // .dan.StrVec nodes = 12;
  bool has_nodes() const;
  private:
  bool _internal_has_nodes() const;
  public:
  void clear_nodes();
  const ::dan::StrVec& nodes() const;
  ::dan::StrVec* release_nodes();
  ::dan::StrVec* mutable_nodes();
  void set_allocated_nodes(::dan::StrVec* nodes);
  private:
  const ::dan::StrVec& _internal_nodes() const;
  ::dan::StrVec* _internal_mutable_nodes();
  public:
  void unsafe_arena_set_allocated_nodes(
      ::dan::StrVec* nodes);
  ::dan::StrVec* unsafe_arena_release_nodes();

  // int32 vpfid = 4;
  void clear_vpfid();
  ::PROTOBUF_NAMESPACE_ID::int32 vpfid() const;
  void set_vpfid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vpfid() const;
  void _internal_set_vpfid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool incoming = 8;
  void clear_incoming();
  bool incoming() const;
  void set_incoming(bool value);
  private:
  bool _internal_incoming() const;
  void _internal_set_incoming(bool value);
  public:

  // bool merge = 9;
  void clear_merge();
  bool merge() const;
  void set_merge(bool value);
  private:
  bool _internal_merge() const;
  void _internal_set_merge(bool value);
  public:

  // bool is_partition = 10;
  void clear_is_partition();
  bool is_partition() const;
  void set_is_partition(bool value);
  private:
  bool _internal_is_partition() const;
  void _internal_set_is_partition(bool value);
  public:

  // int32 part_type = 11;
  void clear_part_type();
  ::PROTOBUF_NAMESPACE_ID::int32 part_type() const;
  void set_part_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_part_type() const;
  void _internal_set_part_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.CreateGraph)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field > vschema_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field > eschema_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vpname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vptype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eptype_;
  ::dan::StrVec* nodes_;
  ::PROTOBUF_NAMESPACE_ID::int32 vpfid_;
  bool incoming_;
  bool merge_;
  bool is_partition_;
  ::PROTOBUF_NAMESPACE_ID::int32 part_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GraphPartition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.GraphPartition) */ {
 public:
  inline GraphPartition() : GraphPartition(nullptr) {}
  virtual ~GraphPartition();

  GraphPartition(const GraphPartition& from);
  GraphPartition(GraphPartition&& from) noexcept
    : GraphPartition() {
    *this = ::std::move(from);
  }

  inline GraphPartition& operator=(const GraphPartition& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphPartition& operator=(GraphPartition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GraphPartition& default_instance();

  static inline const GraphPartition* internal_default_instance() {
    return reinterpret_cast<const GraphPartition*>(
               &_GraphPartition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GraphPartition& a, GraphPartition& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphPartition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphPartition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GraphPartition* New() const final {
    return CreateMaybeMessage<GraphPartition>(nullptr);
  }

  GraphPartition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GraphPartition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GraphPartition& from);
  void MergeFrom(const GraphPartition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphPartition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.GraphPartition";
  }
  protected:
  explicit GraphPartition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kPtypeFieldNumber = 2,
    kNodesFieldNumber = 3,
    kDopFieldNumber = 4,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // string ptype = 2;
  void clear_ptype();
  const std::string& ptype() const;
  void set_ptype(const std::string& value);
  void set_ptype(std::string&& value);
  void set_ptype(const char* value);
  void set_ptype(const char* value, size_t size);
  std::string* mutable_ptype();
  std::string* release_ptype();
  void set_allocated_ptype(std::string* ptype);
  private:
  const std::string& _internal_ptype() const;
  void _internal_set_ptype(const std::string& value);
  std::string* _internal_mutable_ptype();
  public:

  // .dan.StrVec nodes = 3;
  bool has_nodes() const;
  private:
  bool _internal_has_nodes() const;
  public:
  void clear_nodes();
  const ::dan::StrVec& nodes() const;
  ::dan::StrVec* release_nodes();
  ::dan::StrVec* mutable_nodes();
  void set_allocated_nodes(::dan::StrVec* nodes);
  private:
  const ::dan::StrVec& _internal_nodes() const;
  ::dan::StrVec* _internal_mutable_nodes();
  public:
  void unsafe_arena_set_allocated_nodes(
      ::dan::StrVec* nodes);
  ::dan::StrVec* unsafe_arena_release_nodes();

  // int32 dop = 4;
  void clear_dop();
  ::PROTOBUF_NAMESPACE_ID::int32 dop() const;
  void set_dop(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dop() const;
  void _internal_set_dop(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.GraphPartition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ptype_;
  ::dan::StrVec* nodes_;
  ::PROTOBUF_NAMESPACE_ID::int32 dop_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GraphInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.GraphInfo) */ {
 public:
  inline GraphInfo() : GraphInfo(nullptr) {}
  virtual ~GraphInfo();

  GraphInfo(const GraphInfo& from);
  GraphInfo(GraphInfo&& from) noexcept
    : GraphInfo() {
    *this = ::std::move(from);
  }

  inline GraphInfo& operator=(const GraphInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphInfo& operator=(GraphInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GraphInfo& default_instance();

  static inline const GraphInfo* internal_default_instance() {
    return reinterpret_cast<const GraphInfo*>(
               &_GraphInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GraphInfo& a, GraphInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GraphInfo* New() const final {
    return CreateMaybeMessage<GraphInfo>(nullptr);
  }

  GraphInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GraphInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GraphInfo& from);
  void MergeFrom(const GraphInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.GraphInfo";
  }
  protected:
  explicit GraphInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVpfieldsFieldNumber = 3,
    kGnameFieldNumber = 1,
    kVpnameFieldNumber = 2,
    kEpfieldsFieldNumber = 4,
    kIncomingFieldNumber = 5,
  };
  // repeated .dan.StrVec vpfields = 3;
  int vpfields_size() const;
  private:
  int _internal_vpfields_size() const;
  public:
  void clear_vpfields();
  ::dan::StrVec* mutable_vpfields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::StrVec >*
      mutable_vpfields();
  private:
  const ::dan::StrVec& _internal_vpfields(int index) const;
  ::dan::StrVec* _internal_add_vpfields();
  public:
  const ::dan::StrVec& vpfields(int index) const;
  ::dan::StrVec* add_vpfields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::StrVec >&
      vpfields() const;

  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // .dan.StrVec vpname = 2;
  bool has_vpname() const;
  private:
  bool _internal_has_vpname() const;
  public:
  void clear_vpname();
  const ::dan::StrVec& vpname() const;
  ::dan::StrVec* release_vpname();
  ::dan::StrVec* mutable_vpname();
  void set_allocated_vpname(::dan::StrVec* vpname);
  private:
  const ::dan::StrVec& _internal_vpname() const;
  ::dan::StrVec* _internal_mutable_vpname();
  public:
  void unsafe_arena_set_allocated_vpname(
      ::dan::StrVec* vpname);
  ::dan::StrVec* unsafe_arena_release_vpname();

  // .dan.StrVec epfields = 4;
  bool has_epfields() const;
  private:
  bool _internal_has_epfields() const;
  public:
  void clear_epfields();
  const ::dan::StrVec& epfields() const;
  ::dan::StrVec* release_epfields();
  ::dan::StrVec* mutable_epfields();
  void set_allocated_epfields(::dan::StrVec* epfields);
  private:
  const ::dan::StrVec& _internal_epfields() const;
  ::dan::StrVec* _internal_mutable_epfields();
  public:
  void unsafe_arena_set_allocated_epfields(
      ::dan::StrVec* epfields);
  ::dan::StrVec* unsafe_arena_release_epfields();

  // bool incoming = 5;
  void clear_incoming();
  bool incoming() const;
  void set_incoming(bool value);
  private:
  bool _internal_incoming() const;
  void _internal_set_incoming(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dan.GraphInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::StrVec > vpfields_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::dan::StrVec* vpname_;
  ::dan::StrVec* epfields_;
  bool incoming_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InsertRecord PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.InsertRecord) */ {
 public:
  inline InsertRecord() : InsertRecord(nullptr) {}
  virtual ~InsertRecord();

  InsertRecord(const InsertRecord& from);
  InsertRecord(InsertRecord&& from) noexcept
    : InsertRecord() {
    *this = ::std::move(from);
  }

  inline InsertRecord& operator=(const InsertRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRecord& operator=(InsertRecord&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertRecord& default_instance();

  static inline const InsertRecord* internal_default_instance() {
    return reinterpret_cast<const InsertRecord*>(
               &_InsertRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(InsertRecord& a, InsertRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRecord* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertRecord* New() const final {
    return CreateMaybeMessage<InsertRecord>(nullptr);
  }

  InsertRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertRecord>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertRecord& from);
  void MergeFrom(const InsertRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRecord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.InsertRecord";
  }
  protected:
  explicit InsertRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTnameFieldNumber = 1,
    kValuesFieldNumber = 2,
  };
  // string tname = 1;
  void clear_tname();
  const std::string& tname() const;
  void set_tname(const std::string& value);
  void set_tname(std::string&& value);
  void set_tname(const char* value);
  void set_tname(const char* value, size_t size);
  std::string* mutable_tname();
  std::string* release_tname();
  void set_allocated_tname(std::string* tname);
  private:
  const std::string& _internal_tname() const;
  void _internal_set_tname(const std::string& value);
  std::string* _internal_mutable_tname();
  public:

  // .dan.Record values = 2;
  bool has_values() const;
  private:
  bool _internal_has_values() const;
  public:
  void clear_values();
  const ::dan::Record& values() const;
  ::dan::Record* release_values();
  ::dan::Record* mutable_values();
  void set_allocated_values(::dan::Record* values);
  private:
  const ::dan::Record& _internal_values() const;
  ::dan::Record* _internal_mutable_values();
  public:
  void unsafe_arena_set_allocated_values(
      ::dan::Record* values);
  ::dan::Record* unsafe_arena_release_values();

  // @@protoc_insertion_point(class_scope:dan.InsertRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tname_;
  ::dan::Record* values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InsertRecordStr PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.InsertRecordStr) */ {
 public:
  inline InsertRecordStr() : InsertRecordStr(nullptr) {}
  virtual ~InsertRecordStr();

  InsertRecordStr(const InsertRecordStr& from);
  InsertRecordStr(InsertRecordStr&& from) noexcept
    : InsertRecordStr() {
    *this = ::std::move(from);
  }

  inline InsertRecordStr& operator=(const InsertRecordStr& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRecordStr& operator=(InsertRecordStr&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertRecordStr& default_instance();

  static inline const InsertRecordStr* internal_default_instance() {
    return reinterpret_cast<const InsertRecordStr*>(
               &_InsertRecordStr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(InsertRecordStr& a, InsertRecordStr& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRecordStr* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRecordStr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertRecordStr* New() const final {
    return CreateMaybeMessage<InsertRecordStr>(nullptr);
  }

  InsertRecordStr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertRecordStr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertRecordStr& from);
  void MergeFrom(const InsertRecordStr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRecordStr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.InsertRecordStr";
  }
  protected:
  explicit InsertRecordStr(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTnameFieldNumber = 1,
    kValuesFieldNumber = 2,
  };
  // string tname = 1;
  void clear_tname();
  const std::string& tname() const;
  void set_tname(const std::string& value);
  void set_tname(std::string&& value);
  void set_tname(const char* value);
  void set_tname(const char* value, size_t size);
  std::string* mutable_tname();
  std::string* release_tname();
  void set_allocated_tname(std::string* tname);
  private:
  const std::string& _internal_tname() const;
  void _internal_set_tname(const std::string& value);
  std::string* _internal_mutable_tname();
  public:

  // .dan.StrVec values = 2;
  bool has_values() const;
  private:
  bool _internal_has_values() const;
  public:
  void clear_values();
  const ::dan::StrVec& values() const;
  ::dan::StrVec* release_values();
  ::dan::StrVec* mutable_values();
  void set_allocated_values(::dan::StrVec* values);
  private:
  const ::dan::StrVec& _internal_values() const;
  ::dan::StrVec* _internal_mutable_values();
  public:
  void unsafe_arena_set_allocated_values(
      ::dan::StrVec* values);
  ::dan::StrVec* unsafe_arena_release_values();

  // @@protoc_insertion_point(class_scope:dan.InsertRecordStr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tname_;
  ::dan::StrVec* values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InsertRecordBatch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.InsertRecordBatch) */ {
 public:
  inline InsertRecordBatch() : InsertRecordBatch(nullptr) {}
  virtual ~InsertRecordBatch();

  InsertRecordBatch(const InsertRecordBatch& from);
  InsertRecordBatch(InsertRecordBatch&& from) noexcept
    : InsertRecordBatch() {
    *this = ::std::move(from);
  }

  inline InsertRecordBatch& operator=(const InsertRecordBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRecordBatch& operator=(InsertRecordBatch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertRecordBatch& default_instance();

  static inline const InsertRecordBatch* internal_default_instance() {
    return reinterpret_cast<const InsertRecordBatch*>(
               &_InsertRecordBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(InsertRecordBatch& a, InsertRecordBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRecordBatch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRecordBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertRecordBatch* New() const final {
    return CreateMaybeMessage<InsertRecordBatch>(nullptr);
  }

  InsertRecordBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertRecordBatch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertRecordBatch& from);
  void MergeFrom(const InsertRecordBatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRecordBatch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.InsertRecordBatch";
  }
  protected:
  explicit InsertRecordBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTnameFieldNumber = 1,
    kBatchFieldNumber = 2,
  };
  // string tname = 1;
  void clear_tname();
  const std::string& tname() const;
  void set_tname(const std::string& value);
  void set_tname(std::string&& value);
  void set_tname(const char* value);
  void set_tname(const char* value, size_t size);
  std::string* mutable_tname();
  std::string* release_tname();
  void set_allocated_tname(std::string* tname);
  private:
  const std::string& _internal_tname() const;
  void _internal_set_tname(const std::string& value);
  std::string* _internal_mutable_tname();
  public:

  // .dan.Table batch = 2;
  bool has_batch() const;
  private:
  bool _internal_has_batch() const;
  public:
  void clear_batch();
  const ::dan::Table& batch() const;
  ::dan::Table* release_batch();
  ::dan::Table* mutable_batch();
  void set_allocated_batch(::dan::Table* batch);
  private:
  const ::dan::Table& _internal_batch() const;
  ::dan::Table* _internal_mutable_batch();
  public:
  void unsafe_arena_set_allocated_batch(
      ::dan::Table* batch);
  ::dan::Table* unsafe_arena_release_batch();

  // @@protoc_insertion_point(class_scope:dan.InsertRecordBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tname_;
  ::dan::Table* batch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class DefineVertex PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.DefineVertex) */ {
 public:
  inline DefineVertex() : DefineVertex(nullptr) {}
  virtual ~DefineVertex();

  DefineVertex(const DefineVertex& from);
  DefineVertex(DefineVertex&& from) noexcept
    : DefineVertex() {
    *this = ::std::move(from);
  }

  inline DefineVertex& operator=(const DefineVertex& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefineVertex& operator=(DefineVertex&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DefineVertex& default_instance();

  static inline const DefineVertex* internal_default_instance() {
    return reinterpret_cast<const DefineVertex*>(
               &_DefineVertex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DefineVertex& a, DefineVertex& b) {
    a.Swap(&b);
  }
  inline void Swap(DefineVertex* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefineVertex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DefineVertex* New() const final {
    return CreateMaybeMessage<DefineVertex>(nullptr);
  }

  DefineVertex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DefineVertex>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DefineVertex& from);
  void MergeFrom(const DefineVertex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefineVertex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.DefineVertex";
  }
  protected:
  explicit DefineVertex(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVschemaFieldNumber = 3,
    kGnameFieldNumber = 1,
    kVpnameFieldNumber = 2,
    kVptypeFieldNumber = 5,
    kVpfidFieldNumber = 4,
  };
  // repeated .dan.Field vschema = 3;
  int vschema_size() const;
  private:
  int _internal_vschema_size() const;
  public:
  void clear_vschema();
  ::dan::Field* mutable_vschema(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >*
      mutable_vschema();
  private:
  const ::dan::Field& _internal_vschema(int index) const;
  ::dan::Field* _internal_add_vschema();
  public:
  const ::dan::Field& vschema(int index) const;
  ::dan::Field* add_vschema();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >&
      vschema() const;

  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // string vpname = 2;
  void clear_vpname();
  const std::string& vpname() const;
  void set_vpname(const std::string& value);
  void set_vpname(std::string&& value);
  void set_vpname(const char* value);
  void set_vpname(const char* value, size_t size);
  std::string* mutable_vpname();
  std::string* release_vpname();
  void set_allocated_vpname(std::string* vpname);
  private:
  const std::string& _internal_vpname() const;
  void _internal_set_vpname(const std::string& value);
  std::string* _internal_mutable_vpname();
  public:

  // string vptype = 5;
  void clear_vptype();
  const std::string& vptype() const;
  void set_vptype(const std::string& value);
  void set_vptype(std::string&& value);
  void set_vptype(const char* value);
  void set_vptype(const char* value, size_t size);
  std::string* mutable_vptype();
  std::string* release_vptype();
  void set_allocated_vptype(std::string* vptype);
  private:
  const std::string& _internal_vptype() const;
  void _internal_set_vptype(const std::string& value);
  std::string* _internal_mutable_vptype();
  public:

  // int32 vpfid = 4;
  void clear_vpfid();
  ::PROTOBUF_NAMESPACE_ID::int32 vpfid() const;
  void set_vpfid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vpfid() const;
  void _internal_set_vpfid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.DefineVertex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field > vschema_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vpname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vptype_;
  ::PROTOBUF_NAMESPACE_ID::int32 vpfid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class ImportVertex PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.ImportVertex) */ {
 public:
  inline ImportVertex() : ImportVertex(nullptr) {}
  virtual ~ImportVertex();

  ImportVertex(const ImportVertex& from);
  ImportVertex(ImportVertex&& from) noexcept
    : ImportVertex() {
    *this = ::std::move(from);
  }

  inline ImportVertex& operator=(const ImportVertex& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImportVertex& operator=(ImportVertex&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImportVertex& default_instance();

  static inline const ImportVertex* internal_default_instance() {
    return reinterpret_cast<const ImportVertex*>(
               &_ImportVertex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ImportVertex& a, ImportVertex& b) {
    a.Swap(&b);
  }
  inline void Swap(ImportVertex* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImportVertex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImportVertex* New() const final {
    return CreateMaybeMessage<ImportVertex>(nullptr);
  }

  ImportVertex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImportVertex>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImportVertex& from);
  void MergeFrom(const ImportVertex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportVertex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.ImportVertex";
  }
  protected:
  explicit ImportVertex(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kVpnameFieldNumber = 2,
    kCsvFieldNumber = 3,
    kDelimFieldNumber = 4,
    kHeaderFieldNumber = 5,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // string vpname = 2;
  void clear_vpname();
  const std::string& vpname() const;
  void set_vpname(const std::string& value);
  void set_vpname(std::string&& value);
  void set_vpname(const char* value);
  void set_vpname(const char* value, size_t size);
  std::string* mutable_vpname();
  std::string* release_vpname();
  void set_allocated_vpname(std::string* vpname);
  private:
  const std::string& _internal_vpname() const;
  void _internal_set_vpname(const std::string& value);
  std::string* _internal_mutable_vpname();
  public:

  // string csv = 3;
  void clear_csv();
  const std::string& csv() const;
  void set_csv(const std::string& value);
  void set_csv(std::string&& value);
  void set_csv(const char* value);
  void set_csv(const char* value, size_t size);
  std::string* mutable_csv();
  std::string* release_csv();
  void set_allocated_csv(std::string* csv);
  private:
  const std::string& _internal_csv() const;
  void _internal_set_csv(const std::string& value);
  std::string* _internal_mutable_csv();
  public:

  // string delim = 4;
  void clear_delim();
  const std::string& delim() const;
  void set_delim(const std::string& value);
  void set_delim(std::string&& value);
  void set_delim(const char* value);
  void set_delim(const char* value, size_t size);
  std::string* mutable_delim();
  std::string* release_delim();
  void set_allocated_delim(std::string* delim);
  private:
  const std::string& _internal_delim() const;
  void _internal_set_delim(const std::string& value);
  std::string* _internal_mutable_delim();
  public:

  // bool header = 5;
  void clear_header();
  bool header() const;
  void set_header(bool value);
  private:
  bool _internal_header() const;
  void _internal_set_header(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dan.ImportVertex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vpname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr csv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delim_;
  bool header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InsertVertex PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.InsertVertex) */ {
 public:
  inline InsertVertex() : InsertVertex(nullptr) {}
  virtual ~InsertVertex();

  InsertVertex(const InsertVertex& from);
  InsertVertex(InsertVertex&& from) noexcept
    : InsertVertex() {
    *this = ::std::move(from);
  }

  inline InsertVertex& operator=(const InsertVertex& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertVertex& operator=(InsertVertex&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertVertex& default_instance();

  static inline const InsertVertex* internal_default_instance() {
    return reinterpret_cast<const InsertVertex*>(
               &_InsertVertex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(InsertVertex& a, InsertVertex& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertVertex* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertVertex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertVertex* New() const final {
    return CreateMaybeMessage<InsertVertex>(nullptr);
  }

  InsertVertex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertVertex>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertVertex& from);
  void MergeFrom(const InsertVertex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertVertex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.InsertVertex";
  }
  protected:
  explicit InsertVertex(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kVpropFieldNumber = 2,
    kVpidFieldNumber = 3,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // .dan.Record vprop = 2;
  bool has_vprop() const;
  private:
  bool _internal_has_vprop() const;
  public:
  void clear_vprop();
  const ::dan::Record& vprop() const;
  ::dan::Record* release_vprop();
  ::dan::Record* mutable_vprop();
  void set_allocated_vprop(::dan::Record* vprop);
  private:
  const ::dan::Record& _internal_vprop() const;
  ::dan::Record* _internal_mutable_vprop();
  public:
  void unsafe_arena_set_allocated_vprop(
      ::dan::Record* vprop);
  ::dan::Record* unsafe_arena_release_vprop();

  // int32 vpid = 3;
  void clear_vpid();
  ::PROTOBUF_NAMESPACE_ID::int32 vpid() const;
  void set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vpid() const;
  void _internal_set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.InsertVertex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::dan::Record* vprop_;
  ::PROTOBUF_NAMESPACE_ID::int32 vpid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InsertVertexBatch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.InsertVertexBatch) */ {
 public:
  inline InsertVertexBatch() : InsertVertexBatch(nullptr) {}
  virtual ~InsertVertexBatch();

  InsertVertexBatch(const InsertVertexBatch& from);
  InsertVertexBatch(InsertVertexBatch&& from) noexcept
    : InsertVertexBatch() {
    *this = ::std::move(from);
  }

  inline InsertVertexBatch& operator=(const InsertVertexBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertVertexBatch& operator=(InsertVertexBatch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertVertexBatch& default_instance();

  static inline const InsertVertexBatch* internal_default_instance() {
    return reinterpret_cast<const InsertVertexBatch*>(
               &_InsertVertexBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(InsertVertexBatch& a, InsertVertexBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertVertexBatch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertVertexBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertVertexBatch* New() const final {
    return CreateMaybeMessage<InsertVertexBatch>(nullptr);
  }

  InsertVertexBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertVertexBatch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertVertexBatch& from);
  void MergeFrom(const InsertVertexBatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertVertexBatch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.InsertVertexBatch";
  }
  protected:
  explicit InsertVertexBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kVpropFieldNumber = 2,
    kVpidsFieldNumber = 4,
    kVpidFieldNumber = 3,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // .dan.Table vprop = 2;
  bool has_vprop() const;
  private:
  bool _internal_has_vprop() const;
  public:
  void clear_vprop();
  const ::dan::Table& vprop() const;
  ::dan::Table* release_vprop();
  ::dan::Table* mutable_vprop();
  void set_allocated_vprop(::dan::Table* vprop);
  private:
  const ::dan::Table& _internal_vprop() const;
  ::dan::Table* _internal_mutable_vprop();
  public:
  void unsafe_arena_set_allocated_vprop(
      ::dan::Table* vprop);
  ::dan::Table* unsafe_arena_release_vprop();

  // .dan.IntVec vpids = 4;
  bool has_vpids() const;
  private:
  bool _internal_has_vpids() const;
  public:
  void clear_vpids();
  const ::dan::IntVec& vpids() const;
  ::dan::IntVec* release_vpids();
  ::dan::IntVec* mutable_vpids();
  void set_allocated_vpids(::dan::IntVec* vpids);
  private:
  const ::dan::IntVec& _internal_vpids() const;
  ::dan::IntVec* _internal_mutable_vpids();
  public:
  void unsafe_arena_set_allocated_vpids(
      ::dan::IntVec* vpids);
  ::dan::IntVec* unsafe_arena_release_vpids();

  // int32 vpid = 3;
  void clear_vpid();
  ::PROTOBUF_NAMESPACE_ID::int32 vpid() const;
  void set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vpid() const;
  void _internal_set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.InsertVertexBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::dan::Table* vprop_;
  ::dan::IntVec* vpids_;
  ::PROTOBUF_NAMESPACE_ID::int32 vpid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class ImportEdge PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.ImportEdge) */ {
 public:
  inline ImportEdge() : ImportEdge(nullptr) {}
  virtual ~ImportEdge();

  ImportEdge(const ImportEdge& from);
  ImportEdge(ImportEdge&& from) noexcept
    : ImportEdge() {
    *this = ::std::move(from);
  }

  inline ImportEdge& operator=(const ImportEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImportEdge& operator=(ImportEdge&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImportEdge& default_instance();

  static inline const ImportEdge* internal_default_instance() {
    return reinterpret_cast<const ImportEdge*>(
               &_ImportEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ImportEdge& a, ImportEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(ImportEdge* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImportEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImportEdge* New() const final {
    return CreateMaybeMessage<ImportEdge>(nullptr);
  }

  ImportEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImportEdge>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImportEdge& from);
  void MergeFrom(const ImportEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportEdge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.ImportEdge";
  }
  protected:
  explicit ImportEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kCsvFieldNumber = 2,
    kDelimFieldNumber = 5,
    kSrcVpidFieldNumber = 3,
    kDstVpidFieldNumber = 4,
    kHeaderFieldNumber = 6,
    kBatchFieldNumber = 7,
    kDopFieldNumber = 8,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // string csv = 2;
  void clear_csv();
  const std::string& csv() const;
  void set_csv(const std::string& value);
  void set_csv(std::string&& value);
  void set_csv(const char* value);
  void set_csv(const char* value, size_t size);
  std::string* mutable_csv();
  std::string* release_csv();
  void set_allocated_csv(std::string* csv);
  private:
  const std::string& _internal_csv() const;
  void _internal_set_csv(const std::string& value);
  std::string* _internal_mutable_csv();
  public:

  // string delim = 5;
  void clear_delim();
  const std::string& delim() const;
  void set_delim(const std::string& value);
  void set_delim(std::string&& value);
  void set_delim(const char* value);
  void set_delim(const char* value, size_t size);
  std::string* mutable_delim();
  std::string* release_delim();
  void set_allocated_delim(std::string* delim);
  private:
  const std::string& _internal_delim() const;
  void _internal_set_delim(const std::string& value);
  std::string* _internal_mutable_delim();
  public:

  // int32 src_vpid = 3;
  void clear_src_vpid();
  ::PROTOBUF_NAMESPACE_ID::int32 src_vpid() const;
  void set_src_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_src_vpid() const;
  void _internal_set_src_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 dst_vpid = 4;
  void clear_dst_vpid();
  ::PROTOBUF_NAMESPACE_ID::int32 dst_vpid() const;
  void set_dst_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dst_vpid() const;
  void _internal_set_dst_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool header = 6;
  void clear_header();
  bool header() const;
  void set_header(bool value);
  private:
  bool _internal_header() const;
  void _internal_set_header(bool value);
  public:

  // int32 batch = 7;
  void clear_batch();
  ::PROTOBUF_NAMESPACE_ID::int32 batch() const;
  void set_batch(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batch() const;
  void _internal_set_batch(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 dop = 8;
  void clear_dop();
  ::PROTOBUF_NAMESPACE_ID::int32 dop() const;
  void set_dop(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dop() const;
  void _internal_set_dop(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.ImportEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr csv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delim_;
  ::PROTOBUF_NAMESPACE_ID::int32 src_vpid_;
  ::PROTOBUF_NAMESPACE_ID::int32 dst_vpid_;
  bool header_;
  ::PROTOBUF_NAMESPACE_ID::int32 batch_;
  ::PROTOBUF_NAMESPACE_ID::int32 dop_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InsertEdge PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.InsertEdge) */ {
 public:
  inline InsertEdge() : InsertEdge(nullptr) {}
  virtual ~InsertEdge();

  InsertEdge(const InsertEdge& from);
  InsertEdge(InsertEdge&& from) noexcept
    : InsertEdge() {
    *this = ::std::move(from);
  }

  inline InsertEdge& operator=(const InsertEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertEdge& operator=(InsertEdge&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertEdge& default_instance();

  static inline const InsertEdge* internal_default_instance() {
    return reinterpret_cast<const InsertEdge*>(
               &_InsertEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(InsertEdge& a, InsertEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertEdge* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertEdge* New() const final {
    return CreateMaybeMessage<InsertEdge>(nullptr);
  }

  InsertEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertEdge>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertEdge& from);
  void MergeFrom(const InsertEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertEdge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.InsertEdge";
  }
  protected:
  explicit InsertEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kSrcFieldNumber = 2,
    kDestFieldNumber = 3,
    kEpropFieldNumber = 6,
    kSrcVpidFieldNumber = 4,
    kDestVpidFieldNumber = 5,
    kIgnoreInFieldNumber = 7,
    kOnlyInFieldNumber = 8,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // .dan.Eval src = 2;
  bool has_src() const;
  private:
  bool _internal_has_src() const;
  public:
  void clear_src();
  const ::dan::Eval& src() const;
  ::dan::Eval* release_src();
  ::dan::Eval* mutable_src();
  void set_allocated_src(::dan::Eval* src);
  private:
  const ::dan::Eval& _internal_src() const;
  ::dan::Eval* _internal_mutable_src();
  public:
  void unsafe_arena_set_allocated_src(
      ::dan::Eval* src);
  ::dan::Eval* unsafe_arena_release_src();

  // .dan.Eval dest = 3;
  bool has_dest() const;
  private:
  bool _internal_has_dest() const;
  public:
  void clear_dest();
  const ::dan::Eval& dest() const;
  ::dan::Eval* release_dest();
  ::dan::Eval* mutable_dest();
  void set_allocated_dest(::dan::Eval* dest);
  private:
  const ::dan::Eval& _internal_dest() const;
  ::dan::Eval* _internal_mutable_dest();
  public:
  void unsafe_arena_set_allocated_dest(
      ::dan::Eval* dest);
  ::dan::Eval* unsafe_arena_release_dest();

  // .dan.Record eprop = 6;
  bool has_eprop() const;
  private:
  bool _internal_has_eprop() const;
  public:
  void clear_eprop();
  const ::dan::Record& eprop() const;
  ::dan::Record* release_eprop();
  ::dan::Record* mutable_eprop();
  void set_allocated_eprop(::dan::Record* eprop);
  private:
  const ::dan::Record& _internal_eprop() const;
  ::dan::Record* _internal_mutable_eprop();
  public:
  void unsafe_arena_set_allocated_eprop(
      ::dan::Record* eprop);
  ::dan::Record* unsafe_arena_release_eprop();

  // int32 src_vpid = 4;
  void clear_src_vpid();
  ::PROTOBUF_NAMESPACE_ID::int32 src_vpid() const;
  void set_src_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_src_vpid() const;
  void _internal_set_src_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 dest_vpid = 5;
  void clear_dest_vpid();
  ::PROTOBUF_NAMESPACE_ID::int32 dest_vpid() const;
  void set_dest_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dest_vpid() const;
  void _internal_set_dest_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool ignore_in = 7;
  void clear_ignore_in();
  bool ignore_in() const;
  void set_ignore_in(bool value);
  private:
  bool _internal_ignore_in() const;
  void _internal_set_ignore_in(bool value);
  public:

  // bool only_in = 8;
  void clear_only_in();
  bool only_in() const;
  void set_only_in(bool value);
  private:
  bool _internal_only_in() const;
  void _internal_set_only_in(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dan.InsertEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::dan::Eval* src_;
  ::dan::Eval* dest_;
  ::dan::Record* eprop_;
  ::PROTOBUF_NAMESPACE_ID::int32 src_vpid_;
  ::PROTOBUF_NAMESPACE_ID::int32 dest_vpid_;
  bool ignore_in_;
  bool only_in_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InsertEdgeVP PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.InsertEdgeVP) */ {
 public:
  inline InsertEdgeVP() : InsertEdgeVP(nullptr) {}
  virtual ~InsertEdgeVP();

  InsertEdgeVP(const InsertEdgeVP& from);
  InsertEdgeVP(InsertEdgeVP&& from) noexcept
    : InsertEdgeVP() {
    *this = ::std::move(from);
  }

  inline InsertEdgeVP& operator=(const InsertEdgeVP& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertEdgeVP& operator=(InsertEdgeVP&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertEdgeVP& default_instance();

  static inline const InsertEdgeVP* internal_default_instance() {
    return reinterpret_cast<const InsertEdgeVP*>(
               &_InsertEdgeVP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(InsertEdgeVP& a, InsertEdgeVP& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertEdgeVP* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertEdgeVP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertEdgeVP* New() const final {
    return CreateMaybeMessage<InsertEdgeVP>(nullptr);
  }

  InsertEdgeVP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertEdgeVP>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertEdgeVP& from);
  void MergeFrom(const InsertEdgeVP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertEdgeVP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.InsertEdgeVP";
  }
  protected:
  explicit InsertEdgeVP(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kSrcFieldNumber = 2,
    kDestFieldNumber = 3,
    kEpropFieldNumber = 6,
    kSrcVpidFieldNumber = 4,
    kDestVpidFieldNumber = 5,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // .dan.Record src = 2;
  bool has_src() const;
  private:
  bool _internal_has_src() const;
  public:
  void clear_src();
  const ::dan::Record& src() const;
  ::dan::Record* release_src();
  ::dan::Record* mutable_src();
  void set_allocated_src(::dan::Record* src);
  private:
  const ::dan::Record& _internal_src() const;
  ::dan::Record* _internal_mutable_src();
  public:
  void unsafe_arena_set_allocated_src(
      ::dan::Record* src);
  ::dan::Record* unsafe_arena_release_src();

  // .dan.Record dest = 3;
  bool has_dest() const;
  private:
  bool _internal_has_dest() const;
  public:
  void clear_dest();
  const ::dan::Record& dest() const;
  ::dan::Record* release_dest();
  ::dan::Record* mutable_dest();
  void set_allocated_dest(::dan::Record* dest);
  private:
  const ::dan::Record& _internal_dest() const;
  ::dan::Record* _internal_mutable_dest();
  public:
  void unsafe_arena_set_allocated_dest(
      ::dan::Record* dest);
  ::dan::Record* unsafe_arena_release_dest();

  // .dan.Record eprop = 6;
  bool has_eprop() const;
  private:
  bool _internal_has_eprop() const;
  public:
  void clear_eprop();
  const ::dan::Record& eprop() const;
  ::dan::Record* release_eprop();
  ::dan::Record* mutable_eprop();
  void set_allocated_eprop(::dan::Record* eprop);
  private:
  const ::dan::Record& _internal_eprop() const;
  ::dan::Record* _internal_mutable_eprop();
  public:
  void unsafe_arena_set_allocated_eprop(
      ::dan::Record* eprop);
  ::dan::Record* unsafe_arena_release_eprop();

  // int32 src_vpid = 4;
  void clear_src_vpid();
  ::PROTOBUF_NAMESPACE_ID::int32 src_vpid() const;
  void set_src_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_src_vpid() const;
  void _internal_set_src_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 dest_vpid = 5;
  void clear_dest_vpid();
  ::PROTOBUF_NAMESPACE_ID::int32 dest_vpid() const;
  void set_dest_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dest_vpid() const;
  void _internal_set_dest_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.InsertEdgeVP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::dan::Record* src_;
  ::dan::Record* dest_;
  ::dan::Record* eprop_;
  ::PROTOBUF_NAMESPACE_ID::int32 src_vpid_;
  ::PROTOBUF_NAMESPACE_ID::int32 dest_vpid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InsertEdgeNaive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.InsertEdgeNaive) */ {
 public:
  inline InsertEdgeNaive() : InsertEdgeNaive(nullptr) {}
  virtual ~InsertEdgeNaive();

  InsertEdgeNaive(const InsertEdgeNaive& from);
  InsertEdgeNaive(InsertEdgeNaive&& from) noexcept
    : InsertEdgeNaive() {
    *this = ::std::move(from);
  }

  inline InsertEdgeNaive& operator=(const InsertEdgeNaive& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertEdgeNaive& operator=(InsertEdgeNaive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertEdgeNaive& default_instance();

  static inline const InsertEdgeNaive* internal_default_instance() {
    return reinterpret_cast<const InsertEdgeNaive*>(
               &_InsertEdgeNaive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(InsertEdgeNaive& a, InsertEdgeNaive& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertEdgeNaive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertEdgeNaive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertEdgeNaive* New() const final {
    return CreateMaybeMessage<InsertEdgeNaive>(nullptr);
  }

  InsertEdgeNaive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertEdgeNaive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertEdgeNaive& from);
  void MergeFrom(const InsertEdgeNaive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertEdgeNaive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.InsertEdgeNaive";
  }
  protected:
  explicit InsertEdgeNaive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kEpropFieldNumber = 4,
    kSrcFieldNumber = 2,
    kDestFieldNumber = 3,
    kIgnoreInFieldNumber = 5,
    kOnlyInFieldNumber = 6,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // .dan.Record eprop = 4;
  bool has_eprop() const;
  private:
  bool _internal_has_eprop() const;
  public:
  void clear_eprop();
  const ::dan::Record& eprop() const;
  ::dan::Record* release_eprop();
  ::dan::Record* mutable_eprop();
  void set_allocated_eprop(::dan::Record* eprop);
  private:
  const ::dan::Record& _internal_eprop() const;
  ::dan::Record* _internal_mutable_eprop();
  public:
  void unsafe_arena_set_allocated_eprop(
      ::dan::Record* eprop);
  ::dan::Record* unsafe_arena_release_eprop();

  // int64 src = 2;
  void clear_src();
  ::PROTOBUF_NAMESPACE_ID::int64 src() const;
  void set_src(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_src() const;
  void _internal_set_src(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 dest = 3;
  void clear_dest();
  ::PROTOBUF_NAMESPACE_ID::int64 dest() const;
  void set_dest(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dest() const;
  void _internal_set_dest(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool ignore_in = 5;
  void clear_ignore_in();
  bool ignore_in() const;
  void set_ignore_in(bool value);
  private:
  bool _internal_ignore_in() const;
  void _internal_set_ignore_in(bool value);
  public:

  // bool only_in = 6;
  void clear_only_in();
  bool only_in() const;
  void set_only_in(bool value);
  private:
  bool _internal_only_in() const;
  void _internal_set_only_in(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dan.InsertEdgeNaive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::dan::Record* eprop_;
  ::PROTOBUF_NAMESPACE_ID::int64 src_;
  ::PROTOBUF_NAMESPACE_ID::int64 dest_;
  bool ignore_in_;
  bool only_in_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InsertEdgeBatch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.InsertEdgeBatch) */ {
 public:
  inline InsertEdgeBatch() : InsertEdgeBatch(nullptr) {}
  virtual ~InsertEdgeBatch();

  InsertEdgeBatch(const InsertEdgeBatch& from);
  InsertEdgeBatch(InsertEdgeBatch&& from) noexcept
    : InsertEdgeBatch() {
    *this = ::std::move(from);
  }

  inline InsertEdgeBatch& operator=(const InsertEdgeBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertEdgeBatch& operator=(InsertEdgeBatch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertEdgeBatch& default_instance();

  static inline const InsertEdgeBatch* internal_default_instance() {
    return reinterpret_cast<const InsertEdgeBatch*>(
               &_InsertEdgeBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(InsertEdgeBatch& a, InsertEdgeBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertEdgeBatch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertEdgeBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertEdgeBatch* New() const final {
    return CreateMaybeMessage<InsertEdgeBatch>(nullptr);
  }

  InsertEdgeBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertEdgeBatch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertEdgeBatch& from);
  void MergeFrom(const InsertEdgeBatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertEdgeBatch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.InsertEdgeBatch";
  }
  protected:
  explicit InsertEdgeBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kSrcFieldNumber = 2,
    kDestFieldNumber = 3,
    kEpropFieldNumber = 4,
    kSrcVpidFieldNumber = 5,
    kDestVpidFieldNumber = 6,
    kIgnoreInFieldNumber = 7,
    kOnlyInFieldNumber = 8,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // .dan.Record src = 2;
  bool has_src() const;
  private:
  bool _internal_has_src() const;
  public:
  void clear_src();
  const ::dan::Record& src() const;
  ::dan::Record* release_src();
  ::dan::Record* mutable_src();
  void set_allocated_src(::dan::Record* src);
  private:
  const ::dan::Record& _internal_src() const;
  ::dan::Record* _internal_mutable_src();
  public:
  void unsafe_arena_set_allocated_src(
      ::dan::Record* src);
  ::dan::Record* unsafe_arena_release_src();

  // .dan.Record dest = 3;
  bool has_dest() const;
  private:
  bool _internal_has_dest() const;
  public:
  void clear_dest();
  const ::dan::Record& dest() const;
  ::dan::Record* release_dest();
  ::dan::Record* mutable_dest();
  void set_allocated_dest(::dan::Record* dest);
  private:
  const ::dan::Record& _internal_dest() const;
  ::dan::Record* _internal_mutable_dest();
  public:
  void unsafe_arena_set_allocated_dest(
      ::dan::Record* dest);
  ::dan::Record* unsafe_arena_release_dest();

  // .dan.Table eprop = 4;
  bool has_eprop() const;
  private:
  bool _internal_has_eprop() const;
  public:
  void clear_eprop();
  const ::dan::Table& eprop() const;
  ::dan::Table* release_eprop();
  ::dan::Table* mutable_eprop();
  void set_allocated_eprop(::dan::Table* eprop);
  private:
  const ::dan::Table& _internal_eprop() const;
  ::dan::Table* _internal_mutable_eprop();
  public:
  void unsafe_arena_set_allocated_eprop(
      ::dan::Table* eprop);
  ::dan::Table* unsafe_arena_release_eprop();

  // .dan.IntVec src_vpid = 5;
  bool has_src_vpid() const;
  private:
  bool _internal_has_src_vpid() const;
  public:
  void clear_src_vpid();
  const ::dan::IntVec& src_vpid() const;
  ::dan::IntVec* release_src_vpid();
  ::dan::IntVec* mutable_src_vpid();
  void set_allocated_src_vpid(::dan::IntVec* src_vpid);
  private:
  const ::dan::IntVec& _internal_src_vpid() const;
  ::dan::IntVec* _internal_mutable_src_vpid();
  public:
  void unsafe_arena_set_allocated_src_vpid(
      ::dan::IntVec* src_vpid);
  ::dan::IntVec* unsafe_arena_release_src_vpid();

  // .dan.IntVec dest_vpid = 6;
  bool has_dest_vpid() const;
  private:
  bool _internal_has_dest_vpid() const;
  public:
  void clear_dest_vpid();
  const ::dan::IntVec& dest_vpid() const;
  ::dan::IntVec* release_dest_vpid();
  ::dan::IntVec* mutable_dest_vpid();
  void set_allocated_dest_vpid(::dan::IntVec* dest_vpid);
  private:
  const ::dan::IntVec& _internal_dest_vpid() const;
  ::dan::IntVec* _internal_mutable_dest_vpid();
  public:
  void unsafe_arena_set_allocated_dest_vpid(
      ::dan::IntVec* dest_vpid);
  ::dan::IntVec* unsafe_arena_release_dest_vpid();

  // bool ignore_in = 7;
  void clear_ignore_in();
  bool ignore_in() const;
  void set_ignore_in(bool value);
  private:
  bool _internal_ignore_in() const;
  void _internal_set_ignore_in(bool value);
  public:

  // bool only_in = 8;
  void clear_only_in();
  bool only_in() const;
  void set_only_in(bool value);
  private:
  bool _internal_only_in() const;
  void _internal_set_only_in(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dan.InsertEdgeBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::dan::Record* src_;
  ::dan::Record* dest_;
  ::dan::Table* eprop_;
  ::dan::IntVec* src_vpid_;
  ::dan::IntVec* dest_vpid_;
  bool ignore_in_;
  bool only_in_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InsertEdgeBatchVP PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.InsertEdgeBatchVP) */ {
 public:
  inline InsertEdgeBatchVP() : InsertEdgeBatchVP(nullptr) {}
  virtual ~InsertEdgeBatchVP();

  InsertEdgeBatchVP(const InsertEdgeBatchVP& from);
  InsertEdgeBatchVP(InsertEdgeBatchVP&& from) noexcept
    : InsertEdgeBatchVP() {
    *this = ::std::move(from);
  }

  inline InsertEdgeBatchVP& operator=(const InsertEdgeBatchVP& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertEdgeBatchVP& operator=(InsertEdgeBatchVP&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertEdgeBatchVP& default_instance();

  static inline const InsertEdgeBatchVP* internal_default_instance() {
    return reinterpret_cast<const InsertEdgeBatchVP*>(
               &_InsertEdgeBatchVP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(InsertEdgeBatchVP& a, InsertEdgeBatchVP& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertEdgeBatchVP* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertEdgeBatchVP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertEdgeBatchVP* New() const final {
    return CreateMaybeMessage<InsertEdgeBatchVP>(nullptr);
  }

  InsertEdgeBatchVP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertEdgeBatchVP>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertEdgeBatchVP& from);
  void MergeFrom(const InsertEdgeBatchVP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertEdgeBatchVP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.InsertEdgeBatchVP";
  }
  protected:
  explicit InsertEdgeBatchVP(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kSrcFieldNumber = 2,
    kDestFieldNumber = 3,
    kEpropFieldNumber = 4,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // .dan.Table src = 2;
  bool has_src() const;
  private:
  bool _internal_has_src() const;
  public:
  void clear_src();
  const ::dan::Table& src() const;
  ::dan::Table* release_src();
  ::dan::Table* mutable_src();
  void set_allocated_src(::dan::Table* src);
  private:
  const ::dan::Table& _internal_src() const;
  ::dan::Table* _internal_mutable_src();
  public:
  void unsafe_arena_set_allocated_src(
      ::dan::Table* src);
  ::dan::Table* unsafe_arena_release_src();

  // .dan.Table dest = 3;
  bool has_dest() const;
  private:
  bool _internal_has_dest() const;
  public:
  void clear_dest();
  const ::dan::Table& dest() const;
  ::dan::Table* release_dest();
  ::dan::Table* mutable_dest();
  void set_allocated_dest(::dan::Table* dest);
  private:
  const ::dan::Table& _internal_dest() const;
  ::dan::Table* _internal_mutable_dest();
  public:
  void unsafe_arena_set_allocated_dest(
      ::dan::Table* dest);
  ::dan::Table* unsafe_arena_release_dest();

  // .dan.Table eprop = 4;
  bool has_eprop() const;
  private:
  bool _internal_has_eprop() const;
  public:
  void clear_eprop();
  const ::dan::Table& eprop() const;
  ::dan::Table* release_eprop();
  ::dan::Table* mutable_eprop();
  void set_allocated_eprop(::dan::Table* eprop);
  private:
  const ::dan::Table& _internal_eprop() const;
  ::dan::Table* _internal_mutable_eprop();
  public:
  void unsafe_arena_set_allocated_eprop(
      ::dan::Table* eprop);
  ::dan::Table* unsafe_arena_release_eprop();

  // @@protoc_insertion_point(class_scope:dan.InsertEdgeBatchVP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::dan::Table* src_;
  ::dan::Table* dest_;
  ::dan::Table* eprop_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class TableScan PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.TableScan) */ {
 public:
  inline TableScan() : TableScan(nullptr) {}
  virtual ~TableScan();

  TableScan(const TableScan& from);
  TableScan(TableScan&& from) noexcept
    : TableScan() {
    *this = ::std::move(from);
  }

  inline TableScan& operator=(const TableScan& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableScan& operator=(TableScan&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TableScan& default_instance();

  static inline const TableScan* internal_default_instance() {
    return reinterpret_cast<const TableScan*>(
               &_TableScan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(TableScan& a, TableScan& b) {
    a.Swap(&b);
  }
  inline void Swap(TableScan* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableScan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableScan* New() const final {
    return CreateMaybeMessage<TableScan>(nullptr);
  }

  TableScan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableScan>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TableScan& from);
  void MergeFrom(const TableScan& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableScan* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.TableScan";
  }
  protected:
  explicit TableScan(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTnameFieldNumber = 1,
    kFidsFieldNumber = 2,
    kLimitFieldNumber = 3,
  };
  // string tname = 1;
  void clear_tname();
  const std::string& tname() const;
  void set_tname(const std::string& value);
  void set_tname(std::string&& value);
  void set_tname(const char* value);
  void set_tname(const char* value, size_t size);
  std::string* mutable_tname();
  std::string* release_tname();
  void set_allocated_tname(std::string* tname);
  private:
  const std::string& _internal_tname() const;
  void _internal_set_tname(const std::string& value);
  std::string* _internal_mutable_tname();
  public:

  // .dan.IntVec fids = 2;
  bool has_fids() const;
  private:
  bool _internal_has_fids() const;
  public:
  void clear_fids();
  const ::dan::IntVec& fids() const;
  ::dan::IntVec* release_fids();
  ::dan::IntVec* mutable_fids();
  void set_allocated_fids(::dan::IntVec* fids);
  private:
  const ::dan::IntVec& _internal_fids() const;
  ::dan::IntVec* _internal_mutable_fids();
  public:
  void unsafe_arena_set_allocated_fids(
      ::dan::IntVec* fids);
  ::dan::IntVec* unsafe_arena_release_fids();

  // int64 limit = 3;
  void clear_limit();
  ::PROTOBUF_NAMESPACE_ID::int64 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_limit() const;
  void _internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.TableScan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tname_;
  ::dan::IntVec* fids_;
  ::PROTOBUF_NAMESPACE_ID::int64 limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class IndexSearch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.IndexSearch) */ {
 public:
  inline IndexSearch() : IndexSearch(nullptr) {}
  virtual ~IndexSearch();

  IndexSearch(const IndexSearch& from);
  IndexSearch(IndexSearch&& from) noexcept
    : IndexSearch() {
    *this = ::std::move(from);
  }

  inline IndexSearch& operator=(const IndexSearch& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexSearch& operator=(IndexSearch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IndexSearch& default_instance();

  static inline const IndexSearch* internal_default_instance() {
    return reinterpret_cast<const IndexSearch*>(
               &_IndexSearch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(IndexSearch& a, IndexSearch& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexSearch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexSearch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IndexSearch* New() const final {
    return CreateMaybeMessage<IndexSearch>(nullptr);
  }

  IndexSearch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexSearch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IndexSearch& from);
  void MergeFrom(const IndexSearch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexSearch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.IndexSearch";
  }
  protected:
  explicit IndexSearch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTnameFieldNumber = 1,
    kValFieldNumber = 3,
    kFidsFieldNumber = 4,
    kFidFieldNumber = 2,
  };
  // string tname = 1;
  void clear_tname();
  const std::string& tname() const;
  void set_tname(const std::string& value);
  void set_tname(std::string&& value);
  void set_tname(const char* value);
  void set_tname(const char* value, size_t size);
  std::string* mutable_tname();
  std::string* release_tname();
  void set_allocated_tname(std::string* tname);
  private:
  const std::string& _internal_tname() const;
  void _internal_set_tname(const std::string& value);
  std::string* _internal_mutable_tname();
  public:

  // .dan.Eval val = 3;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const ::dan::Eval& val() const;
  ::dan::Eval* release_val();
  ::dan::Eval* mutable_val();
  void set_allocated_val(::dan::Eval* val);
  private:
  const ::dan::Eval& _internal_val() const;
  ::dan::Eval* _internal_mutable_val();
  public:
  void unsafe_arena_set_allocated_val(
      ::dan::Eval* val);
  ::dan::Eval* unsafe_arena_release_val();

  // .dan.IntVec fids = 4;
  bool has_fids() const;
  private:
  bool _internal_has_fids() const;
  public:
  void clear_fids();
  const ::dan::IntVec& fids() const;
  ::dan::IntVec* release_fids();
  ::dan::IntVec* mutable_fids();
  void set_allocated_fids(::dan::IntVec* fids);
  private:
  const ::dan::IntVec& _internal_fids() const;
  ::dan::IntVec* _internal_mutable_fids();
  public:
  void unsafe_arena_set_allocated_fids(
      ::dan::IntVec* fids);
  ::dan::IntVec* unsafe_arena_release_fids();

  // int64 fid = 2;
  void clear_fid();
  ::PROTOBUF_NAMESPACE_ID::int64 fid() const;
  void set_fid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_fid() const;
  void _internal_set_fid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.IndexSearch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tname_;
  ::dan::Eval* val_;
  ::dan::IntVec* fids_;
  ::PROTOBUF_NAMESPACE_ID::int64 fid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class AdjacentList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.AdjacentList) */ {
 public:
  inline AdjacentList() : AdjacentList(nullptr) {}
  virtual ~AdjacentList();

  AdjacentList(const AdjacentList& from);
  AdjacentList(AdjacentList&& from) noexcept
    : AdjacentList() {
    *this = ::std::move(from);
  }

  inline AdjacentList& operator=(const AdjacentList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdjacentList& operator=(AdjacentList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdjacentList& default_instance();

  static inline const AdjacentList* internal_default_instance() {
    return reinterpret_cast<const AdjacentList*>(
               &_AdjacentList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(AdjacentList& a, AdjacentList& b) {
    a.Swap(&b);
  }
  inline void Swap(AdjacentList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdjacentList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdjacentList* New() const final {
    return CreateMaybeMessage<AdjacentList>(nullptr);
  }

  AdjacentList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdjacentList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdjacentList& from);
  void MergeFrom(const AdjacentList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdjacentList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.AdjacentList";
  }
  protected:
  explicit AdjacentList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kSrcFieldNumber = 2,
    kFidsFieldNumber = 3,
    kVpidFieldNumber = 4,
    kIncomingFieldNumber = 5,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // .dan.Eval src = 2;
  bool has_src() const;
  private:
  bool _internal_has_src() const;
  public:
  void clear_src();
  const ::dan::Eval& src() const;
  ::dan::Eval* release_src();
  ::dan::Eval* mutable_src();
  void set_allocated_src(::dan::Eval* src);
  private:
  const ::dan::Eval& _internal_src() const;
  ::dan::Eval* _internal_mutable_src();
  public:
  void unsafe_arena_set_allocated_src(
      ::dan::Eval* src);
  ::dan::Eval* unsafe_arena_release_src();

  // .dan.IntVec fids = 3;
  bool has_fids() const;
  private:
  bool _internal_has_fids() const;
  public:
  void clear_fids();
  const ::dan::IntVec& fids() const;
  ::dan::IntVec* release_fids();
  ::dan::IntVec* mutable_fids();
  void set_allocated_fids(::dan::IntVec* fids);
  private:
  const ::dan::IntVec& _internal_fids() const;
  ::dan::IntVec* _internal_mutable_fids();
  public:
  void unsafe_arena_set_allocated_fids(
      ::dan::IntVec* fids);
  ::dan::IntVec* unsafe_arena_release_fids();

  // int32 vpid = 4;
  void clear_vpid();
  ::PROTOBUF_NAMESPACE_ID::int32 vpid() const;
  void set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vpid() const;
  void _internal_set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool incoming = 5;
  void clear_incoming();
  bool incoming() const;
  void set_incoming(bool value);
  private:
  bool _internal_incoming() const;
  void _internal_set_incoming(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dan.AdjacentList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::dan::Eval* src_;
  ::dan::IntVec* fids_;
  ::PROTOBUF_NAMESPACE_ID::int32 vpid_;
  bool incoming_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class AdjacentListResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.AdjacentListResult) */ {
 public:
  inline AdjacentListResult() : AdjacentListResult(nullptr) {}
  virtual ~AdjacentListResult();

  AdjacentListResult(const AdjacentListResult& from);
  AdjacentListResult(AdjacentListResult&& from) noexcept
    : AdjacentListResult() {
    *this = ::std::move(from);
  }

  inline AdjacentListResult& operator=(const AdjacentListResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdjacentListResult& operator=(AdjacentListResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdjacentListResult& default_instance();

  static inline const AdjacentListResult* internal_default_instance() {
    return reinterpret_cast<const AdjacentListResult*>(
               &_AdjacentListResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(AdjacentListResult& a, AdjacentListResult& b) {
    a.Swap(&b);
  }
  inline void Swap(AdjacentListResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdjacentListResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdjacentListResult* New() const final {
    return CreateMaybeMessage<AdjacentListResult>(nullptr);
  }

  AdjacentListResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdjacentListResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdjacentListResult& from);
  void MergeFrom(const AdjacentListResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdjacentListResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.AdjacentListResult";
  }
  protected:
  explicit AdjacentListResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestsFieldNumber = 1,
    kEpropsFieldNumber = 2,
    kNodesFieldNumber = 3,
  };
  // .dan.Table dests = 1;
  bool has_dests() const;
  private:
  bool _internal_has_dests() const;
  public:
  void clear_dests();
  const ::dan::Table& dests() const;
  ::dan::Table* release_dests();
  ::dan::Table* mutable_dests();
  void set_allocated_dests(::dan::Table* dests);
  private:
  const ::dan::Table& _internal_dests() const;
  ::dan::Table* _internal_mutable_dests();
  public:
  void unsafe_arena_set_allocated_dests(
      ::dan::Table* dests);
  ::dan::Table* unsafe_arena_release_dests();

  // .dan.Record eprops = 2;
  bool has_eprops() const;
  private:
  bool _internal_has_eprops() const;
  public:
  void clear_eprops();
  const ::dan::Record& eprops() const;
  ::dan::Record* release_eprops();
  ::dan::Record* mutable_eprops();
  void set_allocated_eprops(::dan::Record* eprops);
  private:
  const ::dan::Record& _internal_eprops() const;
  ::dan::Record* _internal_mutable_eprops();
  public:
  void unsafe_arena_set_allocated_eprops(
      ::dan::Record* eprops);
  ::dan::Record* unsafe_arena_release_eprops();

  // .dan.StrVec nodes = 3;
  bool has_nodes() const;
  private:
  bool _internal_has_nodes() const;
  public:
  void clear_nodes();
  const ::dan::StrVec& nodes() const;
  ::dan::StrVec* release_nodes();
  ::dan::StrVec* mutable_nodes();
  void set_allocated_nodes(::dan::StrVec* nodes);
  private:
  const ::dan::StrVec& _internal_nodes() const;
  ::dan::StrVec* _internal_mutable_nodes();
  public:
  void unsafe_arena_set_allocated_nodes(
      ::dan::StrVec* nodes);
  ::dan::StrVec* unsafe_arena_release_nodes();

  // @@protoc_insertion_point(class_scope:dan.AdjacentListResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::dan::Table* dests_;
  ::dan::Record* eprops_;
  ::dan::StrVec* nodes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetVertex PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.GetVertex) */ {
 public:
  inline GetVertex() : GetVertex(nullptr) {}
  virtual ~GetVertex();

  GetVertex(const GetVertex& from);
  GetVertex(GetVertex&& from) noexcept
    : GetVertex() {
    *this = ::std::move(from);
  }

  inline GetVertex& operator=(const GetVertex& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVertex& operator=(GetVertex&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetVertex& default_instance();

  static inline const GetVertex* internal_default_instance() {
    return reinterpret_cast<const GetVertex*>(
               &_GetVertex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GetVertex& a, GetVertex& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVertex* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVertex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetVertex* New() const final {
    return CreateMaybeMessage<GetVertex>(nullptr);
  }

  GetVertex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetVertex>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetVertex& from);
  void MergeFrom(const GetVertex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVertex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.GetVertex";
  }
  protected:
  explicit GetVertex(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kVkeyFieldNumber = 2,
    kFidsFieldNumber = 5,
    kVidFieldNumber = 4,
    kVpidFieldNumber = 3,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // .dan.Eval vkey = 2;
  bool has_vkey() const;
  private:
  bool _internal_has_vkey() const;
  public:
  void clear_vkey();
  const ::dan::Eval& vkey() const;
  ::dan::Eval* release_vkey();
  ::dan::Eval* mutable_vkey();
  void set_allocated_vkey(::dan::Eval* vkey);
  private:
  const ::dan::Eval& _internal_vkey() const;
  ::dan::Eval* _internal_mutable_vkey();
  public:
  void unsafe_arena_set_allocated_vkey(
      ::dan::Eval* vkey);
  ::dan::Eval* unsafe_arena_release_vkey();

  // .dan.IntVec fids = 5;
  bool has_fids() const;
  private:
  bool _internal_has_fids() const;
  public:
  void clear_fids();
  const ::dan::IntVec& fids() const;
  ::dan::IntVec* release_fids();
  ::dan::IntVec* mutable_fids();
  void set_allocated_fids(::dan::IntVec* fids);
  private:
  const ::dan::IntVec& _internal_fids() const;
  ::dan::IntVec* _internal_mutable_fids();
  public:
  void unsafe_arena_set_allocated_fids(
      ::dan::IntVec* fids);
  ::dan::IntVec* unsafe_arena_release_fids();

  // int64 vid = 4;
  void clear_vid();
  ::PROTOBUF_NAMESPACE_ID::int64 vid() const;
  void set_vid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_vid() const;
  void _internal_set_vid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 vpid = 3;
  void clear_vpid();
  ::PROTOBUF_NAMESPACE_ID::int32 vpid() const;
  void set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vpid() const;
  void _internal_set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.GetVertex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::dan::Eval* vkey_;
  ::dan::IntVec* fids_;
  ::PROTOBUF_NAMESPACE_ID::int64 vid_;
  ::PROTOBUF_NAMESPACE_ID::int32 vpid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class VertexList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.VertexList) */ {
 public:
  inline VertexList() : VertexList(nullptr) {}
  virtual ~VertexList();

  VertexList(const VertexList& from);
  VertexList(VertexList&& from) noexcept
    : VertexList() {
    *this = ::std::move(from);
  }

  inline VertexList& operator=(const VertexList& from) {
    CopyFrom(from);
    return *this;
  }
  inline VertexList& operator=(VertexList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VertexList& default_instance();

  static inline const VertexList* internal_default_instance() {
    return reinterpret_cast<const VertexList*>(
               &_VertexList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(VertexList& a, VertexList& b) {
    a.Swap(&b);
  }
  inline void Swap(VertexList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VertexList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VertexList* New() const final {
    return CreateMaybeMessage<VertexList>(nullptr);
  }

  VertexList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VertexList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VertexList& from);
  void MergeFrom(const VertexList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VertexList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.VertexList";
  }
  protected:
  explicit VertexList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVkeyFieldNumber = 1,
    kVpidFieldNumber = 2,
    kVpropFieldNumber = 3,
  };
  // .dan.Record vkey = 1;
  bool has_vkey() const;
  private:
  bool _internal_has_vkey() const;
  public:
  void clear_vkey();
  const ::dan::Record& vkey() const;
  ::dan::Record* release_vkey();
  ::dan::Record* mutable_vkey();
  void set_allocated_vkey(::dan::Record* vkey);
  private:
  const ::dan::Record& _internal_vkey() const;
  ::dan::Record* _internal_mutable_vkey();
  public:
  void unsafe_arena_set_allocated_vkey(
      ::dan::Record* vkey);
  ::dan::Record* unsafe_arena_release_vkey();

  // .dan.IntVec vpid = 2;
  bool has_vpid() const;
  private:
  bool _internal_has_vpid() const;
  public:
  void clear_vpid();
  const ::dan::IntVec& vpid() const;
  ::dan::IntVec* release_vpid();
  ::dan::IntVec* mutable_vpid();
  void set_allocated_vpid(::dan::IntVec* vpid);
  private:
  const ::dan::IntVec& _internal_vpid() const;
  ::dan::IntVec* _internal_mutable_vpid();
  public:
  void unsafe_arena_set_allocated_vpid(
      ::dan::IntVec* vpid);
  ::dan::IntVec* unsafe_arena_release_vpid();

  // .dan.Table vprop = 3;
  bool has_vprop() const;
  private:
  bool _internal_has_vprop() const;
  public:
  void clear_vprop();
  const ::dan::Table& vprop() const;
  ::dan::Table* release_vprop();
  ::dan::Table* mutable_vprop();
  void set_allocated_vprop(::dan::Table* vprop);
  private:
  const ::dan::Table& _internal_vprop() const;
  ::dan::Table* _internal_mutable_vprop();
  public:
  void unsafe_arena_set_allocated_vprop(
      ::dan::Table* vprop);
  ::dan::Table* unsafe_arena_release_vprop();

  // @@protoc_insertion_point(class_scope:dan.VertexList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::dan::Record* vkey_;
  ::dan::IntVec* vpid_;
  ::dan::Table* vprop_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class EdgeList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.EdgeList) */ {
 public:
  inline EdgeList() : EdgeList(nullptr) {}
  virtual ~EdgeList();

  EdgeList(const EdgeList& from);
  EdgeList(EdgeList&& from) noexcept
    : EdgeList() {
    *this = ::std::move(from);
  }

  inline EdgeList& operator=(const EdgeList& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdgeList& operator=(EdgeList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EdgeList& default_instance();

  static inline const EdgeList* internal_default_instance() {
    return reinterpret_cast<const EdgeList*>(
               &_EdgeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(EdgeList& a, EdgeList& b) {
    a.Swap(&b);
  }
  inline void Swap(EdgeList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdgeList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EdgeList* New() const final {
    return CreateMaybeMessage<EdgeList>(nullptr);
  }

  EdgeList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EdgeList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EdgeList& from);
  void MergeFrom(const EdgeList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.EdgeList";
  }
  protected:
  explicit EdgeList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDstFieldNumber = 2,
  };
  // .dan.Record src = 1;
  bool has_src() const;
  private:
  bool _internal_has_src() const;
  public:
  void clear_src();
  const ::dan::Record& src() const;
  ::dan::Record* release_src();
  ::dan::Record* mutable_src();
  void set_allocated_src(::dan::Record* src);
  private:
  const ::dan::Record& _internal_src() const;
  ::dan::Record* _internal_mutable_src();
  public:
  void unsafe_arena_set_allocated_src(
      ::dan::Record* src);
  ::dan::Record* unsafe_arena_release_src();

  // .dan.Record dst = 2;
  bool has_dst() const;
  private:
  bool _internal_has_dst() const;
  public:
  void clear_dst();
  const ::dan::Record& dst() const;
  ::dan::Record* release_dst();
  ::dan::Record* mutable_dst();
  void set_allocated_dst(::dan::Record* dst);
  private:
  const ::dan::Record& _internal_dst() const;
  ::dan::Record* _internal_mutable_dst();
  public:
  void unsafe_arena_set_allocated_dst(
      ::dan::Record* dst);
  ::dan::Record* unsafe_arena_release_dst();

  // @@protoc_insertion_point(class_scope:dan.EdgeList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::dan::Record* src_;
  ::dan::Record* dst_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class RemoteTask PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.RemoteTask) */ {
 public:
  inline RemoteTask() : RemoteTask(nullptr) {}
  virtual ~RemoteTask();

  RemoteTask(const RemoteTask& from);
  RemoteTask(RemoteTask&& from) noexcept
    : RemoteTask() {
    *this = ::std::move(from);
  }

  inline RemoteTask& operator=(const RemoteTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteTask& operator=(RemoteTask&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteTask& default_instance();

  static inline const RemoteTask* internal_default_instance() {
    return reinterpret_cast<const RemoteTask*>(
               &_RemoteTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(RemoteTask& a, RemoteTask& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteTask* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteTask* New() const final {
    return CreateMaybeMessage<RemoteTask>(nullptr);
  }

  RemoteTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteTask>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteTask& from);
  void MergeFrom(const RemoteTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.RemoteTask";
  }
  protected:
  explicit RemoteTask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuncFieldNumber = 1,
    kArgsFieldNumber = 2,
    kKargsFieldNumber = 3,
    kImmediateReturnFieldNumber = 4,
  };
  // bytes func = 1;
  void clear_func();
  const std::string& func() const;
  void set_func(const std::string& value);
  void set_func(std::string&& value);
  void set_func(const char* value);
  void set_func(const void* value, size_t size);
  std::string* mutable_func();
  std::string* release_func();
  void set_allocated_func(std::string* func);
  private:
  const std::string& _internal_func() const;
  void _internal_set_func(const std::string& value);
  std::string* _internal_mutable_func();
  public:

  // bytes args = 2;
  void clear_args();
  const std::string& args() const;
  void set_args(const std::string& value);
  void set_args(std::string&& value);
  void set_args(const char* value);
  void set_args(const void* value, size_t size);
  std::string* mutable_args();
  std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // bytes kargs = 3;
  void clear_kargs();
  const std::string& kargs() const;
  void set_kargs(const std::string& value);
  void set_kargs(std::string&& value);
  void set_kargs(const char* value);
  void set_kargs(const void* value, size_t size);
  std::string* mutable_kargs();
  std::string* release_kargs();
  void set_allocated_kargs(std::string* kargs);
  private:
  const std::string& _internal_kargs() const;
  void _internal_set_kargs(const std::string& value);
  std::string* _internal_mutable_kargs();
  public:

  // bool immediate_return = 4;
  void clear_immediate_return();
  bool immediate_return() const;
  void set_immediate_return(bool value);
  private:
  bool _internal_immediate_return() const;
  void _internal_set_immediate_return(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dan.RemoteTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr func_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kargs_;
  bool immediate_return_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class RemoteResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.RemoteResult) */ {
 public:
  inline RemoteResult() : RemoteResult(nullptr) {}
  virtual ~RemoteResult();

  RemoteResult(const RemoteResult& from);
  RemoteResult(RemoteResult&& from) noexcept
    : RemoteResult() {
    *this = ::std::move(from);
  }

  inline RemoteResult& operator=(const RemoteResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteResult& operator=(RemoteResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteResult& default_instance();

  static inline const RemoteResult* internal_default_instance() {
    return reinterpret_cast<const RemoteResult*>(
               &_RemoteResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(RemoteResult& a, RemoteResult& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteResult* New() const final {
    return CreateMaybeMessage<RemoteResult>(nullptr);
  }

  RemoteResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteResult& from);
  void MergeFrom(const RemoteResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.RemoteResult";
  }
  protected:
  explicit RemoteResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // bytes results = 1;
  void clear_results();
  const std::string& results() const;
  void set_results(const std::string& value);
  void set_results(std::string&& value);
  void set_results(const char* value);
  void set_results(const void* value, size_t size);
  std::string* mutable_results();
  std::string* release_results();
  void set_allocated_results(std::string* results);
  private:
  const std::string& _internal_results() const;
  void _internal_set_results(const std::string& value);
  std::string* _internal_mutable_results();
  public:

  // @@protoc_insertion_point(class_scope:dan.RemoteResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class RemoteObject PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.RemoteObject) */ {
 public:
  inline RemoteObject() : RemoteObject(nullptr) {}
  virtual ~RemoteObject();

  RemoteObject(const RemoteObject& from);
  RemoteObject(RemoteObject&& from) noexcept
    : RemoteObject() {
    *this = ::std::move(from);
  }

  inline RemoteObject& operator=(const RemoteObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteObject& operator=(RemoteObject&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteObject& default_instance();

  static inline const RemoteObject* internal_default_instance() {
    return reinterpret_cast<const RemoteObject*>(
               &_RemoteObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(RemoteObject& a, RemoteObject& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteObject* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteObject* New() const final {
    return CreateMaybeMessage<RemoteObject>(nullptr);
  }

  RemoteObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteObject>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteObject& from);
  void MergeFrom(const RemoteObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteObject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.RemoteObject";
  }
  protected:
  explicit RemoteObject(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClsFieldNumber = 1,
    kArgsFieldNumber = 2,
    kKargsFieldNumber = 3,
  };
  // bytes cls = 1;
  void clear_cls();
  const std::string& cls() const;
  void set_cls(const std::string& value);
  void set_cls(std::string&& value);
  void set_cls(const char* value);
  void set_cls(const void* value, size_t size);
  std::string* mutable_cls();
  std::string* release_cls();
  void set_allocated_cls(std::string* cls);
  private:
  const std::string& _internal_cls() const;
  void _internal_set_cls(const std::string& value);
  std::string* _internal_mutable_cls();
  public:

  // bytes args = 2;
  void clear_args();
  const std::string& args() const;
  void set_args(const std::string& value);
  void set_args(std::string&& value);
  void set_args(const char* value);
  void set_args(const void* value, size_t size);
  std::string* mutable_args();
  std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // bytes kargs = 3;
  void clear_kargs();
  const std::string& kargs() const;
  void set_kargs(const std::string& value);
  void set_kargs(std::string&& value);
  void set_kargs(const char* value);
  void set_kargs(const void* value, size_t size);
  std::string* mutable_kargs();
  std::string* release_kargs();
  void set_allocated_kargs(std::string* kargs);
  private:
  const std::string& _internal_kargs() const;
  void _internal_set_kargs(const std::string& value);
  std::string* _internal_mutable_kargs();
  public:

  // @@protoc_insertion_point(class_scope:dan.RemoteObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kargs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class RemoteTaskResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.RemoteTaskResult) */ {
 public:
  inline RemoteTaskResult() : RemoteTaskResult(nullptr) {}
  virtual ~RemoteTaskResult();

  RemoteTaskResult(const RemoteTaskResult& from);
  RemoteTaskResult(RemoteTaskResult&& from) noexcept
    : RemoteTaskResult() {
    *this = ::std::move(from);
  }

  inline RemoteTaskResult& operator=(const RemoteTaskResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteTaskResult& operator=(RemoteTaskResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteTaskResult& default_instance();

  static inline const RemoteTaskResult* internal_default_instance() {
    return reinterpret_cast<const RemoteTaskResult*>(
               &_RemoteTaskResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(RemoteTaskResult& a, RemoteTaskResult& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteTaskResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteTaskResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteTaskResult* New() const final {
    return CreateMaybeMessage<RemoteTaskResult>(nullptr);
  }

  RemoteTaskResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteTaskResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteTaskResult& from);
  void MergeFrom(const RemoteTaskResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteTaskResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.RemoteTaskResult";
  }
  protected:
  explicit RemoteTaskResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
  };
  // int64 object_id = 1;
  void clear_object_id();
  ::PROTOBUF_NAMESPACE_ID::int64 object_id() const;
  void set_object_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_object_id() const;
  void _internal_set_object_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.RemoteTaskResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 object_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class RemoteObjectTask PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.RemoteObjectTask) */ {
 public:
  inline RemoteObjectTask() : RemoteObjectTask(nullptr) {}
  virtual ~RemoteObjectTask();

  RemoteObjectTask(const RemoteObjectTask& from);
  RemoteObjectTask(RemoteObjectTask&& from) noexcept
    : RemoteObjectTask() {
    *this = ::std::move(from);
  }

  inline RemoteObjectTask& operator=(const RemoteObjectTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteObjectTask& operator=(RemoteObjectTask&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteObjectTask& default_instance();

  static inline const RemoteObjectTask* internal_default_instance() {
    return reinterpret_cast<const RemoteObjectTask*>(
               &_RemoteObjectTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(RemoteObjectTask& a, RemoteObjectTask& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteObjectTask* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteObjectTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteObjectTask* New() const final {
    return CreateMaybeMessage<RemoteObjectTask>(nullptr);
  }

  RemoteObjectTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteObjectTask>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteObjectTask& from);
  void MergeFrom(const RemoteObjectTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteObjectTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.RemoteObjectTask";
  }
  protected:
  explicit RemoteObjectTask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFnameFieldNumber = 2,
    kArgsFieldNumber = 3,
    kKargsFieldNumber = 4,
    kObjectIdFieldNumber = 1,
    kImmediateReturnFieldNumber = 5,
  };
  // string fname = 2;
  void clear_fname();
  const std::string& fname() const;
  void set_fname(const std::string& value);
  void set_fname(std::string&& value);
  void set_fname(const char* value);
  void set_fname(const char* value, size_t size);
  std::string* mutable_fname();
  std::string* release_fname();
  void set_allocated_fname(std::string* fname);
  private:
  const std::string& _internal_fname() const;
  void _internal_set_fname(const std::string& value);
  std::string* _internal_mutable_fname();
  public:

  // bytes args = 3;
  void clear_args();
  const std::string& args() const;
  void set_args(const std::string& value);
  void set_args(std::string&& value);
  void set_args(const char* value);
  void set_args(const void* value, size_t size);
  std::string* mutable_args();
  std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // bytes kargs = 4;
  void clear_kargs();
  const std::string& kargs() const;
  void set_kargs(const std::string& value);
  void set_kargs(std::string&& value);
  void set_kargs(const char* value);
  void set_kargs(const void* value, size_t size);
  std::string* mutable_kargs();
  std::string* release_kargs();
  void set_allocated_kargs(std::string* kargs);
  private:
  const std::string& _internal_kargs() const;
  void _internal_set_kargs(const std::string& value);
  std::string* _internal_mutable_kargs();
  public:

  // int64 object_id = 1;
  void clear_object_id();
  ::PROTOBUF_NAMESPACE_ID::int64 object_id() const;
  void set_object_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_object_id() const;
  void _internal_set_object_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool immediate_return = 5;
  void clear_immediate_return();
  bool immediate_return() const;
  void set_immediate_return(bool value);
  private:
  bool _internal_immediate_return() const;
  void _internal_set_immediate_return(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dan.RemoteObjectTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kargs_;
  ::PROTOBUF_NAMESPACE_ID::int64 object_id_;
  bool immediate_return_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class LoadGraphFromFolder PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.LoadGraphFromFolder) */ {
 public:
  inline LoadGraphFromFolder() : LoadGraphFromFolder(nullptr) {}
  virtual ~LoadGraphFromFolder();

  LoadGraphFromFolder(const LoadGraphFromFolder& from);
  LoadGraphFromFolder(LoadGraphFromFolder&& from) noexcept
    : LoadGraphFromFolder() {
    *this = ::std::move(from);
  }

  inline LoadGraphFromFolder& operator=(const LoadGraphFromFolder& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadGraphFromFolder& operator=(LoadGraphFromFolder&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadGraphFromFolder& default_instance();

  static inline const LoadGraphFromFolder* internal_default_instance() {
    return reinterpret_cast<const LoadGraphFromFolder*>(
               &_LoadGraphFromFolder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(LoadGraphFromFolder& a, LoadGraphFromFolder& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadGraphFromFolder* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadGraphFromFolder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadGraphFromFolder* New() const final {
    return CreateMaybeMessage<LoadGraphFromFolder>(nullptr);
  }

  LoadGraphFromFolder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadGraphFromFolder>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadGraphFromFolder& from);
  void MergeFrom(const LoadGraphFromFolder& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadGraphFromFolder* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.LoadGraphFromFolder";
  }
  protected:
  explicit LoadGraphFromFolder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEschemaFieldNumber = 3,
    kFolderFieldNumber = 1,
    kGnameFieldNumber = 2,
    kVptypeFieldNumber = 4,
    kEptypeFieldNumber = 5,
    kNodesFieldNumber = 10,
    kIncomingFieldNumber = 6,
    kMergeFieldNumber = 7,
    kIsPartitionFieldNumber = 8,
    kPartTypeFieldNumber = 9,
  };
  // repeated .dan.Field eschema = 3;
  int eschema_size() const;
  private:
  int _internal_eschema_size() const;
  public:
  void clear_eschema();
  ::dan::Field* mutable_eschema(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >*
      mutable_eschema();
  private:
  const ::dan::Field& _internal_eschema(int index) const;
  ::dan::Field* _internal_add_eschema();
  public:
  const ::dan::Field& eschema(int index) const;
  ::dan::Field* add_eschema();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >&
      eschema() const;

  // string folder = 1;
  void clear_folder();
  const std::string& folder() const;
  void set_folder(const std::string& value);
  void set_folder(std::string&& value);
  void set_folder(const char* value);
  void set_folder(const char* value, size_t size);
  std::string* mutable_folder();
  std::string* release_folder();
  void set_allocated_folder(std::string* folder);
  private:
  const std::string& _internal_folder() const;
  void _internal_set_folder(const std::string& value);
  std::string* _internal_mutable_folder();
  public:

  // string gname = 2;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // string vptype = 4;
  void clear_vptype();
  const std::string& vptype() const;
  void set_vptype(const std::string& value);
  void set_vptype(std::string&& value);
  void set_vptype(const char* value);
  void set_vptype(const char* value, size_t size);
  std::string* mutable_vptype();
  std::string* release_vptype();
  void set_allocated_vptype(std::string* vptype);
  private:
  const std::string& _internal_vptype() const;
  void _internal_set_vptype(const std::string& value);
  std::string* _internal_mutable_vptype();
  public:

  // string eptype = 5;
  void clear_eptype();
  const std::string& eptype() const;
  void set_eptype(const std::string& value);
  void set_eptype(std::string&& value);
  void set_eptype(const char* value);
  void set_eptype(const char* value, size_t size);
  std::string* mutable_eptype();
  std::string* release_eptype();
  void set_allocated_eptype(std::string* eptype);
  private:
  const std::string& _internal_eptype() const;
  void _internal_set_eptype(const std::string& value);
  std::string* _internal_mutable_eptype();
  public:

  // .dan.StrVec nodes = 10;
  bool has_nodes() const;
  private:
  bool _internal_has_nodes() const;
  public:
  void clear_nodes();
  const ::dan::StrVec& nodes() const;
  ::dan::StrVec* release_nodes();
  ::dan::StrVec* mutable_nodes();
  void set_allocated_nodes(::dan::StrVec* nodes);
  private:
  const ::dan::StrVec& _internal_nodes() const;
  ::dan::StrVec* _internal_mutable_nodes();
  public:
  void unsafe_arena_set_allocated_nodes(
      ::dan::StrVec* nodes);
  ::dan::StrVec* unsafe_arena_release_nodes();

  // bool incoming = 6;
  void clear_incoming();
  bool incoming() const;
  void set_incoming(bool value);
  private:
  bool _internal_incoming() const;
  void _internal_set_incoming(bool value);
  public:

  // bool merge = 7;
  void clear_merge();
  bool merge() const;
  void set_merge(bool value);
  private:
  bool _internal_merge() const;
  void _internal_set_merge(bool value);
  public:

  // bool is_partition = 8;
  void clear_is_partition();
  bool is_partition() const;
  void set_is_partition(bool value);
  private:
  bool _internal_is_partition() const;
  void _internal_set_is_partition(bool value);
  public:

  // int32 part_type = 9;
  void clear_part_type();
  ::PROTOBUF_NAMESPACE_ID::int32 part_type() const;
  void set_part_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_part_type() const;
  void _internal_set_part_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.LoadGraphFromFolder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field > eschema_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr folder_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vptype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eptype_;
  ::dan::StrVec* nodes_;
  bool incoming_;
  bool merge_;
  bool is_partition_;
  ::PROTOBUF_NAMESPACE_ID::int32 part_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class VertexExists PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.VertexExists) */ {
 public:
  inline VertexExists() : VertexExists(nullptr) {}
  virtual ~VertexExists();

  VertexExists(const VertexExists& from);
  VertexExists(VertexExists&& from) noexcept
    : VertexExists() {
    *this = ::std::move(from);
  }

  inline VertexExists& operator=(const VertexExists& from) {
    CopyFrom(from);
    return *this;
  }
  inline VertexExists& operator=(VertexExists&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VertexExists& default_instance();

  static inline const VertexExists* internal_default_instance() {
    return reinterpret_cast<const VertexExists*>(
               &_VertexExists_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(VertexExists& a, VertexExists& b) {
    a.Swap(&b);
  }
  inline void Swap(VertexExists* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VertexExists* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VertexExists* New() const final {
    return CreateMaybeMessage<VertexExists>(nullptr);
  }

  VertexExists* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VertexExists>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VertexExists& from);
  void MergeFrom(const VertexExists& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VertexExists* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.VertexExists";
  }
  protected:
  explicit VertexExists(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kVkeyFieldNumber = 2,
    kVpidFieldNumber = 3,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // .dan.Eval vkey = 2;
  bool has_vkey() const;
  private:
  bool _internal_has_vkey() const;
  public:
  void clear_vkey();
  const ::dan::Eval& vkey() const;
  ::dan::Eval* release_vkey();
  ::dan::Eval* mutable_vkey();
  void set_allocated_vkey(::dan::Eval* vkey);
  private:
  const ::dan::Eval& _internal_vkey() const;
  ::dan::Eval* _internal_mutable_vkey();
  public:
  void unsafe_arena_set_allocated_vkey(
      ::dan::Eval* vkey);
  ::dan::Eval* unsafe_arena_release_vkey();

  // int32 vpid = 3;
  void clear_vpid();
  ::PROTOBUF_NAMESPACE_ID::int32 vpid() const;
  void set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vpid() const;
  void _internal_set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.VertexExists)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::dan::Eval* vkey_;
  ::PROTOBUF_NAMESPACE_ID::int32 vpid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class TestStream PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.TestStream) */ {
 public:
  inline TestStream() : TestStream(nullptr) {}
  virtual ~TestStream();

  TestStream(const TestStream& from);
  TestStream(TestStream&& from) noexcept
    : TestStream() {
    *this = ::std::move(from);
  }

  inline TestStream& operator=(const TestStream& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestStream& operator=(TestStream&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TestStream& default_instance();

  static inline const TestStream* internal_default_instance() {
    return reinterpret_cast<const TestStream*>(
               &_TestStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(TestStream& a, TestStream& b) {
    a.Swap(&b);
  }
  inline void Swap(TestStream* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestStream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TestStream* New() const final {
    return CreateMaybeMessage<TestStream>(nullptr);
  }

  TestStream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TestStream>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TestStream& from);
  void MergeFrom(const TestStream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestStream* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.TestStream";
  }
  protected:
  explicit TestStream(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .dan.Table data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::dan::Table& data() const;
  ::dan::Table* release_data();
  ::dan::Table* mutable_data();
  void set_allocated_data(::dan::Table* data);
  private:
  const ::dan::Table& _internal_data() const;
  ::dan::Table* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::dan::Table* data);
  ::dan::Table* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:dan.TestStream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::dan::Table* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class HostInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.HostInfo) */ {
 public:
  inline HostInfo() : HostInfo(nullptr) {}
  virtual ~HostInfo();

  HostInfo(const HostInfo& from);
  HostInfo(HostInfo&& from) noexcept
    : HostInfo() {
    *this = ::std::move(from);
  }

  inline HostInfo& operator=(const HostInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostInfo& operator=(HostInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HostInfo& default_instance();

  static inline const HostInfo* internal_default_instance() {
    return reinterpret_cast<const HostInfo*>(
               &_HostInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(HostInfo& a, HostInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(HostInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HostInfo* New() const final {
    return CreateMaybeMessage<HostInfo>(nullptr);
  }

  HostInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HostInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HostInfo& from);
  void MergeFrom(const HostInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.HostInfo";
  }
  protected:
  explicit HostInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string addr = 1;
  void clear_addr();
  const std::string& addr() const;
  void set_addr(const std::string& value);
  void set_addr(std::string&& value);
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  std::string* mutable_addr();
  std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // int32 port = 2;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.HostInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class Binary PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.Binary) */ {
 public:
  inline Binary() : Binary(nullptr) {}
  virtual ~Binary();

  Binary(const Binary& from);
  Binary(Binary&& from) noexcept
    : Binary() {
    *this = ::std::move(from);
  }

  inline Binary& operator=(const Binary& from) {
    CopyFrom(from);
    return *this;
  }
  inline Binary& operator=(Binary&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Binary& default_instance();

  static inline const Binary* internal_default_instance() {
    return reinterpret_cast<const Binary*>(
               &_Binary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(Binary& a, Binary& b) {
    a.Swap(&b);
  }
  inline void Swap(Binary* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Binary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Binary* New() const final {
    return CreateMaybeMessage<Binary>(nullptr);
  }

  Binary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Binary>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Binary& from);
  void MergeFrom(const Binary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Binary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.Binary";
  }
  protected:
  explicit Binary(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // bytes v = 1;
  void clear_v();
  const std::string& v() const;
  void set_v(const std::string& value);
  void set_v(std::string&& value);
  void set_v(const char* value);
  void set_v(const void* value, size_t size);
  std::string* mutable_v();
  std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // @@protoc_insertion_point(class_scope:dan.Binary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class MergeInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.MergeInfo) */ {
 public:
  inline MergeInfo() : MergeInfo(nullptr) {}
  virtual ~MergeInfo();

  MergeInfo(const MergeInfo& from);
  MergeInfo(MergeInfo&& from) noexcept
    : MergeInfo() {
    *this = ::std::move(from);
  }

  inline MergeInfo& operator=(const MergeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MergeInfo& operator=(MergeInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MergeInfo& default_instance();

  static inline const MergeInfo* internal_default_instance() {
    return reinterpret_cast<const MergeInfo*>(
               &_MergeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(MergeInfo& a, MergeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MergeInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MergeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MergeInfo* New() const final {
    return CreateMaybeMessage<MergeInfo>(nullptr);
  }

  MergeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MergeInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MergeInfo& from);
  void MergeFrom(const MergeInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MergeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.MergeInfo";
  }
  protected:
  explicit MergeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kLeastFieldNumber = 2,
    kNumSplitFieldNumber = 3,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // int32 least = 2;
  void clear_least();
  ::PROTOBUF_NAMESPACE_ID::int32 least() const;
  void set_least(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_least() const;
  void _internal_set_least(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 num_split = 3;
  void clear_num_split();
  ::PROTOBUF_NAMESPACE_ID::int32 num_split() const;
  void set_num_split(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_split() const;
  void _internal_set_num_split(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.MergeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::PROTOBUF_NAMESPACE_ID::int32 least_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_split_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class TransferBinary PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.TransferBinary) */ {
 public:
  inline TransferBinary() : TransferBinary(nullptr) {}
  virtual ~TransferBinary();

  TransferBinary(const TransferBinary& from);
  TransferBinary(TransferBinary&& from) noexcept
    : TransferBinary() {
    *this = ::std::move(from);
  }

  inline TransferBinary& operator=(const TransferBinary& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferBinary& operator=(TransferBinary&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransferBinary& default_instance();

  static inline const TransferBinary* internal_default_instance() {
    return reinterpret_cast<const TransferBinary*>(
               &_TransferBinary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(TransferBinary& a, TransferBinary& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferBinary* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferBinary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransferBinary* New() const final {
    return CreateMaybeMessage<TransferBinary>(nullptr);
  }

  TransferBinary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferBinary>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransferBinary& from);
  void MergeFrom(const TransferBinary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferBinary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.TransferBinary";
  }
  protected:
  explicit TransferBinary(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kBinaryFieldNumber = 5,
    kTypeFieldNumber = 1,
    kPaIdFieldNumber = 3,
    kSgmtIdFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .dan.Binary binary = 5;
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;
  public:
  void clear_binary();
  const ::dan::Binary& binary() const;
  ::dan::Binary* release_binary();
  ::dan::Binary* mutable_binary();
  void set_allocated_binary(::dan::Binary* binary);
  private:
  const ::dan::Binary& _internal_binary() const;
  ::dan::Binary* _internal_mutable_binary();
  public:
  void unsafe_arena_set_allocated_binary(
      ::dan::Binary* binary);
  ::dan::Binary* unsafe_arena_release_binary();

  // int32 type = 1;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 pa_id = 3;
  void clear_pa_id();
  ::PROTOBUF_NAMESPACE_ID::int32 pa_id() const;
  void set_pa_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pa_id() const;
  void _internal_set_pa_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 sgmt_id = 4;
  void clear_sgmt_id();
  ::PROTOBUF_NAMESPACE_ID::int32 sgmt_id() const;
  void set_sgmt_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sgmt_id() const;
  void _internal_set_sgmt_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.TransferBinary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::dan::Binary* binary_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 pa_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 sgmt_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class MemoryStat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.MemoryStat) */ {
 public:
  inline MemoryStat() : MemoryStat(nullptr) {}
  virtual ~MemoryStat();

  MemoryStat(const MemoryStat& from);
  MemoryStat(MemoryStat&& from) noexcept
    : MemoryStat() {
    *this = ::std::move(from);
  }

  inline MemoryStat& operator=(const MemoryStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoryStat& operator=(MemoryStat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MemoryStat& default_instance();

  static inline const MemoryStat* internal_default_instance() {
    return reinterpret_cast<const MemoryStat*>(
               &_MemoryStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(MemoryStat& a, MemoryStat& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoryStat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemoryStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MemoryStat* New() const final {
    return CreateMaybeMessage<MemoryStat>(nullptr);
  }

  MemoryStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MemoryStat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MemoryStat& from);
  void MergeFrom(const MemoryStat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemoryStat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.MemoryStat";
  }
  protected:
  explicit MemoryStat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kNodesFieldNumber = 4,
    kVerboseFieldNumber = 1,
    kLevelFieldNumber = 3,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .dan.StrVec nodes = 4;
  bool has_nodes() const;
  private:
  bool _internal_has_nodes() const;
  public:
  void clear_nodes();
  const ::dan::StrVec& nodes() const;
  ::dan::StrVec* release_nodes();
  ::dan::StrVec* mutable_nodes();
  void set_allocated_nodes(::dan::StrVec* nodes);
  private:
  const ::dan::StrVec& _internal_nodes() const;
  ::dan::StrVec* _internal_mutable_nodes();
  public:
  void unsafe_arena_set_allocated_nodes(
      ::dan::StrVec* nodes);
  ::dan::StrVec* unsafe_arena_release_nodes();

  // bool verbose = 1;
  void clear_verbose();
  bool verbose() const;
  void set_verbose(bool value);
  private:
  bool _internal_verbose() const;
  void _internal_set_verbose(bool value);
  public:

  // int32 level = 3;
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::int32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_level() const;
  void _internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.MemoryStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::dan::StrVec* nodes_;
  bool verbose_;
  ::PROTOBUF_NAMESPACE_ID::int32 level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class APPNP PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.APPNP) */ {
 public:
  inline APPNP() : APPNP(nullptr) {}
  virtual ~APPNP();

  APPNP(const APPNP& from);
  APPNP(APPNP&& from) noexcept
    : APPNP() {
    *this = ::std::move(from);
  }

  inline APPNP& operator=(const APPNP& from) {
    CopyFrom(from);
    return *this;
  }
  inline APPNP& operator=(APPNP&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const APPNP& default_instance();

  static inline const APPNP* internal_default_instance() {
    return reinterpret_cast<const APPNP*>(
               &_APPNP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(APPNP& a, APPNP& b) {
    a.Swap(&b);
  }
  inline void Swap(APPNP* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APPNP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline APPNP* New() const final {
    return CreateMaybeMessage<APPNP>(nullptr);
  }

  APPNP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<APPNP>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const APPNP& from);
  void MergeFrom(const APPNP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APPNP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.APPNP";
  }
  protected:
  explicit APPNP(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlphaFieldNumber = 1,
    kKFieldNumber = 2,
  };
  // float alpha = 1;
  void clear_alpha();
  float alpha() const;
  void set_alpha(float value);
  private:
  float _internal_alpha() const;
  void _internal_set_alpha(float value);
  public:

  // int32 k = 2;
  void clear_k();
  ::PROTOBUF_NAMESPACE_ID::int32 k() const;
  void set_k(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_k() const;
  void _internal_set_k(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.APPNP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float alpha_;
  ::PROTOBUF_NAMESPACE_ID::int32 k_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GAT PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.GAT) */ {
 public:
  inline GAT() : GAT(nullptr) {}
  virtual ~GAT();

  GAT(const GAT& from);
  GAT(GAT&& from) noexcept
    : GAT() {
    *this = ::std::move(from);
  }

  inline GAT& operator=(const GAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline GAT& operator=(GAT&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GAT& default_instance();

  static inline const GAT* internal_default_instance() {
    return reinterpret_cast<const GAT*>(
               &_GAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(GAT& a, GAT& b) {
    a.Swap(&b);
  }
  inline void Swap(GAT* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GAT* New() const final {
    return CreateMaybeMessage<GAT>(nullptr);
  }

  GAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GAT>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GAT& from);
  void MergeFrom(const GAT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GAT* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.GAT";
  }
  protected:
  explicit GAT(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumHeadFieldNumber = 1,
    kAggFieldNumber = 2,
    kImportanceSplFieldNumber = 3,
  };
  // int32 num_head = 1;
  void clear_num_head();
  ::PROTOBUF_NAMESPACE_ID::int32 num_head() const;
  void set_num_head(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_head() const;
  void _internal_set_num_head(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool agg = 2;
  void clear_agg();
  bool agg() const;
  void set_agg(bool value);
  private:
  bool _internal_agg() const;
  void _internal_set_agg(bool value);
  public:

  // int32 importance_spl = 3;
  void clear_importance_spl();
  ::PROTOBUF_NAMESPACE_ID::int32 importance_spl() const;
  void set_importance_spl(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_importance_spl() const;
  void _internal_set_importance_spl(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.GAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_head_;
  bool agg_;
  ::PROTOBUF_NAMESPACE_ID::int32 importance_spl_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class ModelInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.ModelInfo) */ {
 public:
  inline ModelInfo() : ModelInfo(nullptr) {}
  virtual ~ModelInfo();

  ModelInfo(const ModelInfo& from);
  ModelInfo(ModelInfo&& from) noexcept
    : ModelInfo() {
    *this = ::std::move(from);
  }

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInfo& operator=(ModelInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelInfo& default_instance();

  enum MCase {
    kAppnp = 1,
    kGat = 2,
    M_NOT_SET = 0,
  };

  static inline const ModelInfo* internal_default_instance() {
    return reinterpret_cast<const ModelInfo*>(
               &_ModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(ModelInfo& a, ModelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo* New() const final {
    return CreateMaybeMessage<ModelInfo>(nullptr);
  }

  ModelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.ModelInfo";
  }
  protected:
  explicit ModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppnpFieldNumber = 1,
    kGatFieldNumber = 2,
  };
  // .dan.APPNP appnp = 1;
  bool has_appnp() const;
  private:
  bool _internal_has_appnp() const;
  public:
  void clear_appnp();
  const ::dan::APPNP& appnp() const;
  ::dan::APPNP* release_appnp();
  ::dan::APPNP* mutable_appnp();
  void set_allocated_appnp(::dan::APPNP* appnp);
  private:
  const ::dan::APPNP& _internal_appnp() const;
  ::dan::APPNP* _internal_mutable_appnp();
  public:
  void unsafe_arena_set_allocated_appnp(
      ::dan::APPNP* appnp);
  ::dan::APPNP* unsafe_arena_release_appnp();

  // .dan.GAT gat = 2;
  bool has_gat() const;
  private:
  bool _internal_has_gat() const;
  public:
  void clear_gat();
  const ::dan::GAT& gat() const;
  ::dan::GAT* release_gat();
  ::dan::GAT* mutable_gat();
  void set_allocated_gat(::dan::GAT* gat);
  private:
  const ::dan::GAT& _internal_gat() const;
  ::dan::GAT* _internal_mutable_gat();
  public:
  void unsafe_arena_set_allocated_gat(
      ::dan::GAT* gat);
  ::dan::GAT* unsafe_arena_release_gat();

  void clear_m();
  MCase m_case() const;
  // @@protoc_insertion_point(class_scope:dan.ModelInfo)
 private:
  class _Internal;
  void set_has_appnp();
  void set_has_gat();

  inline bool has_m() const;
  inline void clear_has_m();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MUnion {
    MUnion() {}
    ::dan::APPNP* appnp_;
    ::dan::GAT* gat_;
  } m_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class NodeClassifierInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dan.NodeClassifierInfo) */ {
 public:
  inline NodeClassifierInfo() : NodeClassifierInfo(nullptr) {}
  virtual ~NodeClassifierInfo();

  NodeClassifierInfo(const NodeClassifierInfo& from);
  NodeClassifierInfo(NodeClassifierInfo&& from) noexcept
    : NodeClassifierInfo() {
    *this = ::std::move(from);
  }

  inline NodeClassifierInfo& operator=(const NodeClassifierInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeClassifierInfo& operator=(NodeClassifierInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeClassifierInfo& default_instance();

  static inline const NodeClassifierInfo* internal_default_instance() {
    return reinterpret_cast<const NodeClassifierInfo*>(
               &_NodeClassifierInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(NodeClassifierInfo& a, NodeClassifierInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeClassifierInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeClassifierInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeClassifierInfo* New() const final {
    return CreateMaybeMessage<NodeClassifierInfo>(nullptr);
  }

  NodeClassifierInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeClassifierInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeClassifierInfo& from);
  void MergeFrom(const NodeClassifierInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeClassifierInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dan.NodeClassifierInfo";
  }
  protected:
  explicit NodeClassifierInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_interface_2eproto);
    return ::descriptor_table_interface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGnameFieldNumber = 1,
    kLogFileFieldNumber = 12,
    kFidsFieldNumber = 2,
    kModelInfoFieldNumber = 11,
    kInputSizeFieldNumber = 3,
    kHiddenSizeFieldNumber = 4,
    kNumClassFieldNumber = 5,
    kDropoutFieldNumber = 6,
    kLearningRateFieldNumber = 7,
    kDataUpdateIntervalFieldNumber = 8,
    kMergeManuallyFieldNumber = 9,
    kNumEpochsFieldNumber = 10,
  };
  // string gname = 1;
  void clear_gname();
  const std::string& gname() const;
  void set_gname(const std::string& value);
  void set_gname(std::string&& value);
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  std::string* mutable_gname();
  std::string* release_gname();
  void set_allocated_gname(std::string* gname);
  private:
  const std::string& _internal_gname() const;
  void _internal_set_gname(const std::string& value);
  std::string* _internal_mutable_gname();
  public:

  // string log_file = 12;
  void clear_log_file();
  const std::string& log_file() const;
  void set_log_file(const std::string& value);
  void set_log_file(std::string&& value);
  void set_log_file(const char* value);
  void set_log_file(const char* value, size_t size);
  std::string* mutable_log_file();
  std::string* release_log_file();
  void set_allocated_log_file(std::string* log_file);
  private:
  const std::string& _internal_log_file() const;
  void _internal_set_log_file(const std::string& value);
  std::string* _internal_mutable_log_file();
  public:

  // .dan.IntVec fids = 2;
  bool has_fids() const;
  private:
  bool _internal_has_fids() const;
  public:
  void clear_fids();
  const ::dan::IntVec& fids() const;
  ::dan::IntVec* release_fids();
  ::dan::IntVec* mutable_fids();
  void set_allocated_fids(::dan::IntVec* fids);
  private:
  const ::dan::IntVec& _internal_fids() const;
  ::dan::IntVec* _internal_mutable_fids();
  public:
  void unsafe_arena_set_allocated_fids(
      ::dan::IntVec* fids);
  ::dan::IntVec* unsafe_arena_release_fids();

  // .dan.ModelInfo model_info = 11;
  bool has_model_info() const;
  private:
  bool _internal_has_model_info() const;
  public:
  void clear_model_info();
  const ::dan::ModelInfo& model_info() const;
  ::dan::ModelInfo* release_model_info();
  ::dan::ModelInfo* mutable_model_info();
  void set_allocated_model_info(::dan::ModelInfo* model_info);
  private:
  const ::dan::ModelInfo& _internal_model_info() const;
  ::dan::ModelInfo* _internal_mutable_model_info();
  public:
  void unsafe_arena_set_allocated_model_info(
      ::dan::ModelInfo* model_info);
  ::dan::ModelInfo* unsafe_arena_release_model_info();

  // int32 input_size = 3;
  void clear_input_size();
  ::PROTOBUF_NAMESPACE_ID::int32 input_size() const;
  void set_input_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_input_size() const;
  void _internal_set_input_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 hidden_size = 4;
  void clear_hidden_size();
  ::PROTOBUF_NAMESPACE_ID::int32 hidden_size() const;
  void set_hidden_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hidden_size() const;
  void _internal_set_hidden_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 num_class = 5;
  void clear_num_class();
  ::PROTOBUF_NAMESPACE_ID::int32 num_class() const;
  void set_num_class(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_class() const;
  void _internal_set_num_class(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float dropout = 6;
  void clear_dropout();
  float dropout() const;
  void set_dropout(float value);
  private:
  float _internal_dropout() const;
  void _internal_set_dropout(float value);
  public:

  // float learning_rate = 7;
  void clear_learning_rate();
  float learning_rate() const;
  void set_learning_rate(float value);
  private:
  float _internal_learning_rate() const;
  void _internal_set_learning_rate(float value);
  public:

  // int32 data_update_interval = 8;
  void clear_data_update_interval();
  ::PROTOBUF_NAMESPACE_ID::int32 data_update_interval() const;
  void set_data_update_interval(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_data_update_interval() const;
  void _internal_set_data_update_interval(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool merge_manually = 9;
  void clear_merge_manually();
  bool merge_manually() const;
  void set_merge_manually(bool value);
  private:
  bool _internal_merge_manually() const;
  void _internal_set_merge_manually(bool value);
  public:

  // int32 num_epochs = 10;
  void clear_num_epochs();
  ::PROTOBUF_NAMESPACE_ID::int32 num_epochs() const;
  void set_num_epochs(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_epochs() const;
  void _internal_set_num_epochs(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dan.NodeClassifierInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_file_;
  ::dan::IntVec* fids_;
  ::dan::ModelInfo* model_info_;
  ::PROTOBUF_NAMESPACE_ID::int32 input_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 hidden_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_class_;
  float dropout_;
  float learning_rate_;
  ::PROTOBUF_NAMESPACE_ID::int32 data_update_interval_;
  bool merge_manually_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_epochs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Void

// -------------------------------------------------------------------

// Int

// int32 v = 1;
inline void Int::clear_v() {
  v_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Int::_internal_v() const {
  return v_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Int::v() const {
  // @@protoc_insertion_point(field_get:dan.Int.v)
  return _internal_v();
}
inline void Int::_internal_set_v(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  v_ = value;
}
inline void Int::set_v(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:dan.Int.v)
}

// -------------------------------------------------------------------

// IntVec

// repeated int32 v = 1;
inline int IntVec::_internal_v_size() const {
  return v_.size();
}
inline int IntVec::v_size() const {
  return _internal_v_size();
}
inline void IntVec::clear_v() {
  v_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntVec::_internal_v(int index) const {
  return v_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntVec::v(int index) const {
  // @@protoc_insertion_point(field_get:dan.IntVec.v)
  return _internal_v(index);
}
inline void IntVec::set_v(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  v_.Set(index, value);
  // @@protoc_insertion_point(field_set:dan.IntVec.v)
}
inline void IntVec::_internal_add_v(::PROTOBUF_NAMESPACE_ID::int32 value) {
  v_.Add(value);
}
inline void IntVec::add_v(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_v(value);
  // @@protoc_insertion_point(field_add:dan.IntVec.v)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
IntVec::_internal_v() const {
  return v_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
IntVec::v() const {
  // @@protoc_insertion_point(field_list:dan.IntVec.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
IntVec::_internal_mutable_v() {
  return &v_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
IntVec::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:dan.IntVec.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// Long

// int64 v = 1;
inline void Long::clear_v() {
  v_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Long::_internal_v() const {
  return v_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Long::v() const {
  // @@protoc_insertion_point(field_get:dan.Long.v)
  return _internal_v();
}
inline void Long::_internal_set_v(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  v_ = value;
}
inline void Long::set_v(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:dan.Long.v)
}

// -------------------------------------------------------------------

// LongVec

// repeated int64 v = 1;
inline int LongVec::_internal_v_size() const {
  return v_.size();
}
inline int LongVec::v_size() const {
  return _internal_v_size();
}
inline void LongVec::clear_v() {
  v_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LongVec::_internal_v(int index) const {
  return v_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LongVec::v(int index) const {
  // @@protoc_insertion_point(field_get:dan.LongVec.v)
  return _internal_v(index);
}
inline void LongVec::set_v(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  v_.Set(index, value);
  // @@protoc_insertion_point(field_set:dan.LongVec.v)
}
inline void LongVec::_internal_add_v(::PROTOBUF_NAMESPACE_ID::int64 value) {
  v_.Add(value);
}
inline void LongVec::add_v(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_v(value);
  // @@protoc_insertion_point(field_add:dan.LongVec.v)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
LongVec::_internal_v() const {
  return v_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
LongVec::v() const {
  // @@protoc_insertion_point(field_list:dan.LongVec.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
LongVec::_internal_mutable_v() {
  return &v_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
LongVec::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:dan.LongVec.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// Float

// float v = 1;
inline void Float::clear_v() {
  v_ = 0;
}
inline float Float::_internal_v() const {
  return v_;
}
inline float Float::v() const {
  // @@protoc_insertion_point(field_get:dan.Float.v)
  return _internal_v();
}
inline void Float::_internal_set_v(float value) {
  
  v_ = value;
}
inline void Float::set_v(float value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:dan.Float.v)
}

// -------------------------------------------------------------------

// FloatVec

// repeated float v = 1;
inline int FloatVec::_internal_v_size() const {
  return v_.size();
}
inline int FloatVec::v_size() const {
  return _internal_v_size();
}
inline void FloatVec::clear_v() {
  v_.Clear();
}
inline float FloatVec::_internal_v(int index) const {
  return v_.Get(index);
}
inline float FloatVec::v(int index) const {
  // @@protoc_insertion_point(field_get:dan.FloatVec.v)
  return _internal_v(index);
}
inline void FloatVec::set_v(int index, float value) {
  v_.Set(index, value);
  // @@protoc_insertion_point(field_set:dan.FloatVec.v)
}
inline void FloatVec::_internal_add_v(float value) {
  v_.Add(value);
}
inline void FloatVec::add_v(float value) {
  _internal_add_v(value);
  // @@protoc_insertion_point(field_add:dan.FloatVec.v)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FloatVec::_internal_v() const {
  return v_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FloatVec::v() const {
  // @@protoc_insertion_point(field_list:dan.FloatVec.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FloatVec::_internal_mutable_v() {
  return &v_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FloatVec::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:dan.FloatVec.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// Double

// double v = 1;
inline void Double::clear_v() {
  v_ = 0;
}
inline double Double::_internal_v() const {
  return v_;
}
inline double Double::v() const {
  // @@protoc_insertion_point(field_get:dan.Double.v)
  return _internal_v();
}
inline void Double::_internal_set_v(double value) {
  
  v_ = value;
}
inline void Double::set_v(double value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:dan.Double.v)
}

// -------------------------------------------------------------------

// DoubleVec

// repeated double v = 1;
inline int DoubleVec::_internal_v_size() const {
  return v_.size();
}
inline int DoubleVec::v_size() const {
  return _internal_v_size();
}
inline void DoubleVec::clear_v() {
  v_.Clear();
}
inline double DoubleVec::_internal_v(int index) const {
  return v_.Get(index);
}
inline double DoubleVec::v(int index) const {
  // @@protoc_insertion_point(field_get:dan.DoubleVec.v)
  return _internal_v(index);
}
inline void DoubleVec::set_v(int index, double value) {
  v_.Set(index, value);
  // @@protoc_insertion_point(field_set:dan.DoubleVec.v)
}
inline void DoubleVec::_internal_add_v(double value) {
  v_.Add(value);
}
inline void DoubleVec::add_v(double value) {
  _internal_add_v(value);
  // @@protoc_insertion_point(field_add:dan.DoubleVec.v)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DoubleVec::_internal_v() const {
  return v_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DoubleVec::v() const {
  // @@protoc_insertion_point(field_list:dan.DoubleVec.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DoubleVec::_internal_mutable_v() {
  return &v_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DoubleVec::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:dan.DoubleVec.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// Str

// string v = 1;
inline void Str::clear_v() {
  v_.ClearToEmpty();
}
inline const std::string& Str::v() const {
  // @@protoc_insertion_point(field_get:dan.Str.v)
  return _internal_v();
}
inline void Str::set_v(const std::string& value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:dan.Str.v)
}
inline std::string* Str::mutable_v() {
  // @@protoc_insertion_point(field_mutable:dan.Str.v)
  return _internal_mutable_v();
}
inline const std::string& Str::_internal_v() const {
  return v_.Get();
}
inline void Str::_internal_set_v(const std::string& value) {
  
  v_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Str::set_v(std::string&& value) {
  
  v_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.Str.v)
}
inline void Str::set_v(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  v_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.Str.v)
}
inline void Str::set_v(const char* value,
    size_t size) {
  
  v_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.Str.v)
}
inline std::string* Str::_internal_mutable_v() {
  
  return v_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Str::release_v() {
  // @@protoc_insertion_point(field_release:dan.Str.v)
  return v_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Str::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  v_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), v,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.Str.v)
}

// -------------------------------------------------------------------

// StrVec

// repeated string v = 1;
inline int StrVec::_internal_v_size() const {
  return v_.size();
}
inline int StrVec::v_size() const {
  return _internal_v_size();
}
inline void StrVec::clear_v() {
  v_.Clear();
}
inline std::string* StrVec::add_v() {
  // @@protoc_insertion_point(field_add_mutable:dan.StrVec.v)
  return _internal_add_v();
}
inline const std::string& StrVec::_internal_v(int index) const {
  return v_.Get(index);
}
inline const std::string& StrVec::v(int index) const {
  // @@protoc_insertion_point(field_get:dan.StrVec.v)
  return _internal_v(index);
}
inline std::string* StrVec::mutable_v(int index) {
  // @@protoc_insertion_point(field_mutable:dan.StrVec.v)
  return v_.Mutable(index);
}
inline void StrVec::set_v(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:dan.StrVec.v)
  v_.Mutable(index)->assign(value);
}
inline void StrVec::set_v(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:dan.StrVec.v)
  v_.Mutable(index)->assign(std::move(value));
}
inline void StrVec::set_v(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  v_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dan.StrVec.v)
}
inline void StrVec::set_v(int index, const char* value, size_t size) {
  v_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dan.StrVec.v)
}
inline std::string* StrVec::_internal_add_v() {
  return v_.Add();
}
inline void StrVec::add_v(const std::string& value) {
  v_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dan.StrVec.v)
}
inline void StrVec::add_v(std::string&& value) {
  v_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dan.StrVec.v)
}
inline void StrVec::add_v(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  v_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dan.StrVec.v)
}
inline void StrVec::add_v(const char* value, size_t size) {
  v_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dan.StrVec.v)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StrVec::v() const {
  // @@protoc_insertion_point(field_list:dan.StrVec.v)
  return v_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StrVec::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:dan.StrVec.v)
  return &v_;
}

// -------------------------------------------------------------------

// Eval

// int64 l = 1;
inline bool Eval::_internal_has_l() const {
  return v_case() == kL;
}
inline void Eval::set_has_l() {
  _oneof_case_[0] = kL;
}
inline void Eval::clear_l() {
  if (_internal_has_l()) {
    v_.l_ = PROTOBUF_LONGLONG(0);
    clear_has_v();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Eval::_internal_l() const {
  if (_internal_has_l()) {
    return v_.l_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void Eval::_internal_set_l(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!_internal_has_l()) {
    clear_v();
    set_has_l();
  }
  v_.l_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Eval::l() const {
  // @@protoc_insertion_point(field_get:dan.Eval.l)
  return _internal_l();
}
inline void Eval::set_l(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_l(value);
  // @@protoc_insertion_point(field_set:dan.Eval.l)
}

// double d = 2;
inline bool Eval::_internal_has_d() const {
  return v_case() == kD;
}
inline void Eval::set_has_d() {
  _oneof_case_[0] = kD;
}
inline void Eval::clear_d() {
  if (_internal_has_d()) {
    v_.d_ = 0;
    clear_has_v();
  }
}
inline double Eval::_internal_d() const {
  if (_internal_has_d()) {
    return v_.d_;
  }
  return 0;
}
inline void Eval::_internal_set_d(double value) {
  if (!_internal_has_d()) {
    clear_v();
    set_has_d();
  }
  v_.d_ = value;
}
inline double Eval::d() const {
  // @@protoc_insertion_point(field_get:dan.Eval.d)
  return _internal_d();
}
inline void Eval::set_d(double value) {
  _internal_set_d(value);
  // @@protoc_insertion_point(field_set:dan.Eval.d)
}

// string s = 3;
inline bool Eval::_internal_has_s() const {
  return v_case() == kS;
}
inline void Eval::set_has_s() {
  _oneof_case_[0] = kS;
}
inline void Eval::clear_s() {
  if (_internal_has_s()) {
    v_.s_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_v();
  }
}
inline const std::string& Eval::s() const {
  // @@protoc_insertion_point(field_get:dan.Eval.s)
  return _internal_s();
}
inline void Eval::set_s(const std::string& value) {
  _internal_set_s(value);
  // @@protoc_insertion_point(field_set:dan.Eval.s)
}
inline std::string* Eval::mutable_s() {
  // @@protoc_insertion_point(field_mutable:dan.Eval.s)
  return _internal_mutable_s();
}
inline const std::string& Eval::_internal_s() const {
  if (_internal_has_s()) {
    return v_.s_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Eval::_internal_set_s(const std::string& value) {
  if (!_internal_has_s()) {
    clear_v();
    set_has_s();
    v_.s_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  v_.s_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Eval::set_s(std::string&& value) {
  // @@protoc_insertion_point(field_set:dan.Eval.s)
  if (!_internal_has_s()) {
    clear_v();
    set_has_s();
    v_.s_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  v_.s_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.Eval.s)
}
inline void Eval::set_s(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_s()) {
    clear_v();
    set_has_s();
    v_.s_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  v_.s_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.Eval.s)
}
inline void Eval::set_s(const char* value,
                             size_t size) {
  if (!_internal_has_s()) {
    clear_v();
    set_has_s();
    v_.s_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  v_.s_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.Eval.s)
}
inline std::string* Eval::_internal_mutable_s() {
  if (!_internal_has_s()) {
    clear_v();
    set_has_s();
    v_.s_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return v_.s_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Eval::release_s() {
  // @@protoc_insertion_point(field_release:dan.Eval.s)
  if (_internal_has_s()) {
    clear_has_v();
    return v_.s_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Eval::set_allocated_s(std::string* s) {
  if (has_v()) {
    clear_v();
  }
  if (s != nullptr) {
    set_has_s();
    v_.s_.UnsafeSetDefault(s);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(s);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:dan.Eval.s)
}

// bool b = 4;
inline bool Eval::_internal_has_b() const {
  return v_case() == kB;
}
inline void Eval::set_has_b() {
  _oneof_case_[0] = kB;
}
inline void Eval::clear_b() {
  if (_internal_has_b()) {
    v_.b_ = false;
    clear_has_v();
  }
}
inline bool Eval::_internal_b() const {
  if (_internal_has_b()) {
    return v_.b_;
  }
  return false;
}
inline void Eval::_internal_set_b(bool value) {
  if (!_internal_has_b()) {
    clear_v();
    set_has_b();
  }
  v_.b_ = value;
}
inline bool Eval::b() const {
  // @@protoc_insertion_point(field_get:dan.Eval.b)
  return _internal_b();
}
inline void Eval::set_b(bool value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:dan.Eval.b)
}

// .dan.IntVec il = 5;
inline bool Eval::_internal_has_il() const {
  return v_case() == kIl;
}
inline bool Eval::has_il() const {
  return _internal_has_il();
}
inline void Eval::set_has_il() {
  _oneof_case_[0] = kIl;
}
inline void Eval::clear_il() {
  if (_internal_has_il()) {
    if (GetArena() == nullptr) {
      delete v_.il_;
    }
    clear_has_v();
  }
}
inline ::dan::IntVec* Eval::release_il() {
  // @@protoc_insertion_point(field_release:dan.Eval.il)
  if (_internal_has_il()) {
    clear_has_v();
      ::dan::IntVec* temp = v_.il_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    v_.il_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dan::IntVec& Eval::_internal_il() const {
  return _internal_has_il()
      ? *v_.il_
      : reinterpret_cast< ::dan::IntVec&>(::dan::_IntVec_default_instance_);
}
inline const ::dan::IntVec& Eval::il() const {
  // @@protoc_insertion_point(field_get:dan.Eval.il)
  return _internal_il();
}
inline ::dan::IntVec* Eval::unsafe_arena_release_il() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dan.Eval.il)
  if (_internal_has_il()) {
    clear_has_v();
    ::dan::IntVec* temp = v_.il_;
    v_.il_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Eval::unsafe_arena_set_allocated_il(::dan::IntVec* il) {
  clear_v();
  if (il) {
    set_has_il();
    v_.il_ = il;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.Eval.il)
}
inline ::dan::IntVec* Eval::_internal_mutable_il() {
  if (!_internal_has_il()) {
    clear_v();
    set_has_il();
    v_.il_ = CreateMaybeMessage< ::dan::IntVec >(GetArena());
  }
  return v_.il_;
}
inline ::dan::IntVec* Eval::mutable_il() {
  // @@protoc_insertion_point(field_mutable:dan.Eval.il)
  return _internal_mutable_il();
}

// .dan.LongVec ll = 6;
inline bool Eval::_internal_has_ll() const {
  return v_case() == kLl;
}
inline bool Eval::has_ll() const {
  return _internal_has_ll();
}
inline void Eval::set_has_ll() {
  _oneof_case_[0] = kLl;
}
inline void Eval::clear_ll() {
  if (_internal_has_ll()) {
    if (GetArena() == nullptr) {
      delete v_.ll_;
    }
    clear_has_v();
  }
}
inline ::dan::LongVec* Eval::release_ll() {
  // @@protoc_insertion_point(field_release:dan.Eval.ll)
  if (_internal_has_ll()) {
    clear_has_v();
      ::dan::LongVec* temp = v_.ll_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    v_.ll_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dan::LongVec& Eval::_internal_ll() const {
  return _internal_has_ll()
      ? *v_.ll_
      : reinterpret_cast< ::dan::LongVec&>(::dan::_LongVec_default_instance_);
}
inline const ::dan::LongVec& Eval::ll() const {
  // @@protoc_insertion_point(field_get:dan.Eval.ll)
  return _internal_ll();
}
inline ::dan::LongVec* Eval::unsafe_arena_release_ll() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dan.Eval.ll)
  if (_internal_has_ll()) {
    clear_has_v();
    ::dan::LongVec* temp = v_.ll_;
    v_.ll_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Eval::unsafe_arena_set_allocated_ll(::dan::LongVec* ll) {
  clear_v();
  if (ll) {
    set_has_ll();
    v_.ll_ = ll;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.Eval.ll)
}
inline ::dan::LongVec* Eval::_internal_mutable_ll() {
  if (!_internal_has_ll()) {
    clear_v();
    set_has_ll();
    v_.ll_ = CreateMaybeMessage< ::dan::LongVec >(GetArena());
  }
  return v_.ll_;
}
inline ::dan::LongVec* Eval::mutable_ll() {
  // @@protoc_insertion_point(field_mutable:dan.Eval.ll)
  return _internal_mutable_ll();
}

// .dan.FloatVec fl = 7;
inline bool Eval::_internal_has_fl() const {
  return v_case() == kFl;
}
inline bool Eval::has_fl() const {
  return _internal_has_fl();
}
inline void Eval::set_has_fl() {
  _oneof_case_[0] = kFl;
}
inline void Eval::clear_fl() {
  if (_internal_has_fl()) {
    if (GetArena() == nullptr) {
      delete v_.fl_;
    }
    clear_has_v();
  }
}
inline ::dan::FloatVec* Eval::release_fl() {
  // @@protoc_insertion_point(field_release:dan.Eval.fl)
  if (_internal_has_fl()) {
    clear_has_v();
      ::dan::FloatVec* temp = v_.fl_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    v_.fl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dan::FloatVec& Eval::_internal_fl() const {
  return _internal_has_fl()
      ? *v_.fl_
      : reinterpret_cast< ::dan::FloatVec&>(::dan::_FloatVec_default_instance_);
}
inline const ::dan::FloatVec& Eval::fl() const {
  // @@protoc_insertion_point(field_get:dan.Eval.fl)
  return _internal_fl();
}
inline ::dan::FloatVec* Eval::unsafe_arena_release_fl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dan.Eval.fl)
  if (_internal_has_fl()) {
    clear_has_v();
    ::dan::FloatVec* temp = v_.fl_;
    v_.fl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Eval::unsafe_arena_set_allocated_fl(::dan::FloatVec* fl) {
  clear_v();
  if (fl) {
    set_has_fl();
    v_.fl_ = fl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.Eval.fl)
}
inline ::dan::FloatVec* Eval::_internal_mutable_fl() {
  if (!_internal_has_fl()) {
    clear_v();
    set_has_fl();
    v_.fl_ = CreateMaybeMessage< ::dan::FloatVec >(GetArena());
  }
  return v_.fl_;
}
inline ::dan::FloatVec* Eval::mutable_fl() {
  // @@protoc_insertion_point(field_mutable:dan.Eval.fl)
  return _internal_mutable_fl();
}

// .dan.DoubleVec dl = 8;
inline bool Eval::_internal_has_dl() const {
  return v_case() == kDl;
}
inline bool Eval::has_dl() const {
  return _internal_has_dl();
}
inline void Eval::set_has_dl() {
  _oneof_case_[0] = kDl;
}
inline void Eval::clear_dl() {
  if (_internal_has_dl()) {
    if (GetArena() == nullptr) {
      delete v_.dl_;
    }
    clear_has_v();
  }
}
inline ::dan::DoubleVec* Eval::release_dl() {
  // @@protoc_insertion_point(field_release:dan.Eval.dl)
  if (_internal_has_dl()) {
    clear_has_v();
      ::dan::DoubleVec* temp = v_.dl_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    v_.dl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dan::DoubleVec& Eval::_internal_dl() const {
  return _internal_has_dl()
      ? *v_.dl_
      : reinterpret_cast< ::dan::DoubleVec&>(::dan::_DoubleVec_default_instance_);
}
inline const ::dan::DoubleVec& Eval::dl() const {
  // @@protoc_insertion_point(field_get:dan.Eval.dl)
  return _internal_dl();
}
inline ::dan::DoubleVec* Eval::unsafe_arena_release_dl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dan.Eval.dl)
  if (_internal_has_dl()) {
    clear_has_v();
    ::dan::DoubleVec* temp = v_.dl_;
    v_.dl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Eval::unsafe_arena_set_allocated_dl(::dan::DoubleVec* dl) {
  clear_v();
  if (dl) {
    set_has_dl();
    v_.dl_ = dl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.Eval.dl)
}
inline ::dan::DoubleVec* Eval::_internal_mutable_dl() {
  if (!_internal_has_dl()) {
    clear_v();
    set_has_dl();
    v_.dl_ = CreateMaybeMessage< ::dan::DoubleVec >(GetArena());
  }
  return v_.dl_;
}
inline ::dan::DoubleVec* Eval::mutable_dl() {
  // @@protoc_insertion_point(field_mutable:dan.Eval.dl)
  return _internal_mutable_dl();
}

inline bool Eval::has_v() const {
  return v_case() != V_NOT_SET;
}
inline void Eval::clear_has_v() {
  _oneof_case_[0] = V_NOT_SET;
}
inline Eval::VCase Eval::v_case() const {
  return Eval::VCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Record

// repeated .dan.Eval v = 1;
inline int Record::_internal_v_size() const {
  return v_.size();
}
inline int Record::v_size() const {
  return _internal_v_size();
}
inline void Record::clear_v() {
  v_.Clear();
}
inline ::dan::Eval* Record::mutable_v(int index) {
  // @@protoc_insertion_point(field_mutable:dan.Record.v)
  return v_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Eval >*
Record::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:dan.Record.v)
  return &v_;
}
inline const ::dan::Eval& Record::_internal_v(int index) const {
  return v_.Get(index);
}
inline const ::dan::Eval& Record::v(int index) const {
  // @@protoc_insertion_point(field_get:dan.Record.v)
  return _internal_v(index);
}
inline ::dan::Eval* Record::_internal_add_v() {
  return v_.Add();
}
inline ::dan::Eval* Record::add_v() {
  // @@protoc_insertion_point(field_add:dan.Record.v)
  return _internal_add_v();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Eval >&
Record::v() const {
  // @@protoc_insertion_point(field_list:dan.Record.v)
  return v_;
}

// -------------------------------------------------------------------

// Table

// repeated .dan.Record v = 1;
inline int Table::_internal_v_size() const {
  return v_.size();
}
inline int Table::v_size() const {
  return _internal_v_size();
}
inline void Table::clear_v() {
  v_.Clear();
}
inline ::dan::Record* Table::mutable_v(int index) {
  // @@protoc_insertion_point(field_mutable:dan.Table.v)
  return v_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Record >*
Table::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:dan.Table.v)
  return &v_;
}
inline const ::dan::Record& Table::_internal_v(int index) const {
  return v_.Get(index);
}
inline const ::dan::Record& Table::v(int index) const {
  // @@protoc_insertion_point(field_get:dan.Table.v)
  return _internal_v(index);
}
inline ::dan::Record* Table::_internal_add_v() {
  return v_.Add();
}
inline ::dan::Record* Table::add_v() {
  // @@protoc_insertion_point(field_add:dan.Table.v)
  return _internal_add_v();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Record >&
Table::v() const {
  // @@protoc_insertion_point(field_list:dan.Table.v)
  return v_;
}

// -------------------------------------------------------------------

// Code

// .dan.Code.Status msg = 1;
inline void Code::clear_msg() {
  msg_ = 0;
}
inline ::dan::Code_Status Code::_internal_msg() const {
  return static_cast< ::dan::Code_Status >(msg_);
}
inline ::dan::Code_Status Code::msg() const {
  // @@protoc_insertion_point(field_get:dan.Code.msg)
  return _internal_msg();
}
inline void Code::_internal_set_msg(::dan::Code_Status value) {
  
  msg_ = value;
}
inline void Code::set_msg(::dan::Code_Status value) {
  _internal_set_msg(value);
  // @@protoc_insertion_point(field_set:dan.Code.msg)
}

// -------------------------------------------------------------------

// NodeInfo

// int32 id = 1;
inline void NodeInfo::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeInfo::id() const {
  // @@protoc_insertion_point(field_get:dan.NodeInfo.id)
  return _internal_id();
}
inline void NodeInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void NodeInfo::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dan.NodeInfo.id)
}

// string host = 2;
inline void NodeInfo::clear_host() {
  host_.ClearToEmpty();
}
inline const std::string& NodeInfo::host() const {
  // @@protoc_insertion_point(field_get:dan.NodeInfo.host)
  return _internal_host();
}
inline void NodeInfo::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:dan.NodeInfo.host)
}
inline std::string* NodeInfo::mutable_host() {
  // @@protoc_insertion_point(field_mutable:dan.NodeInfo.host)
  return _internal_mutable_host();
}
inline const std::string& NodeInfo::_internal_host() const {
  return host_.Get();
}
inline void NodeInfo::_internal_set_host(const std::string& value) {
  
  host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeInfo::set_host(std::string&& value) {
  
  host_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.NodeInfo.host)
}
inline void NodeInfo::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.NodeInfo.host)
}
inline void NodeInfo::set_host(const char* value,
    size_t size) {
  
  host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.NodeInfo.host)
}
inline std::string* NodeInfo::_internal_mutable_host() {
  
  return host_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeInfo::release_host() {
  // @@protoc_insertion_point(field_release:dan.NodeInfo.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfo::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.NodeInfo.host)
}

// int32 port = 3;
inline void NodeInfo::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeInfo::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeInfo::port() const {
  // @@protoc_insertion_point(field_get:dan.NodeInfo.port)
  return _internal_port();
}
inline void NodeInfo::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void NodeInfo::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:dan.NodeInfo.port)
}

// bool head = 4;
inline void NodeInfo::clear_head() {
  head_ = false;
}
inline bool NodeInfo::_internal_head() const {
  return head_;
}
inline bool NodeInfo::head() const {
  // @@protoc_insertion_point(field_get:dan.NodeInfo.head)
  return _internal_head();
}
inline void NodeInfo::_internal_set_head(bool value) {
  
  head_ = value;
}
inline void NodeInfo::set_head(bool value) {
  _internal_set_head(value);
  // @@protoc_insertion_point(field_set:dan.NodeInfo.head)
}

// -------------------------------------------------------------------

// NodeInfoVec

// repeated .dan.NodeInfo v = 1;
inline int NodeInfoVec::_internal_v_size() const {
  return v_.size();
}
inline int NodeInfoVec::v_size() const {
  return _internal_v_size();
}
inline void NodeInfoVec::clear_v() {
  v_.Clear();
}
inline ::dan::NodeInfo* NodeInfoVec::mutable_v(int index) {
  // @@protoc_insertion_point(field_mutable:dan.NodeInfoVec.v)
  return v_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::NodeInfo >*
NodeInfoVec::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:dan.NodeInfoVec.v)
  return &v_;
}
inline const ::dan::NodeInfo& NodeInfoVec::_internal_v(int index) const {
  return v_.Get(index);
}
inline const ::dan::NodeInfo& NodeInfoVec::v(int index) const {
  // @@protoc_insertion_point(field_get:dan.NodeInfoVec.v)
  return _internal_v(index);
}
inline ::dan::NodeInfo* NodeInfoVec::_internal_add_v() {
  return v_.Add();
}
inline ::dan::NodeInfo* NodeInfoVec::add_v() {
  // @@protoc_insertion_point(field_add:dan.NodeInfoVec.v)
  return _internal_add_v();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::NodeInfo >&
NodeInfoVec::v() const {
  // @@protoc_insertion_point(field_list:dan.NodeInfoVec.v)
  return v_;
}

// -------------------------------------------------------------------

// Field

// string fname = 1;
inline void Field::clear_fname() {
  fname_.ClearToEmpty();
}
inline const std::string& Field::fname() const {
  // @@protoc_insertion_point(field_get:dan.Field.fname)
  return _internal_fname();
}
inline void Field::set_fname(const std::string& value) {
  _internal_set_fname(value);
  // @@protoc_insertion_point(field_set:dan.Field.fname)
}
inline std::string* Field::mutable_fname() {
  // @@protoc_insertion_point(field_mutable:dan.Field.fname)
  return _internal_mutable_fname();
}
inline const std::string& Field::_internal_fname() const {
  return fname_.Get();
}
inline void Field::_internal_set_fname(const std::string& value) {
  
  fname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Field::set_fname(std::string&& value) {
  
  fname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.Field.fname)
}
inline void Field::set_fname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.Field.fname)
}
inline void Field::set_fname(const char* value,
    size_t size) {
  
  fname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.Field.fname)
}
inline std::string* Field::_internal_mutable_fname() {
  
  return fname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Field::release_fname() {
  // @@protoc_insertion_point(field_release:dan.Field.fname)
  return fname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Field::set_allocated_fname(std::string* fname) {
  if (fname != nullptr) {
    
  } else {
    
  }
  fname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.Field.fname)
}

// string ftype = 2;
inline void Field::clear_ftype() {
  ftype_.ClearToEmpty();
}
inline const std::string& Field::ftype() const {
  // @@protoc_insertion_point(field_get:dan.Field.ftype)
  return _internal_ftype();
}
inline void Field::set_ftype(const std::string& value) {
  _internal_set_ftype(value);
  // @@protoc_insertion_point(field_set:dan.Field.ftype)
}
inline std::string* Field::mutable_ftype() {
  // @@protoc_insertion_point(field_mutable:dan.Field.ftype)
  return _internal_mutable_ftype();
}
inline const std::string& Field::_internal_ftype() const {
  return ftype_.Get();
}
inline void Field::_internal_set_ftype(const std::string& value) {
  
  ftype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Field::set_ftype(std::string&& value) {
  
  ftype_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.Field.ftype)
}
inline void Field::set_ftype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ftype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.Field.ftype)
}
inline void Field::set_ftype(const char* value,
    size_t size) {
  
  ftype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.Field.ftype)
}
inline std::string* Field::_internal_mutable_ftype() {
  
  return ftype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Field::release_ftype() {
  // @@protoc_insertion_point(field_release:dan.Field.ftype)
  return ftype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Field::set_allocated_ftype(std::string* ftype) {
  if (ftype != nullptr) {
    
  } else {
    
  }
  ftype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ftype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.Field.ftype)
}

// -------------------------------------------------------------------

// CreateTable

// string tname = 1;
inline void CreateTable::clear_tname() {
  tname_.ClearToEmpty();
}
inline const std::string& CreateTable::tname() const {
  // @@protoc_insertion_point(field_get:dan.CreateTable.tname)
  return _internal_tname();
}
inline void CreateTable::set_tname(const std::string& value) {
  _internal_set_tname(value);
  // @@protoc_insertion_point(field_set:dan.CreateTable.tname)
}
inline std::string* CreateTable::mutable_tname() {
  // @@protoc_insertion_point(field_mutable:dan.CreateTable.tname)
  return _internal_mutable_tname();
}
inline const std::string& CreateTable::_internal_tname() const {
  return tname_.Get();
}
inline void CreateTable::_internal_set_tname(const std::string& value) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CreateTable::set_tname(std::string&& value) {
  
  tname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.CreateTable.tname)
}
inline void CreateTable::set_tname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.CreateTable.tname)
}
inline void CreateTable::set_tname(const char* value,
    size_t size) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.CreateTable.tname)
}
inline std::string* CreateTable::_internal_mutable_tname() {
  
  return tname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CreateTable::release_tname() {
  // @@protoc_insertion_point(field_release:dan.CreateTable.tname)
  return tname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateTable::set_allocated_tname(std::string* tname) {
  if (tname != nullptr) {
    
  } else {
    
  }
  tname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.CreateTable.tname)
}

// string ttype = 2;
inline void CreateTable::clear_ttype() {
  ttype_.ClearToEmpty();
}
inline const std::string& CreateTable::ttype() const {
  // @@protoc_insertion_point(field_get:dan.CreateTable.ttype)
  return _internal_ttype();
}
inline void CreateTable::set_ttype(const std::string& value) {
  _internal_set_ttype(value);
  // @@protoc_insertion_point(field_set:dan.CreateTable.ttype)
}
inline std::string* CreateTable::mutable_ttype() {
  // @@protoc_insertion_point(field_mutable:dan.CreateTable.ttype)
  return _internal_mutable_ttype();
}
inline const std::string& CreateTable::_internal_ttype() const {
  return ttype_.Get();
}
inline void CreateTable::_internal_set_ttype(const std::string& value) {
  
  ttype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CreateTable::set_ttype(std::string&& value) {
  
  ttype_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.CreateTable.ttype)
}
inline void CreateTable::set_ttype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ttype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.CreateTable.ttype)
}
inline void CreateTable::set_ttype(const char* value,
    size_t size) {
  
  ttype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.CreateTable.ttype)
}
inline std::string* CreateTable::_internal_mutable_ttype() {
  
  return ttype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CreateTable::release_ttype() {
  // @@protoc_insertion_point(field_release:dan.CreateTable.ttype)
  return ttype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateTable::set_allocated_ttype(std::string* ttype) {
  if (ttype != nullptr) {
    
  } else {
    
  }
  ttype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ttype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.CreateTable.ttype)
}

// int32 inc_fid = 3;
inline void CreateTable::clear_inc_fid() {
  inc_fid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateTable::_internal_inc_fid() const {
  return inc_fid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateTable::inc_fid() const {
  // @@protoc_insertion_point(field_get:dan.CreateTable.inc_fid)
  return _internal_inc_fid();
}
inline void CreateTable::_internal_set_inc_fid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  inc_fid_ = value;
}
inline void CreateTable::set_inc_fid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_inc_fid(value);
  // @@protoc_insertion_point(field_set:dan.CreateTable.inc_fid)
}

// int32 inc_start = 4;
inline void CreateTable::clear_inc_start() {
  inc_start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateTable::_internal_inc_start() const {
  return inc_start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateTable::inc_start() const {
  // @@protoc_insertion_point(field_get:dan.CreateTable.inc_start)
  return _internal_inc_start();
}
inline void CreateTable::_internal_set_inc_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  inc_start_ = value;
}
inline void CreateTable::set_inc_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_inc_start(value);
  // @@protoc_insertion_point(field_set:dan.CreateTable.inc_start)
}

// repeated .dan.Field schema = 5;
inline int CreateTable::_internal_schema_size() const {
  return schema_.size();
}
inline int CreateTable::schema_size() const {
  return _internal_schema_size();
}
inline void CreateTable::clear_schema() {
  schema_.Clear();
}
inline ::dan::Field* CreateTable::mutable_schema(int index) {
  // @@protoc_insertion_point(field_mutable:dan.CreateTable.schema)
  return schema_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >*
CreateTable::mutable_schema() {
  // @@protoc_insertion_point(field_mutable_list:dan.CreateTable.schema)
  return &schema_;
}
inline const ::dan::Field& CreateTable::_internal_schema(int index) const {
  return schema_.Get(index);
}
inline const ::dan::Field& CreateTable::schema(int index) const {
  // @@protoc_insertion_point(field_get:dan.CreateTable.schema)
  return _internal_schema(index);
}
inline ::dan::Field* CreateTable::_internal_add_schema() {
  return schema_.Add();
}
inline ::dan::Field* CreateTable::add_schema() {
  // @@protoc_insertion_point(field_add:dan.CreateTable.schema)
  return _internal_add_schema();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >&
CreateTable::schema() const {
  // @@protoc_insertion_point(field_list:dan.CreateTable.schema)
  return schema_;
}

// -------------------------------------------------------------------

// CreateIndex

// string tname = 1;
inline void CreateIndex::clear_tname() {
  tname_.ClearToEmpty();
}
inline const std::string& CreateIndex::tname() const {
  // @@protoc_insertion_point(field_get:dan.CreateIndex.tname)
  return _internal_tname();
}
inline void CreateIndex::set_tname(const std::string& value) {
  _internal_set_tname(value);
  // @@protoc_insertion_point(field_set:dan.CreateIndex.tname)
}
inline std::string* CreateIndex::mutable_tname() {
  // @@protoc_insertion_point(field_mutable:dan.CreateIndex.tname)
  return _internal_mutable_tname();
}
inline const std::string& CreateIndex::_internal_tname() const {
  return tname_.Get();
}
inline void CreateIndex::_internal_set_tname(const std::string& value) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CreateIndex::set_tname(std::string&& value) {
  
  tname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.CreateIndex.tname)
}
inline void CreateIndex::set_tname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.CreateIndex.tname)
}
inline void CreateIndex::set_tname(const char* value,
    size_t size) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.CreateIndex.tname)
}
inline std::string* CreateIndex::_internal_mutable_tname() {
  
  return tname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CreateIndex::release_tname() {
  // @@protoc_insertion_point(field_release:dan.CreateIndex.tname)
  return tname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateIndex::set_allocated_tname(std::string* tname) {
  if (tname != nullptr) {
    
  } else {
    
  }
  tname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.CreateIndex.tname)
}

// int32 fid = 2;
inline void CreateIndex::clear_fid() {
  fid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateIndex::_internal_fid() const {
  return fid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateIndex::fid() const {
  // @@protoc_insertion_point(field_get:dan.CreateIndex.fid)
  return _internal_fid();
}
inline void CreateIndex::_internal_set_fid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  fid_ = value;
}
inline void CreateIndex::set_fid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:dan.CreateIndex.fid)
}

// bool unique = 3;
inline void CreateIndex::clear_unique() {
  unique_ = false;
}
inline bool CreateIndex::_internal_unique() const {
  return unique_;
}
inline bool CreateIndex::unique() const {
  // @@protoc_insertion_point(field_get:dan.CreateIndex.unique)
  return _internal_unique();
}
inline void CreateIndex::_internal_set_unique(bool value) {
  
  unique_ = value;
}
inline void CreateIndex::set_unique(bool value) {
  _internal_set_unique(value);
  // @@protoc_insertion_point(field_set:dan.CreateIndex.unique)
}

// -------------------------------------------------------------------

// TablePartition

// string tname = 1;
inline void TablePartition::clear_tname() {
  tname_.ClearToEmpty();
}
inline const std::string& TablePartition::tname() const {
  // @@protoc_insertion_point(field_get:dan.TablePartition.tname)
  return _internal_tname();
}
inline void TablePartition::set_tname(const std::string& value) {
  _internal_set_tname(value);
  // @@protoc_insertion_point(field_set:dan.TablePartition.tname)
}
inline std::string* TablePartition::mutable_tname() {
  // @@protoc_insertion_point(field_mutable:dan.TablePartition.tname)
  return _internal_mutable_tname();
}
inline const std::string& TablePartition::_internal_tname() const {
  return tname_.Get();
}
inline void TablePartition::_internal_set_tname(const std::string& value) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TablePartition::set_tname(std::string&& value) {
  
  tname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.TablePartition.tname)
}
inline void TablePartition::set_tname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.TablePartition.tname)
}
inline void TablePartition::set_tname(const char* value,
    size_t size) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.TablePartition.tname)
}
inline std::string* TablePartition::_internal_mutable_tname() {
  
  return tname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TablePartition::release_tname() {
  // @@protoc_insertion_point(field_release:dan.TablePartition.tname)
  return tname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TablePartition::set_allocated_tname(std::string* tname) {
  if (tname != nullptr) {
    
  } else {
    
  }
  tname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.TablePartition.tname)
}

// int32 fid = 2;
inline void TablePartition::clear_fid() {
  fid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TablePartition::_internal_fid() const {
  return fid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TablePartition::fid() const {
  // @@protoc_insertion_point(field_get:dan.TablePartition.fid)
  return _internal_fid();
}
inline void TablePartition::_internal_set_fid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  fid_ = value;
}
inline void TablePartition::set_fid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:dan.TablePartition.fid)
}

// .dan.StrVec nodes = 3;
inline bool TablePartition::_internal_has_nodes() const {
  return this != internal_default_instance() && nodes_ != nullptr;
}
inline bool TablePartition::has_nodes() const {
  return _internal_has_nodes();
}
inline void TablePartition::clear_nodes() {
  if (GetArena() == nullptr && nodes_ != nullptr) {
    delete nodes_;
  }
  nodes_ = nullptr;
}
inline const ::dan::StrVec& TablePartition::_internal_nodes() const {
  const ::dan::StrVec* p = nodes_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::StrVec&>(
      ::dan::_StrVec_default_instance_);
}
inline const ::dan::StrVec& TablePartition::nodes() const {
  // @@protoc_insertion_point(field_get:dan.TablePartition.nodes)
  return _internal_nodes();
}
inline void TablePartition::unsafe_arena_set_allocated_nodes(
    ::dan::StrVec* nodes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodes_);
  }
  nodes_ = nodes;
  if (nodes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.TablePartition.nodes)
}
inline ::dan::StrVec* TablePartition::release_nodes() {
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::StrVec* TablePartition::unsafe_arena_release_nodes() {
  // @@protoc_insertion_point(field_release:dan.TablePartition.nodes)
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  return temp;
}
inline ::dan::StrVec* TablePartition::_internal_mutable_nodes() {
  
  if (nodes_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::StrVec>(GetArena());
    nodes_ = p;
  }
  return nodes_;
}
inline ::dan::StrVec* TablePartition::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable:dan.TablePartition.nodes)
  return _internal_mutable_nodes();
}
inline void TablePartition::set_allocated_nodes(::dan::StrVec* nodes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete nodes_;
  }
  if (nodes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(nodes);
    if (message_arena != submessage_arena) {
      nodes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodes, submessage_arena);
    }
    
  } else {
    
  }
  nodes_ = nodes;
  // @@protoc_insertion_point(field_set_allocated:dan.TablePartition.nodes)
}

// -------------------------------------------------------------------

// TableInfo

// .dan.StrVec fields = 1;
inline bool TableInfo::_internal_has_fields() const {
  return this != internal_default_instance() && fields_ != nullptr;
}
inline bool TableInfo::has_fields() const {
  return _internal_has_fields();
}
inline void TableInfo::clear_fields() {
  if (GetArena() == nullptr && fields_ != nullptr) {
    delete fields_;
  }
  fields_ = nullptr;
}
inline const ::dan::StrVec& TableInfo::_internal_fields() const {
  const ::dan::StrVec* p = fields_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::StrVec&>(
      ::dan::_StrVec_default_instance_);
}
inline const ::dan::StrVec& TableInfo::fields() const {
  // @@protoc_insertion_point(field_get:dan.TableInfo.fields)
  return _internal_fields();
}
inline void TableInfo::unsafe_arena_set_allocated_fields(
    ::dan::StrVec* fields) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fields_);
  }
  fields_ = fields;
  if (fields) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.TableInfo.fields)
}
inline ::dan::StrVec* TableInfo::release_fields() {
  
  ::dan::StrVec* temp = fields_;
  fields_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::StrVec* TableInfo::unsafe_arena_release_fields() {
  // @@protoc_insertion_point(field_release:dan.TableInfo.fields)
  
  ::dan::StrVec* temp = fields_;
  fields_ = nullptr;
  return temp;
}
inline ::dan::StrVec* TableInfo::_internal_mutable_fields() {
  
  if (fields_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::StrVec>(GetArena());
    fields_ = p;
  }
  return fields_;
}
inline ::dan::StrVec* TableInfo::mutable_fields() {
  // @@protoc_insertion_point(field_mutable:dan.TableInfo.fields)
  return _internal_mutable_fields();
}
inline void TableInfo::set_allocated_fields(::dan::StrVec* fields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fields_;
  }
  if (fields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fields);
    if (message_arena != submessage_arena) {
      fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fields, submessage_arena);
    }
    
  } else {
    
  }
  fields_ = fields;
  // @@protoc_insertion_point(field_set_allocated:dan.TableInfo.fields)
}

// .dan.StrVec nodes = 2;
inline bool TableInfo::_internal_has_nodes() const {
  return this != internal_default_instance() && nodes_ != nullptr;
}
inline bool TableInfo::has_nodes() const {
  return _internal_has_nodes();
}
inline void TableInfo::clear_nodes() {
  if (GetArena() == nullptr && nodes_ != nullptr) {
    delete nodes_;
  }
  nodes_ = nullptr;
}
inline const ::dan::StrVec& TableInfo::_internal_nodes() const {
  const ::dan::StrVec* p = nodes_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::StrVec&>(
      ::dan::_StrVec_default_instance_);
}
inline const ::dan::StrVec& TableInfo::nodes() const {
  // @@protoc_insertion_point(field_get:dan.TableInfo.nodes)
  return _internal_nodes();
}
inline void TableInfo::unsafe_arena_set_allocated_nodes(
    ::dan::StrVec* nodes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodes_);
  }
  nodes_ = nodes;
  if (nodes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.TableInfo.nodes)
}
inline ::dan::StrVec* TableInfo::release_nodes() {
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::StrVec* TableInfo::unsafe_arena_release_nodes() {
  // @@protoc_insertion_point(field_release:dan.TableInfo.nodes)
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  return temp;
}
inline ::dan::StrVec* TableInfo::_internal_mutable_nodes() {
  
  if (nodes_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::StrVec>(GetArena());
    nodes_ = p;
  }
  return nodes_;
}
inline ::dan::StrVec* TableInfo::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable:dan.TableInfo.nodes)
  return _internal_mutable_nodes();
}
inline void TableInfo::set_allocated_nodes(::dan::StrVec* nodes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete nodes_;
  }
  if (nodes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(nodes);
    if (message_arena != submessage_arena) {
      nodes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodes, submessage_arena);
    }
    
  } else {
    
  }
  nodes_ = nodes;
  // @@protoc_insertion_point(field_set_allocated:dan.TableInfo.nodes)
}

// int32 part_fid = 3;
inline void TableInfo::clear_part_fid() {
  part_fid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TableInfo::_internal_part_fid() const {
  return part_fid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TableInfo::part_fid() const {
  // @@protoc_insertion_point(field_get:dan.TableInfo.part_fid)
  return _internal_part_fid();
}
inline void TableInfo::_internal_set_part_fid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  part_fid_ = value;
}
inline void TableInfo::set_part_fid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_part_fid(value);
  // @@protoc_insertion_point(field_set:dan.TableInfo.part_fid)
}

// -------------------------------------------------------------------

// CreateGraph

// string gname = 1;
inline void CreateGraph::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& CreateGraph::gname() const {
  // @@protoc_insertion_point(field_get:dan.CreateGraph.gname)
  return _internal_gname();
}
inline void CreateGraph::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.CreateGraph.gname)
}
inline std::string* CreateGraph::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.CreateGraph.gname)
  return _internal_mutable_gname();
}
inline const std::string& CreateGraph::_internal_gname() const {
  return gname_.Get();
}
inline void CreateGraph::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CreateGraph::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.CreateGraph.gname)
}
inline void CreateGraph::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.CreateGraph.gname)
}
inline void CreateGraph::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.CreateGraph.gname)
}
inline std::string* CreateGraph::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CreateGraph::release_gname() {
  // @@protoc_insertion_point(field_release:dan.CreateGraph.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateGraph::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.CreateGraph.gname)
}

// string vpname = 2;
inline void CreateGraph::clear_vpname() {
  vpname_.ClearToEmpty();
}
inline const std::string& CreateGraph::vpname() const {
  // @@protoc_insertion_point(field_get:dan.CreateGraph.vpname)
  return _internal_vpname();
}
inline void CreateGraph::set_vpname(const std::string& value) {
  _internal_set_vpname(value);
  // @@protoc_insertion_point(field_set:dan.CreateGraph.vpname)
}
inline std::string* CreateGraph::mutable_vpname() {
  // @@protoc_insertion_point(field_mutable:dan.CreateGraph.vpname)
  return _internal_mutable_vpname();
}
inline const std::string& CreateGraph::_internal_vpname() const {
  return vpname_.Get();
}
inline void CreateGraph::_internal_set_vpname(const std::string& value) {
  
  vpname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CreateGraph::set_vpname(std::string&& value) {
  
  vpname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.CreateGraph.vpname)
}
inline void CreateGraph::set_vpname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vpname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.CreateGraph.vpname)
}
inline void CreateGraph::set_vpname(const char* value,
    size_t size) {
  
  vpname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.CreateGraph.vpname)
}
inline std::string* CreateGraph::_internal_mutable_vpname() {
  
  return vpname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CreateGraph::release_vpname() {
  // @@protoc_insertion_point(field_release:dan.CreateGraph.vpname)
  return vpname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateGraph::set_allocated_vpname(std::string* vpname) {
  if (vpname != nullptr) {
    
  } else {
    
  }
  vpname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vpname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.CreateGraph.vpname)
}

// repeated .dan.Field vschema = 3;
inline int CreateGraph::_internal_vschema_size() const {
  return vschema_.size();
}
inline int CreateGraph::vschema_size() const {
  return _internal_vschema_size();
}
inline void CreateGraph::clear_vschema() {
  vschema_.Clear();
}
inline ::dan::Field* CreateGraph::mutable_vschema(int index) {
  // @@protoc_insertion_point(field_mutable:dan.CreateGraph.vschema)
  return vschema_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >*
CreateGraph::mutable_vschema() {
  // @@protoc_insertion_point(field_mutable_list:dan.CreateGraph.vschema)
  return &vschema_;
}
inline const ::dan::Field& CreateGraph::_internal_vschema(int index) const {
  return vschema_.Get(index);
}
inline const ::dan::Field& CreateGraph::vschema(int index) const {
  // @@protoc_insertion_point(field_get:dan.CreateGraph.vschema)
  return _internal_vschema(index);
}
inline ::dan::Field* CreateGraph::_internal_add_vschema() {
  return vschema_.Add();
}
inline ::dan::Field* CreateGraph::add_vschema() {
  // @@protoc_insertion_point(field_add:dan.CreateGraph.vschema)
  return _internal_add_vschema();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >&
CreateGraph::vschema() const {
  // @@protoc_insertion_point(field_list:dan.CreateGraph.vschema)
  return vschema_;
}

// int32 vpfid = 4;
inline void CreateGraph::clear_vpfid() {
  vpfid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateGraph::_internal_vpfid() const {
  return vpfid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateGraph::vpfid() const {
  // @@protoc_insertion_point(field_get:dan.CreateGraph.vpfid)
  return _internal_vpfid();
}
inline void CreateGraph::_internal_set_vpfid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vpfid_ = value;
}
inline void CreateGraph::set_vpfid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vpfid(value);
  // @@protoc_insertion_point(field_set:dan.CreateGraph.vpfid)
}

// string vptype = 5;
inline void CreateGraph::clear_vptype() {
  vptype_.ClearToEmpty();
}
inline const std::string& CreateGraph::vptype() const {
  // @@protoc_insertion_point(field_get:dan.CreateGraph.vptype)
  return _internal_vptype();
}
inline void CreateGraph::set_vptype(const std::string& value) {
  _internal_set_vptype(value);
  // @@protoc_insertion_point(field_set:dan.CreateGraph.vptype)
}
inline std::string* CreateGraph::mutable_vptype() {
  // @@protoc_insertion_point(field_mutable:dan.CreateGraph.vptype)
  return _internal_mutable_vptype();
}
inline const std::string& CreateGraph::_internal_vptype() const {
  return vptype_.Get();
}
inline void CreateGraph::_internal_set_vptype(const std::string& value) {
  
  vptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CreateGraph::set_vptype(std::string&& value) {
  
  vptype_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.CreateGraph.vptype)
}
inline void CreateGraph::set_vptype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.CreateGraph.vptype)
}
inline void CreateGraph::set_vptype(const char* value,
    size_t size) {
  
  vptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.CreateGraph.vptype)
}
inline std::string* CreateGraph::_internal_mutable_vptype() {
  
  return vptype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CreateGraph::release_vptype() {
  // @@protoc_insertion_point(field_release:dan.CreateGraph.vptype)
  return vptype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateGraph::set_allocated_vptype(std::string* vptype) {
  if (vptype != nullptr) {
    
  } else {
    
  }
  vptype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vptype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.CreateGraph.vptype)
}

// repeated .dan.Field eschema = 6;
inline int CreateGraph::_internal_eschema_size() const {
  return eschema_.size();
}
inline int CreateGraph::eschema_size() const {
  return _internal_eschema_size();
}
inline void CreateGraph::clear_eschema() {
  eschema_.Clear();
}
inline ::dan::Field* CreateGraph::mutable_eschema(int index) {
  // @@protoc_insertion_point(field_mutable:dan.CreateGraph.eschema)
  return eschema_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >*
CreateGraph::mutable_eschema() {
  // @@protoc_insertion_point(field_mutable_list:dan.CreateGraph.eschema)
  return &eschema_;
}
inline const ::dan::Field& CreateGraph::_internal_eschema(int index) const {
  return eschema_.Get(index);
}
inline const ::dan::Field& CreateGraph::eschema(int index) const {
  // @@protoc_insertion_point(field_get:dan.CreateGraph.eschema)
  return _internal_eschema(index);
}
inline ::dan::Field* CreateGraph::_internal_add_eschema() {
  return eschema_.Add();
}
inline ::dan::Field* CreateGraph::add_eschema() {
  // @@protoc_insertion_point(field_add:dan.CreateGraph.eschema)
  return _internal_add_eschema();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >&
CreateGraph::eschema() const {
  // @@protoc_insertion_point(field_list:dan.CreateGraph.eschema)
  return eschema_;
}

// string eptype = 7;
inline void CreateGraph::clear_eptype() {
  eptype_.ClearToEmpty();
}
inline const std::string& CreateGraph::eptype() const {
  // @@protoc_insertion_point(field_get:dan.CreateGraph.eptype)
  return _internal_eptype();
}
inline void CreateGraph::set_eptype(const std::string& value) {
  _internal_set_eptype(value);
  // @@protoc_insertion_point(field_set:dan.CreateGraph.eptype)
}
inline std::string* CreateGraph::mutable_eptype() {
  // @@protoc_insertion_point(field_mutable:dan.CreateGraph.eptype)
  return _internal_mutable_eptype();
}
inline const std::string& CreateGraph::_internal_eptype() const {
  return eptype_.Get();
}
inline void CreateGraph::_internal_set_eptype(const std::string& value) {
  
  eptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CreateGraph::set_eptype(std::string&& value) {
  
  eptype_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.CreateGraph.eptype)
}
inline void CreateGraph::set_eptype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  eptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.CreateGraph.eptype)
}
inline void CreateGraph::set_eptype(const char* value,
    size_t size) {
  
  eptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.CreateGraph.eptype)
}
inline std::string* CreateGraph::_internal_mutable_eptype() {
  
  return eptype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CreateGraph::release_eptype() {
  // @@protoc_insertion_point(field_release:dan.CreateGraph.eptype)
  return eptype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateGraph::set_allocated_eptype(std::string* eptype) {
  if (eptype != nullptr) {
    
  } else {
    
  }
  eptype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), eptype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.CreateGraph.eptype)
}

// bool incoming = 8;
inline void CreateGraph::clear_incoming() {
  incoming_ = false;
}
inline bool CreateGraph::_internal_incoming() const {
  return incoming_;
}
inline bool CreateGraph::incoming() const {
  // @@protoc_insertion_point(field_get:dan.CreateGraph.incoming)
  return _internal_incoming();
}
inline void CreateGraph::_internal_set_incoming(bool value) {
  
  incoming_ = value;
}
inline void CreateGraph::set_incoming(bool value) {
  _internal_set_incoming(value);
  // @@protoc_insertion_point(field_set:dan.CreateGraph.incoming)
}

// bool merge = 9;
inline void CreateGraph::clear_merge() {
  merge_ = false;
}
inline bool CreateGraph::_internal_merge() const {
  return merge_;
}
inline bool CreateGraph::merge() const {
  // @@protoc_insertion_point(field_get:dan.CreateGraph.merge)
  return _internal_merge();
}
inline void CreateGraph::_internal_set_merge(bool value) {
  
  merge_ = value;
}
inline void CreateGraph::set_merge(bool value) {
  _internal_set_merge(value);
  // @@protoc_insertion_point(field_set:dan.CreateGraph.merge)
}

// bool is_partition = 10;
inline void CreateGraph::clear_is_partition() {
  is_partition_ = false;
}
inline bool CreateGraph::_internal_is_partition() const {
  return is_partition_;
}
inline bool CreateGraph::is_partition() const {
  // @@protoc_insertion_point(field_get:dan.CreateGraph.is_partition)
  return _internal_is_partition();
}
inline void CreateGraph::_internal_set_is_partition(bool value) {
  
  is_partition_ = value;
}
inline void CreateGraph::set_is_partition(bool value) {
  _internal_set_is_partition(value);
  // @@protoc_insertion_point(field_set:dan.CreateGraph.is_partition)
}

// int32 part_type = 11;
inline void CreateGraph::clear_part_type() {
  part_type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateGraph::_internal_part_type() const {
  return part_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateGraph::part_type() const {
  // @@protoc_insertion_point(field_get:dan.CreateGraph.part_type)
  return _internal_part_type();
}
inline void CreateGraph::_internal_set_part_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  part_type_ = value;
}
inline void CreateGraph::set_part_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_part_type(value);
  // @@protoc_insertion_point(field_set:dan.CreateGraph.part_type)
}

// .dan.StrVec nodes = 12;
inline bool CreateGraph::_internal_has_nodes() const {
  return this != internal_default_instance() && nodes_ != nullptr;
}
inline bool CreateGraph::has_nodes() const {
  return _internal_has_nodes();
}
inline void CreateGraph::clear_nodes() {
  if (GetArena() == nullptr && nodes_ != nullptr) {
    delete nodes_;
  }
  nodes_ = nullptr;
}
inline const ::dan::StrVec& CreateGraph::_internal_nodes() const {
  const ::dan::StrVec* p = nodes_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::StrVec&>(
      ::dan::_StrVec_default_instance_);
}
inline const ::dan::StrVec& CreateGraph::nodes() const {
  // @@protoc_insertion_point(field_get:dan.CreateGraph.nodes)
  return _internal_nodes();
}
inline void CreateGraph::unsafe_arena_set_allocated_nodes(
    ::dan::StrVec* nodes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodes_);
  }
  nodes_ = nodes;
  if (nodes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.CreateGraph.nodes)
}
inline ::dan::StrVec* CreateGraph::release_nodes() {
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::StrVec* CreateGraph::unsafe_arena_release_nodes() {
  // @@protoc_insertion_point(field_release:dan.CreateGraph.nodes)
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  return temp;
}
inline ::dan::StrVec* CreateGraph::_internal_mutable_nodes() {
  
  if (nodes_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::StrVec>(GetArena());
    nodes_ = p;
  }
  return nodes_;
}
inline ::dan::StrVec* CreateGraph::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable:dan.CreateGraph.nodes)
  return _internal_mutable_nodes();
}
inline void CreateGraph::set_allocated_nodes(::dan::StrVec* nodes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete nodes_;
  }
  if (nodes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(nodes);
    if (message_arena != submessage_arena) {
      nodes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodes, submessage_arena);
    }
    
  } else {
    
  }
  nodes_ = nodes;
  // @@protoc_insertion_point(field_set_allocated:dan.CreateGraph.nodes)
}

// -------------------------------------------------------------------

// GraphPartition

// string gname = 1;
inline void GraphPartition::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& GraphPartition::gname() const {
  // @@protoc_insertion_point(field_get:dan.GraphPartition.gname)
  return _internal_gname();
}
inline void GraphPartition::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.GraphPartition.gname)
}
inline std::string* GraphPartition::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.GraphPartition.gname)
  return _internal_mutable_gname();
}
inline const std::string& GraphPartition::_internal_gname() const {
  return gname_.Get();
}
inline void GraphPartition::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GraphPartition::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.GraphPartition.gname)
}
inline void GraphPartition::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.GraphPartition.gname)
}
inline void GraphPartition::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.GraphPartition.gname)
}
inline std::string* GraphPartition::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GraphPartition::release_gname() {
  // @@protoc_insertion_point(field_release:dan.GraphPartition.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GraphPartition::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.GraphPartition.gname)
}

// string ptype = 2;
inline void GraphPartition::clear_ptype() {
  ptype_.ClearToEmpty();
}
inline const std::string& GraphPartition::ptype() const {
  // @@protoc_insertion_point(field_get:dan.GraphPartition.ptype)
  return _internal_ptype();
}
inline void GraphPartition::set_ptype(const std::string& value) {
  _internal_set_ptype(value);
  // @@protoc_insertion_point(field_set:dan.GraphPartition.ptype)
}
inline std::string* GraphPartition::mutable_ptype() {
  // @@protoc_insertion_point(field_mutable:dan.GraphPartition.ptype)
  return _internal_mutable_ptype();
}
inline const std::string& GraphPartition::_internal_ptype() const {
  return ptype_.Get();
}
inline void GraphPartition::_internal_set_ptype(const std::string& value) {
  
  ptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GraphPartition::set_ptype(std::string&& value) {
  
  ptype_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.GraphPartition.ptype)
}
inline void GraphPartition::set_ptype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.GraphPartition.ptype)
}
inline void GraphPartition::set_ptype(const char* value,
    size_t size) {
  
  ptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.GraphPartition.ptype)
}
inline std::string* GraphPartition::_internal_mutable_ptype() {
  
  return ptype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GraphPartition::release_ptype() {
  // @@protoc_insertion_point(field_release:dan.GraphPartition.ptype)
  return ptype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GraphPartition::set_allocated_ptype(std::string* ptype) {
  if (ptype != nullptr) {
    
  } else {
    
  }
  ptype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ptype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.GraphPartition.ptype)
}

// .dan.StrVec nodes = 3;
inline bool GraphPartition::_internal_has_nodes() const {
  return this != internal_default_instance() && nodes_ != nullptr;
}
inline bool GraphPartition::has_nodes() const {
  return _internal_has_nodes();
}
inline void GraphPartition::clear_nodes() {
  if (GetArena() == nullptr && nodes_ != nullptr) {
    delete nodes_;
  }
  nodes_ = nullptr;
}
inline const ::dan::StrVec& GraphPartition::_internal_nodes() const {
  const ::dan::StrVec* p = nodes_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::StrVec&>(
      ::dan::_StrVec_default_instance_);
}
inline const ::dan::StrVec& GraphPartition::nodes() const {
  // @@protoc_insertion_point(field_get:dan.GraphPartition.nodes)
  return _internal_nodes();
}
inline void GraphPartition::unsafe_arena_set_allocated_nodes(
    ::dan::StrVec* nodes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodes_);
  }
  nodes_ = nodes;
  if (nodes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.GraphPartition.nodes)
}
inline ::dan::StrVec* GraphPartition::release_nodes() {
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::StrVec* GraphPartition::unsafe_arena_release_nodes() {
  // @@protoc_insertion_point(field_release:dan.GraphPartition.nodes)
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  return temp;
}
inline ::dan::StrVec* GraphPartition::_internal_mutable_nodes() {
  
  if (nodes_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::StrVec>(GetArena());
    nodes_ = p;
  }
  return nodes_;
}
inline ::dan::StrVec* GraphPartition::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable:dan.GraphPartition.nodes)
  return _internal_mutable_nodes();
}
inline void GraphPartition::set_allocated_nodes(::dan::StrVec* nodes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete nodes_;
  }
  if (nodes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(nodes);
    if (message_arena != submessage_arena) {
      nodes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodes, submessage_arena);
    }
    
  } else {
    
  }
  nodes_ = nodes;
  // @@protoc_insertion_point(field_set_allocated:dan.GraphPartition.nodes)
}

// int32 dop = 4;
inline void GraphPartition::clear_dop() {
  dop_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GraphPartition::_internal_dop() const {
  return dop_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GraphPartition::dop() const {
  // @@protoc_insertion_point(field_get:dan.GraphPartition.dop)
  return _internal_dop();
}
inline void GraphPartition::_internal_set_dop(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dop_ = value;
}
inline void GraphPartition::set_dop(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dop(value);
  // @@protoc_insertion_point(field_set:dan.GraphPartition.dop)
}

// -------------------------------------------------------------------

// GraphInfo

// string gname = 1;
inline void GraphInfo::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& GraphInfo::gname() const {
  // @@protoc_insertion_point(field_get:dan.GraphInfo.gname)
  return _internal_gname();
}
inline void GraphInfo::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.GraphInfo.gname)
}
inline std::string* GraphInfo::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.GraphInfo.gname)
  return _internal_mutable_gname();
}
inline const std::string& GraphInfo::_internal_gname() const {
  return gname_.Get();
}
inline void GraphInfo::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GraphInfo::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.GraphInfo.gname)
}
inline void GraphInfo::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.GraphInfo.gname)
}
inline void GraphInfo::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.GraphInfo.gname)
}
inline std::string* GraphInfo::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GraphInfo::release_gname() {
  // @@protoc_insertion_point(field_release:dan.GraphInfo.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GraphInfo::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.GraphInfo.gname)
}

// .dan.StrVec vpname = 2;
inline bool GraphInfo::_internal_has_vpname() const {
  return this != internal_default_instance() && vpname_ != nullptr;
}
inline bool GraphInfo::has_vpname() const {
  return _internal_has_vpname();
}
inline void GraphInfo::clear_vpname() {
  if (GetArena() == nullptr && vpname_ != nullptr) {
    delete vpname_;
  }
  vpname_ = nullptr;
}
inline const ::dan::StrVec& GraphInfo::_internal_vpname() const {
  const ::dan::StrVec* p = vpname_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::StrVec&>(
      ::dan::_StrVec_default_instance_);
}
inline const ::dan::StrVec& GraphInfo::vpname() const {
  // @@protoc_insertion_point(field_get:dan.GraphInfo.vpname)
  return _internal_vpname();
}
inline void GraphInfo::unsafe_arena_set_allocated_vpname(
    ::dan::StrVec* vpname) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vpname_);
  }
  vpname_ = vpname;
  if (vpname) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.GraphInfo.vpname)
}
inline ::dan::StrVec* GraphInfo::release_vpname() {
  
  ::dan::StrVec* temp = vpname_;
  vpname_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::StrVec* GraphInfo::unsafe_arena_release_vpname() {
  // @@protoc_insertion_point(field_release:dan.GraphInfo.vpname)
  
  ::dan::StrVec* temp = vpname_;
  vpname_ = nullptr;
  return temp;
}
inline ::dan::StrVec* GraphInfo::_internal_mutable_vpname() {
  
  if (vpname_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::StrVec>(GetArena());
    vpname_ = p;
  }
  return vpname_;
}
inline ::dan::StrVec* GraphInfo::mutable_vpname() {
  // @@protoc_insertion_point(field_mutable:dan.GraphInfo.vpname)
  return _internal_mutable_vpname();
}
inline void GraphInfo::set_allocated_vpname(::dan::StrVec* vpname) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vpname_;
  }
  if (vpname) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vpname);
    if (message_arena != submessage_arena) {
      vpname = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vpname, submessage_arena);
    }
    
  } else {
    
  }
  vpname_ = vpname;
  // @@protoc_insertion_point(field_set_allocated:dan.GraphInfo.vpname)
}

// repeated .dan.StrVec vpfields = 3;
inline int GraphInfo::_internal_vpfields_size() const {
  return vpfields_.size();
}
inline int GraphInfo::vpfields_size() const {
  return _internal_vpfields_size();
}
inline void GraphInfo::clear_vpfields() {
  vpfields_.Clear();
}
inline ::dan::StrVec* GraphInfo::mutable_vpfields(int index) {
  // @@protoc_insertion_point(field_mutable:dan.GraphInfo.vpfields)
  return vpfields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::StrVec >*
GraphInfo::mutable_vpfields() {
  // @@protoc_insertion_point(field_mutable_list:dan.GraphInfo.vpfields)
  return &vpfields_;
}
inline const ::dan::StrVec& GraphInfo::_internal_vpfields(int index) const {
  return vpfields_.Get(index);
}
inline const ::dan::StrVec& GraphInfo::vpfields(int index) const {
  // @@protoc_insertion_point(field_get:dan.GraphInfo.vpfields)
  return _internal_vpfields(index);
}
inline ::dan::StrVec* GraphInfo::_internal_add_vpfields() {
  return vpfields_.Add();
}
inline ::dan::StrVec* GraphInfo::add_vpfields() {
  // @@protoc_insertion_point(field_add:dan.GraphInfo.vpfields)
  return _internal_add_vpfields();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::StrVec >&
GraphInfo::vpfields() const {
  // @@protoc_insertion_point(field_list:dan.GraphInfo.vpfields)
  return vpfields_;
}

// .dan.StrVec epfields = 4;
inline bool GraphInfo::_internal_has_epfields() const {
  return this != internal_default_instance() && epfields_ != nullptr;
}
inline bool GraphInfo::has_epfields() const {
  return _internal_has_epfields();
}
inline void GraphInfo::clear_epfields() {
  if (GetArena() == nullptr && epfields_ != nullptr) {
    delete epfields_;
  }
  epfields_ = nullptr;
}
inline const ::dan::StrVec& GraphInfo::_internal_epfields() const {
  const ::dan::StrVec* p = epfields_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::StrVec&>(
      ::dan::_StrVec_default_instance_);
}
inline const ::dan::StrVec& GraphInfo::epfields() const {
  // @@protoc_insertion_point(field_get:dan.GraphInfo.epfields)
  return _internal_epfields();
}
inline void GraphInfo::unsafe_arena_set_allocated_epfields(
    ::dan::StrVec* epfields) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(epfields_);
  }
  epfields_ = epfields;
  if (epfields) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.GraphInfo.epfields)
}
inline ::dan::StrVec* GraphInfo::release_epfields() {
  
  ::dan::StrVec* temp = epfields_;
  epfields_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::StrVec* GraphInfo::unsafe_arena_release_epfields() {
  // @@protoc_insertion_point(field_release:dan.GraphInfo.epfields)
  
  ::dan::StrVec* temp = epfields_;
  epfields_ = nullptr;
  return temp;
}
inline ::dan::StrVec* GraphInfo::_internal_mutable_epfields() {
  
  if (epfields_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::StrVec>(GetArena());
    epfields_ = p;
  }
  return epfields_;
}
inline ::dan::StrVec* GraphInfo::mutable_epfields() {
  // @@protoc_insertion_point(field_mutable:dan.GraphInfo.epfields)
  return _internal_mutable_epfields();
}
inline void GraphInfo::set_allocated_epfields(::dan::StrVec* epfields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete epfields_;
  }
  if (epfields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(epfields);
    if (message_arena != submessage_arena) {
      epfields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, epfields, submessage_arena);
    }
    
  } else {
    
  }
  epfields_ = epfields;
  // @@protoc_insertion_point(field_set_allocated:dan.GraphInfo.epfields)
}

// bool incoming = 5;
inline void GraphInfo::clear_incoming() {
  incoming_ = false;
}
inline bool GraphInfo::_internal_incoming() const {
  return incoming_;
}
inline bool GraphInfo::incoming() const {
  // @@protoc_insertion_point(field_get:dan.GraphInfo.incoming)
  return _internal_incoming();
}
inline void GraphInfo::_internal_set_incoming(bool value) {
  
  incoming_ = value;
}
inline void GraphInfo::set_incoming(bool value) {
  _internal_set_incoming(value);
  // @@protoc_insertion_point(field_set:dan.GraphInfo.incoming)
}

// -------------------------------------------------------------------

// InsertRecord

// string tname = 1;
inline void InsertRecord::clear_tname() {
  tname_.ClearToEmpty();
}
inline const std::string& InsertRecord::tname() const {
  // @@protoc_insertion_point(field_get:dan.InsertRecord.tname)
  return _internal_tname();
}
inline void InsertRecord::set_tname(const std::string& value) {
  _internal_set_tname(value);
  // @@protoc_insertion_point(field_set:dan.InsertRecord.tname)
}
inline std::string* InsertRecord::mutable_tname() {
  // @@protoc_insertion_point(field_mutable:dan.InsertRecord.tname)
  return _internal_mutable_tname();
}
inline const std::string& InsertRecord::_internal_tname() const {
  return tname_.Get();
}
inline void InsertRecord::_internal_set_tname(const std::string& value) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InsertRecord::set_tname(std::string&& value) {
  
  tname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.InsertRecord.tname)
}
inline void InsertRecord::set_tname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.InsertRecord.tname)
}
inline void InsertRecord::set_tname(const char* value,
    size_t size) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.InsertRecord.tname)
}
inline std::string* InsertRecord::_internal_mutable_tname() {
  
  return tname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InsertRecord::release_tname() {
  // @@protoc_insertion_point(field_release:dan.InsertRecord.tname)
  return tname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsertRecord::set_allocated_tname(std::string* tname) {
  if (tname != nullptr) {
    
  } else {
    
  }
  tname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.InsertRecord.tname)
}

// .dan.Record values = 2;
inline bool InsertRecord::_internal_has_values() const {
  return this != internal_default_instance() && values_ != nullptr;
}
inline bool InsertRecord::has_values() const {
  return _internal_has_values();
}
inline void InsertRecord::clear_values() {
  if (GetArena() == nullptr && values_ != nullptr) {
    delete values_;
  }
  values_ = nullptr;
}
inline const ::dan::Record& InsertRecord::_internal_values() const {
  const ::dan::Record* p = values_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& InsertRecord::values() const {
  // @@protoc_insertion_point(field_get:dan.InsertRecord.values)
  return _internal_values();
}
inline void InsertRecord::unsafe_arena_set_allocated_values(
    ::dan::Record* values) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(values_);
  }
  values_ = values;
  if (values) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertRecord.values)
}
inline ::dan::Record* InsertRecord::release_values() {
  
  ::dan::Record* temp = values_;
  values_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* InsertRecord::unsafe_arena_release_values() {
  // @@protoc_insertion_point(field_release:dan.InsertRecord.values)
  
  ::dan::Record* temp = values_;
  values_ = nullptr;
  return temp;
}
inline ::dan::Record* InsertRecord::_internal_mutable_values() {
  
  if (values_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    values_ = p;
  }
  return values_;
}
inline ::dan::Record* InsertRecord::mutable_values() {
  // @@protoc_insertion_point(field_mutable:dan.InsertRecord.values)
  return _internal_mutable_values();
}
inline void InsertRecord::set_allocated_values(::dan::Record* values) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete values_;
  }
  if (values) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(values);
    if (message_arena != submessage_arena) {
      values = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, values, submessage_arena);
    }
    
  } else {
    
  }
  values_ = values;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertRecord.values)
}

// -------------------------------------------------------------------

// InsertRecordStr

// string tname = 1;
inline void InsertRecordStr::clear_tname() {
  tname_.ClearToEmpty();
}
inline const std::string& InsertRecordStr::tname() const {
  // @@protoc_insertion_point(field_get:dan.InsertRecordStr.tname)
  return _internal_tname();
}
inline void InsertRecordStr::set_tname(const std::string& value) {
  _internal_set_tname(value);
  // @@protoc_insertion_point(field_set:dan.InsertRecordStr.tname)
}
inline std::string* InsertRecordStr::mutable_tname() {
  // @@protoc_insertion_point(field_mutable:dan.InsertRecordStr.tname)
  return _internal_mutable_tname();
}
inline const std::string& InsertRecordStr::_internal_tname() const {
  return tname_.Get();
}
inline void InsertRecordStr::_internal_set_tname(const std::string& value) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InsertRecordStr::set_tname(std::string&& value) {
  
  tname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.InsertRecordStr.tname)
}
inline void InsertRecordStr::set_tname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.InsertRecordStr.tname)
}
inline void InsertRecordStr::set_tname(const char* value,
    size_t size) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.InsertRecordStr.tname)
}
inline std::string* InsertRecordStr::_internal_mutable_tname() {
  
  return tname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InsertRecordStr::release_tname() {
  // @@protoc_insertion_point(field_release:dan.InsertRecordStr.tname)
  return tname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsertRecordStr::set_allocated_tname(std::string* tname) {
  if (tname != nullptr) {
    
  } else {
    
  }
  tname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.InsertRecordStr.tname)
}

// .dan.StrVec values = 2;
inline bool InsertRecordStr::_internal_has_values() const {
  return this != internal_default_instance() && values_ != nullptr;
}
inline bool InsertRecordStr::has_values() const {
  return _internal_has_values();
}
inline void InsertRecordStr::clear_values() {
  if (GetArena() == nullptr && values_ != nullptr) {
    delete values_;
  }
  values_ = nullptr;
}
inline const ::dan::StrVec& InsertRecordStr::_internal_values() const {
  const ::dan::StrVec* p = values_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::StrVec&>(
      ::dan::_StrVec_default_instance_);
}
inline const ::dan::StrVec& InsertRecordStr::values() const {
  // @@protoc_insertion_point(field_get:dan.InsertRecordStr.values)
  return _internal_values();
}
inline void InsertRecordStr::unsafe_arena_set_allocated_values(
    ::dan::StrVec* values) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(values_);
  }
  values_ = values;
  if (values) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertRecordStr.values)
}
inline ::dan::StrVec* InsertRecordStr::release_values() {
  
  ::dan::StrVec* temp = values_;
  values_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::StrVec* InsertRecordStr::unsafe_arena_release_values() {
  // @@protoc_insertion_point(field_release:dan.InsertRecordStr.values)
  
  ::dan::StrVec* temp = values_;
  values_ = nullptr;
  return temp;
}
inline ::dan::StrVec* InsertRecordStr::_internal_mutable_values() {
  
  if (values_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::StrVec>(GetArena());
    values_ = p;
  }
  return values_;
}
inline ::dan::StrVec* InsertRecordStr::mutable_values() {
  // @@protoc_insertion_point(field_mutable:dan.InsertRecordStr.values)
  return _internal_mutable_values();
}
inline void InsertRecordStr::set_allocated_values(::dan::StrVec* values) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete values_;
  }
  if (values) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(values);
    if (message_arena != submessage_arena) {
      values = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, values, submessage_arena);
    }
    
  } else {
    
  }
  values_ = values;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertRecordStr.values)
}

// -------------------------------------------------------------------

// InsertRecordBatch

// string tname = 1;
inline void InsertRecordBatch::clear_tname() {
  tname_.ClearToEmpty();
}
inline const std::string& InsertRecordBatch::tname() const {
  // @@protoc_insertion_point(field_get:dan.InsertRecordBatch.tname)
  return _internal_tname();
}
inline void InsertRecordBatch::set_tname(const std::string& value) {
  _internal_set_tname(value);
  // @@protoc_insertion_point(field_set:dan.InsertRecordBatch.tname)
}
inline std::string* InsertRecordBatch::mutable_tname() {
  // @@protoc_insertion_point(field_mutable:dan.InsertRecordBatch.tname)
  return _internal_mutable_tname();
}
inline const std::string& InsertRecordBatch::_internal_tname() const {
  return tname_.Get();
}
inline void InsertRecordBatch::_internal_set_tname(const std::string& value) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InsertRecordBatch::set_tname(std::string&& value) {
  
  tname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.InsertRecordBatch.tname)
}
inline void InsertRecordBatch::set_tname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.InsertRecordBatch.tname)
}
inline void InsertRecordBatch::set_tname(const char* value,
    size_t size) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.InsertRecordBatch.tname)
}
inline std::string* InsertRecordBatch::_internal_mutable_tname() {
  
  return tname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InsertRecordBatch::release_tname() {
  // @@protoc_insertion_point(field_release:dan.InsertRecordBatch.tname)
  return tname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsertRecordBatch::set_allocated_tname(std::string* tname) {
  if (tname != nullptr) {
    
  } else {
    
  }
  tname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.InsertRecordBatch.tname)
}

// .dan.Table batch = 2;
inline bool InsertRecordBatch::_internal_has_batch() const {
  return this != internal_default_instance() && batch_ != nullptr;
}
inline bool InsertRecordBatch::has_batch() const {
  return _internal_has_batch();
}
inline void InsertRecordBatch::clear_batch() {
  if (GetArena() == nullptr && batch_ != nullptr) {
    delete batch_;
  }
  batch_ = nullptr;
}
inline const ::dan::Table& InsertRecordBatch::_internal_batch() const {
  const ::dan::Table* p = batch_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Table&>(
      ::dan::_Table_default_instance_);
}
inline const ::dan::Table& InsertRecordBatch::batch() const {
  // @@protoc_insertion_point(field_get:dan.InsertRecordBatch.batch)
  return _internal_batch();
}
inline void InsertRecordBatch::unsafe_arena_set_allocated_batch(
    ::dan::Table* batch) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(batch_);
  }
  batch_ = batch;
  if (batch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertRecordBatch.batch)
}
inline ::dan::Table* InsertRecordBatch::release_batch() {
  
  ::dan::Table* temp = batch_;
  batch_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Table* InsertRecordBatch::unsafe_arena_release_batch() {
  // @@protoc_insertion_point(field_release:dan.InsertRecordBatch.batch)
  
  ::dan::Table* temp = batch_;
  batch_ = nullptr;
  return temp;
}
inline ::dan::Table* InsertRecordBatch::_internal_mutable_batch() {
  
  if (batch_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Table>(GetArena());
    batch_ = p;
  }
  return batch_;
}
inline ::dan::Table* InsertRecordBatch::mutable_batch() {
  // @@protoc_insertion_point(field_mutable:dan.InsertRecordBatch.batch)
  return _internal_mutable_batch();
}
inline void InsertRecordBatch::set_allocated_batch(::dan::Table* batch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete batch_;
  }
  if (batch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(batch);
    if (message_arena != submessage_arena) {
      batch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch, submessage_arena);
    }
    
  } else {
    
  }
  batch_ = batch;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertRecordBatch.batch)
}

// -------------------------------------------------------------------

// DefineVertex

// string gname = 1;
inline void DefineVertex::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& DefineVertex::gname() const {
  // @@protoc_insertion_point(field_get:dan.DefineVertex.gname)
  return _internal_gname();
}
inline void DefineVertex::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.DefineVertex.gname)
}
inline std::string* DefineVertex::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.DefineVertex.gname)
  return _internal_mutable_gname();
}
inline const std::string& DefineVertex::_internal_gname() const {
  return gname_.Get();
}
inline void DefineVertex::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DefineVertex::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.DefineVertex.gname)
}
inline void DefineVertex::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.DefineVertex.gname)
}
inline void DefineVertex::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.DefineVertex.gname)
}
inline std::string* DefineVertex::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DefineVertex::release_gname() {
  // @@protoc_insertion_point(field_release:dan.DefineVertex.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DefineVertex::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.DefineVertex.gname)
}

// string vpname = 2;
inline void DefineVertex::clear_vpname() {
  vpname_.ClearToEmpty();
}
inline const std::string& DefineVertex::vpname() const {
  // @@protoc_insertion_point(field_get:dan.DefineVertex.vpname)
  return _internal_vpname();
}
inline void DefineVertex::set_vpname(const std::string& value) {
  _internal_set_vpname(value);
  // @@protoc_insertion_point(field_set:dan.DefineVertex.vpname)
}
inline std::string* DefineVertex::mutable_vpname() {
  // @@protoc_insertion_point(field_mutable:dan.DefineVertex.vpname)
  return _internal_mutable_vpname();
}
inline const std::string& DefineVertex::_internal_vpname() const {
  return vpname_.Get();
}
inline void DefineVertex::_internal_set_vpname(const std::string& value) {
  
  vpname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DefineVertex::set_vpname(std::string&& value) {
  
  vpname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.DefineVertex.vpname)
}
inline void DefineVertex::set_vpname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vpname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.DefineVertex.vpname)
}
inline void DefineVertex::set_vpname(const char* value,
    size_t size) {
  
  vpname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.DefineVertex.vpname)
}
inline std::string* DefineVertex::_internal_mutable_vpname() {
  
  return vpname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DefineVertex::release_vpname() {
  // @@protoc_insertion_point(field_release:dan.DefineVertex.vpname)
  return vpname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DefineVertex::set_allocated_vpname(std::string* vpname) {
  if (vpname != nullptr) {
    
  } else {
    
  }
  vpname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vpname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.DefineVertex.vpname)
}

// repeated .dan.Field vschema = 3;
inline int DefineVertex::_internal_vschema_size() const {
  return vschema_.size();
}
inline int DefineVertex::vschema_size() const {
  return _internal_vschema_size();
}
inline void DefineVertex::clear_vschema() {
  vschema_.Clear();
}
inline ::dan::Field* DefineVertex::mutable_vschema(int index) {
  // @@protoc_insertion_point(field_mutable:dan.DefineVertex.vschema)
  return vschema_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >*
DefineVertex::mutable_vschema() {
  // @@protoc_insertion_point(field_mutable_list:dan.DefineVertex.vschema)
  return &vschema_;
}
inline const ::dan::Field& DefineVertex::_internal_vschema(int index) const {
  return vschema_.Get(index);
}
inline const ::dan::Field& DefineVertex::vschema(int index) const {
  // @@protoc_insertion_point(field_get:dan.DefineVertex.vschema)
  return _internal_vschema(index);
}
inline ::dan::Field* DefineVertex::_internal_add_vschema() {
  return vschema_.Add();
}
inline ::dan::Field* DefineVertex::add_vschema() {
  // @@protoc_insertion_point(field_add:dan.DefineVertex.vschema)
  return _internal_add_vschema();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >&
DefineVertex::vschema() const {
  // @@protoc_insertion_point(field_list:dan.DefineVertex.vschema)
  return vschema_;
}

// int32 vpfid = 4;
inline void DefineVertex::clear_vpfid() {
  vpfid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DefineVertex::_internal_vpfid() const {
  return vpfid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DefineVertex::vpfid() const {
  // @@protoc_insertion_point(field_get:dan.DefineVertex.vpfid)
  return _internal_vpfid();
}
inline void DefineVertex::_internal_set_vpfid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vpfid_ = value;
}
inline void DefineVertex::set_vpfid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vpfid(value);
  // @@protoc_insertion_point(field_set:dan.DefineVertex.vpfid)
}

// string vptype = 5;
inline void DefineVertex::clear_vptype() {
  vptype_.ClearToEmpty();
}
inline const std::string& DefineVertex::vptype() const {
  // @@protoc_insertion_point(field_get:dan.DefineVertex.vptype)
  return _internal_vptype();
}
inline void DefineVertex::set_vptype(const std::string& value) {
  _internal_set_vptype(value);
  // @@protoc_insertion_point(field_set:dan.DefineVertex.vptype)
}
inline std::string* DefineVertex::mutable_vptype() {
  // @@protoc_insertion_point(field_mutable:dan.DefineVertex.vptype)
  return _internal_mutable_vptype();
}
inline const std::string& DefineVertex::_internal_vptype() const {
  return vptype_.Get();
}
inline void DefineVertex::_internal_set_vptype(const std::string& value) {
  
  vptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DefineVertex::set_vptype(std::string&& value) {
  
  vptype_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.DefineVertex.vptype)
}
inline void DefineVertex::set_vptype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.DefineVertex.vptype)
}
inline void DefineVertex::set_vptype(const char* value,
    size_t size) {
  
  vptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.DefineVertex.vptype)
}
inline std::string* DefineVertex::_internal_mutable_vptype() {
  
  return vptype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DefineVertex::release_vptype() {
  // @@protoc_insertion_point(field_release:dan.DefineVertex.vptype)
  return vptype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DefineVertex::set_allocated_vptype(std::string* vptype) {
  if (vptype != nullptr) {
    
  } else {
    
  }
  vptype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vptype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.DefineVertex.vptype)
}

// -------------------------------------------------------------------

// ImportVertex

// string gname = 1;
inline void ImportVertex::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& ImportVertex::gname() const {
  // @@protoc_insertion_point(field_get:dan.ImportVertex.gname)
  return _internal_gname();
}
inline void ImportVertex::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.ImportVertex.gname)
}
inline std::string* ImportVertex::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.ImportVertex.gname)
  return _internal_mutable_gname();
}
inline const std::string& ImportVertex::_internal_gname() const {
  return gname_.Get();
}
inline void ImportVertex::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ImportVertex::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.ImportVertex.gname)
}
inline void ImportVertex::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.ImportVertex.gname)
}
inline void ImportVertex::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.ImportVertex.gname)
}
inline std::string* ImportVertex::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ImportVertex::release_gname() {
  // @@protoc_insertion_point(field_release:dan.ImportVertex.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImportVertex::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.ImportVertex.gname)
}

// string vpname = 2;
inline void ImportVertex::clear_vpname() {
  vpname_.ClearToEmpty();
}
inline const std::string& ImportVertex::vpname() const {
  // @@protoc_insertion_point(field_get:dan.ImportVertex.vpname)
  return _internal_vpname();
}
inline void ImportVertex::set_vpname(const std::string& value) {
  _internal_set_vpname(value);
  // @@protoc_insertion_point(field_set:dan.ImportVertex.vpname)
}
inline std::string* ImportVertex::mutable_vpname() {
  // @@protoc_insertion_point(field_mutable:dan.ImportVertex.vpname)
  return _internal_mutable_vpname();
}
inline const std::string& ImportVertex::_internal_vpname() const {
  return vpname_.Get();
}
inline void ImportVertex::_internal_set_vpname(const std::string& value) {
  
  vpname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ImportVertex::set_vpname(std::string&& value) {
  
  vpname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.ImportVertex.vpname)
}
inline void ImportVertex::set_vpname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vpname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.ImportVertex.vpname)
}
inline void ImportVertex::set_vpname(const char* value,
    size_t size) {
  
  vpname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.ImportVertex.vpname)
}
inline std::string* ImportVertex::_internal_mutable_vpname() {
  
  return vpname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ImportVertex::release_vpname() {
  // @@protoc_insertion_point(field_release:dan.ImportVertex.vpname)
  return vpname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImportVertex::set_allocated_vpname(std::string* vpname) {
  if (vpname != nullptr) {
    
  } else {
    
  }
  vpname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vpname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.ImportVertex.vpname)
}

// string csv = 3;
inline void ImportVertex::clear_csv() {
  csv_.ClearToEmpty();
}
inline const std::string& ImportVertex::csv() const {
  // @@protoc_insertion_point(field_get:dan.ImportVertex.csv)
  return _internal_csv();
}
inline void ImportVertex::set_csv(const std::string& value) {
  _internal_set_csv(value);
  // @@protoc_insertion_point(field_set:dan.ImportVertex.csv)
}
inline std::string* ImportVertex::mutable_csv() {
  // @@protoc_insertion_point(field_mutable:dan.ImportVertex.csv)
  return _internal_mutable_csv();
}
inline const std::string& ImportVertex::_internal_csv() const {
  return csv_.Get();
}
inline void ImportVertex::_internal_set_csv(const std::string& value) {
  
  csv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ImportVertex::set_csv(std::string&& value) {
  
  csv_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.ImportVertex.csv)
}
inline void ImportVertex::set_csv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  csv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.ImportVertex.csv)
}
inline void ImportVertex::set_csv(const char* value,
    size_t size) {
  
  csv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.ImportVertex.csv)
}
inline std::string* ImportVertex::_internal_mutable_csv() {
  
  return csv_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ImportVertex::release_csv() {
  // @@protoc_insertion_point(field_release:dan.ImportVertex.csv)
  return csv_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImportVertex::set_allocated_csv(std::string* csv) {
  if (csv != nullptr) {
    
  } else {
    
  }
  csv_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), csv,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.ImportVertex.csv)
}

// string delim = 4;
inline void ImportVertex::clear_delim() {
  delim_.ClearToEmpty();
}
inline const std::string& ImportVertex::delim() const {
  // @@protoc_insertion_point(field_get:dan.ImportVertex.delim)
  return _internal_delim();
}
inline void ImportVertex::set_delim(const std::string& value) {
  _internal_set_delim(value);
  // @@protoc_insertion_point(field_set:dan.ImportVertex.delim)
}
inline std::string* ImportVertex::mutable_delim() {
  // @@protoc_insertion_point(field_mutable:dan.ImportVertex.delim)
  return _internal_mutable_delim();
}
inline const std::string& ImportVertex::_internal_delim() const {
  return delim_.Get();
}
inline void ImportVertex::_internal_set_delim(const std::string& value) {
  
  delim_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ImportVertex::set_delim(std::string&& value) {
  
  delim_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.ImportVertex.delim)
}
inline void ImportVertex::set_delim(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  delim_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.ImportVertex.delim)
}
inline void ImportVertex::set_delim(const char* value,
    size_t size) {
  
  delim_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.ImportVertex.delim)
}
inline std::string* ImportVertex::_internal_mutable_delim() {
  
  return delim_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ImportVertex::release_delim() {
  // @@protoc_insertion_point(field_release:dan.ImportVertex.delim)
  return delim_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImportVertex::set_allocated_delim(std::string* delim) {
  if (delim != nullptr) {
    
  } else {
    
  }
  delim_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), delim,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.ImportVertex.delim)
}

// bool header = 5;
inline void ImportVertex::clear_header() {
  header_ = false;
}
inline bool ImportVertex::_internal_header() const {
  return header_;
}
inline bool ImportVertex::header() const {
  // @@protoc_insertion_point(field_get:dan.ImportVertex.header)
  return _internal_header();
}
inline void ImportVertex::_internal_set_header(bool value) {
  
  header_ = value;
}
inline void ImportVertex::set_header(bool value) {
  _internal_set_header(value);
  // @@protoc_insertion_point(field_set:dan.ImportVertex.header)
}

// -------------------------------------------------------------------

// InsertVertex

// string gname = 1;
inline void InsertVertex::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& InsertVertex::gname() const {
  // @@protoc_insertion_point(field_get:dan.InsertVertex.gname)
  return _internal_gname();
}
inline void InsertVertex::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.InsertVertex.gname)
}
inline std::string* InsertVertex::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.InsertVertex.gname)
  return _internal_mutable_gname();
}
inline const std::string& InsertVertex::_internal_gname() const {
  return gname_.Get();
}
inline void InsertVertex::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InsertVertex::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.InsertVertex.gname)
}
inline void InsertVertex::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.InsertVertex.gname)
}
inline void InsertVertex::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.InsertVertex.gname)
}
inline std::string* InsertVertex::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InsertVertex::release_gname() {
  // @@protoc_insertion_point(field_release:dan.InsertVertex.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsertVertex::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.InsertVertex.gname)
}

// .dan.Record vprop = 2;
inline bool InsertVertex::_internal_has_vprop() const {
  return this != internal_default_instance() && vprop_ != nullptr;
}
inline bool InsertVertex::has_vprop() const {
  return _internal_has_vprop();
}
inline void InsertVertex::clear_vprop() {
  if (GetArena() == nullptr && vprop_ != nullptr) {
    delete vprop_;
  }
  vprop_ = nullptr;
}
inline const ::dan::Record& InsertVertex::_internal_vprop() const {
  const ::dan::Record* p = vprop_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& InsertVertex::vprop() const {
  // @@protoc_insertion_point(field_get:dan.InsertVertex.vprop)
  return _internal_vprop();
}
inline void InsertVertex::unsafe_arena_set_allocated_vprop(
    ::dan::Record* vprop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vprop_);
  }
  vprop_ = vprop;
  if (vprop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertVertex.vprop)
}
inline ::dan::Record* InsertVertex::release_vprop() {
  
  ::dan::Record* temp = vprop_;
  vprop_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* InsertVertex::unsafe_arena_release_vprop() {
  // @@protoc_insertion_point(field_release:dan.InsertVertex.vprop)
  
  ::dan::Record* temp = vprop_;
  vprop_ = nullptr;
  return temp;
}
inline ::dan::Record* InsertVertex::_internal_mutable_vprop() {
  
  if (vprop_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    vprop_ = p;
  }
  return vprop_;
}
inline ::dan::Record* InsertVertex::mutable_vprop() {
  // @@protoc_insertion_point(field_mutable:dan.InsertVertex.vprop)
  return _internal_mutable_vprop();
}
inline void InsertVertex::set_allocated_vprop(::dan::Record* vprop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vprop_;
  }
  if (vprop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vprop);
    if (message_arena != submessage_arena) {
      vprop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vprop, submessage_arena);
    }
    
  } else {
    
  }
  vprop_ = vprop;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertVertex.vprop)
}

// int32 vpid = 3;
inline void InsertVertex::clear_vpid() {
  vpid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertVertex::_internal_vpid() const {
  return vpid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertVertex::vpid() const {
  // @@protoc_insertion_point(field_get:dan.InsertVertex.vpid)
  return _internal_vpid();
}
inline void InsertVertex::_internal_set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vpid_ = value;
}
inline void InsertVertex::set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vpid(value);
  // @@protoc_insertion_point(field_set:dan.InsertVertex.vpid)
}

// -------------------------------------------------------------------

// InsertVertexBatch

// string gname = 1;
inline void InsertVertexBatch::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& InsertVertexBatch::gname() const {
  // @@protoc_insertion_point(field_get:dan.InsertVertexBatch.gname)
  return _internal_gname();
}
inline void InsertVertexBatch::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.InsertVertexBatch.gname)
}
inline std::string* InsertVertexBatch::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.InsertVertexBatch.gname)
  return _internal_mutable_gname();
}
inline const std::string& InsertVertexBatch::_internal_gname() const {
  return gname_.Get();
}
inline void InsertVertexBatch::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InsertVertexBatch::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.InsertVertexBatch.gname)
}
inline void InsertVertexBatch::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.InsertVertexBatch.gname)
}
inline void InsertVertexBatch::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.InsertVertexBatch.gname)
}
inline std::string* InsertVertexBatch::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InsertVertexBatch::release_gname() {
  // @@protoc_insertion_point(field_release:dan.InsertVertexBatch.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsertVertexBatch::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.InsertVertexBatch.gname)
}

// .dan.Table vprop = 2;
inline bool InsertVertexBatch::_internal_has_vprop() const {
  return this != internal_default_instance() && vprop_ != nullptr;
}
inline bool InsertVertexBatch::has_vprop() const {
  return _internal_has_vprop();
}
inline void InsertVertexBatch::clear_vprop() {
  if (GetArena() == nullptr && vprop_ != nullptr) {
    delete vprop_;
  }
  vprop_ = nullptr;
}
inline const ::dan::Table& InsertVertexBatch::_internal_vprop() const {
  const ::dan::Table* p = vprop_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Table&>(
      ::dan::_Table_default_instance_);
}
inline const ::dan::Table& InsertVertexBatch::vprop() const {
  // @@protoc_insertion_point(field_get:dan.InsertVertexBatch.vprop)
  return _internal_vprop();
}
inline void InsertVertexBatch::unsafe_arena_set_allocated_vprop(
    ::dan::Table* vprop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vprop_);
  }
  vprop_ = vprop;
  if (vprop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertVertexBatch.vprop)
}
inline ::dan::Table* InsertVertexBatch::release_vprop() {
  
  ::dan::Table* temp = vprop_;
  vprop_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Table* InsertVertexBatch::unsafe_arena_release_vprop() {
  // @@protoc_insertion_point(field_release:dan.InsertVertexBatch.vprop)
  
  ::dan::Table* temp = vprop_;
  vprop_ = nullptr;
  return temp;
}
inline ::dan::Table* InsertVertexBatch::_internal_mutable_vprop() {
  
  if (vprop_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Table>(GetArena());
    vprop_ = p;
  }
  return vprop_;
}
inline ::dan::Table* InsertVertexBatch::mutable_vprop() {
  // @@protoc_insertion_point(field_mutable:dan.InsertVertexBatch.vprop)
  return _internal_mutable_vprop();
}
inline void InsertVertexBatch::set_allocated_vprop(::dan::Table* vprop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vprop_;
  }
  if (vprop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vprop);
    if (message_arena != submessage_arena) {
      vprop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vprop, submessage_arena);
    }
    
  } else {
    
  }
  vprop_ = vprop;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertVertexBatch.vprop)
}

// int32 vpid = 3;
inline void InsertVertexBatch::clear_vpid() {
  vpid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertVertexBatch::_internal_vpid() const {
  return vpid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertVertexBatch::vpid() const {
  // @@protoc_insertion_point(field_get:dan.InsertVertexBatch.vpid)
  return _internal_vpid();
}
inline void InsertVertexBatch::_internal_set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vpid_ = value;
}
inline void InsertVertexBatch::set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vpid(value);
  // @@protoc_insertion_point(field_set:dan.InsertVertexBatch.vpid)
}

// .dan.IntVec vpids = 4;
inline bool InsertVertexBatch::_internal_has_vpids() const {
  return this != internal_default_instance() && vpids_ != nullptr;
}
inline bool InsertVertexBatch::has_vpids() const {
  return _internal_has_vpids();
}
inline void InsertVertexBatch::clear_vpids() {
  if (GetArena() == nullptr && vpids_ != nullptr) {
    delete vpids_;
  }
  vpids_ = nullptr;
}
inline const ::dan::IntVec& InsertVertexBatch::_internal_vpids() const {
  const ::dan::IntVec* p = vpids_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::IntVec&>(
      ::dan::_IntVec_default_instance_);
}
inline const ::dan::IntVec& InsertVertexBatch::vpids() const {
  // @@protoc_insertion_point(field_get:dan.InsertVertexBatch.vpids)
  return _internal_vpids();
}
inline void InsertVertexBatch::unsafe_arena_set_allocated_vpids(
    ::dan::IntVec* vpids) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vpids_);
  }
  vpids_ = vpids;
  if (vpids) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertVertexBatch.vpids)
}
inline ::dan::IntVec* InsertVertexBatch::release_vpids() {
  
  ::dan::IntVec* temp = vpids_;
  vpids_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::IntVec* InsertVertexBatch::unsafe_arena_release_vpids() {
  // @@protoc_insertion_point(field_release:dan.InsertVertexBatch.vpids)
  
  ::dan::IntVec* temp = vpids_;
  vpids_ = nullptr;
  return temp;
}
inline ::dan::IntVec* InsertVertexBatch::_internal_mutable_vpids() {
  
  if (vpids_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::IntVec>(GetArena());
    vpids_ = p;
  }
  return vpids_;
}
inline ::dan::IntVec* InsertVertexBatch::mutable_vpids() {
  // @@protoc_insertion_point(field_mutable:dan.InsertVertexBatch.vpids)
  return _internal_mutable_vpids();
}
inline void InsertVertexBatch::set_allocated_vpids(::dan::IntVec* vpids) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vpids_;
  }
  if (vpids) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vpids);
    if (message_arena != submessage_arena) {
      vpids = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vpids, submessage_arena);
    }
    
  } else {
    
  }
  vpids_ = vpids;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertVertexBatch.vpids)
}

// -------------------------------------------------------------------

// ImportEdge

// string gname = 1;
inline void ImportEdge::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& ImportEdge::gname() const {
  // @@protoc_insertion_point(field_get:dan.ImportEdge.gname)
  return _internal_gname();
}
inline void ImportEdge::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.ImportEdge.gname)
}
inline std::string* ImportEdge::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.ImportEdge.gname)
  return _internal_mutable_gname();
}
inline const std::string& ImportEdge::_internal_gname() const {
  return gname_.Get();
}
inline void ImportEdge::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ImportEdge::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.ImportEdge.gname)
}
inline void ImportEdge::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.ImportEdge.gname)
}
inline void ImportEdge::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.ImportEdge.gname)
}
inline std::string* ImportEdge::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ImportEdge::release_gname() {
  // @@protoc_insertion_point(field_release:dan.ImportEdge.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImportEdge::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.ImportEdge.gname)
}

// string csv = 2;
inline void ImportEdge::clear_csv() {
  csv_.ClearToEmpty();
}
inline const std::string& ImportEdge::csv() const {
  // @@protoc_insertion_point(field_get:dan.ImportEdge.csv)
  return _internal_csv();
}
inline void ImportEdge::set_csv(const std::string& value) {
  _internal_set_csv(value);
  // @@protoc_insertion_point(field_set:dan.ImportEdge.csv)
}
inline std::string* ImportEdge::mutable_csv() {
  // @@protoc_insertion_point(field_mutable:dan.ImportEdge.csv)
  return _internal_mutable_csv();
}
inline const std::string& ImportEdge::_internal_csv() const {
  return csv_.Get();
}
inline void ImportEdge::_internal_set_csv(const std::string& value) {
  
  csv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ImportEdge::set_csv(std::string&& value) {
  
  csv_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.ImportEdge.csv)
}
inline void ImportEdge::set_csv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  csv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.ImportEdge.csv)
}
inline void ImportEdge::set_csv(const char* value,
    size_t size) {
  
  csv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.ImportEdge.csv)
}
inline std::string* ImportEdge::_internal_mutable_csv() {
  
  return csv_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ImportEdge::release_csv() {
  // @@protoc_insertion_point(field_release:dan.ImportEdge.csv)
  return csv_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImportEdge::set_allocated_csv(std::string* csv) {
  if (csv != nullptr) {
    
  } else {
    
  }
  csv_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), csv,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.ImportEdge.csv)
}

// int32 src_vpid = 3;
inline void ImportEdge::clear_src_vpid() {
  src_vpid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImportEdge::_internal_src_vpid() const {
  return src_vpid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImportEdge::src_vpid() const {
  // @@protoc_insertion_point(field_get:dan.ImportEdge.src_vpid)
  return _internal_src_vpid();
}
inline void ImportEdge::_internal_set_src_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  src_vpid_ = value;
}
inline void ImportEdge::set_src_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_src_vpid(value);
  // @@protoc_insertion_point(field_set:dan.ImportEdge.src_vpid)
}

// int32 dst_vpid = 4;
inline void ImportEdge::clear_dst_vpid() {
  dst_vpid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImportEdge::_internal_dst_vpid() const {
  return dst_vpid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImportEdge::dst_vpid() const {
  // @@protoc_insertion_point(field_get:dan.ImportEdge.dst_vpid)
  return _internal_dst_vpid();
}
inline void ImportEdge::_internal_set_dst_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dst_vpid_ = value;
}
inline void ImportEdge::set_dst_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dst_vpid(value);
  // @@protoc_insertion_point(field_set:dan.ImportEdge.dst_vpid)
}

// string delim = 5;
inline void ImportEdge::clear_delim() {
  delim_.ClearToEmpty();
}
inline const std::string& ImportEdge::delim() const {
  // @@protoc_insertion_point(field_get:dan.ImportEdge.delim)
  return _internal_delim();
}
inline void ImportEdge::set_delim(const std::string& value) {
  _internal_set_delim(value);
  // @@protoc_insertion_point(field_set:dan.ImportEdge.delim)
}
inline std::string* ImportEdge::mutable_delim() {
  // @@protoc_insertion_point(field_mutable:dan.ImportEdge.delim)
  return _internal_mutable_delim();
}
inline const std::string& ImportEdge::_internal_delim() const {
  return delim_.Get();
}
inline void ImportEdge::_internal_set_delim(const std::string& value) {
  
  delim_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ImportEdge::set_delim(std::string&& value) {
  
  delim_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.ImportEdge.delim)
}
inline void ImportEdge::set_delim(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  delim_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.ImportEdge.delim)
}
inline void ImportEdge::set_delim(const char* value,
    size_t size) {
  
  delim_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.ImportEdge.delim)
}
inline std::string* ImportEdge::_internal_mutable_delim() {
  
  return delim_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ImportEdge::release_delim() {
  // @@protoc_insertion_point(field_release:dan.ImportEdge.delim)
  return delim_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImportEdge::set_allocated_delim(std::string* delim) {
  if (delim != nullptr) {
    
  } else {
    
  }
  delim_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), delim,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.ImportEdge.delim)
}

// bool header = 6;
inline void ImportEdge::clear_header() {
  header_ = false;
}
inline bool ImportEdge::_internal_header() const {
  return header_;
}
inline bool ImportEdge::header() const {
  // @@protoc_insertion_point(field_get:dan.ImportEdge.header)
  return _internal_header();
}
inline void ImportEdge::_internal_set_header(bool value) {
  
  header_ = value;
}
inline void ImportEdge::set_header(bool value) {
  _internal_set_header(value);
  // @@protoc_insertion_point(field_set:dan.ImportEdge.header)
}

// int32 batch = 7;
inline void ImportEdge::clear_batch() {
  batch_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImportEdge::_internal_batch() const {
  return batch_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImportEdge::batch() const {
  // @@protoc_insertion_point(field_get:dan.ImportEdge.batch)
  return _internal_batch();
}
inline void ImportEdge::_internal_set_batch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  batch_ = value;
}
inline void ImportEdge::set_batch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batch(value);
  // @@protoc_insertion_point(field_set:dan.ImportEdge.batch)
}

// int32 dop = 8;
inline void ImportEdge::clear_dop() {
  dop_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImportEdge::_internal_dop() const {
  return dop_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImportEdge::dop() const {
  // @@protoc_insertion_point(field_get:dan.ImportEdge.dop)
  return _internal_dop();
}
inline void ImportEdge::_internal_set_dop(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dop_ = value;
}
inline void ImportEdge::set_dop(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dop(value);
  // @@protoc_insertion_point(field_set:dan.ImportEdge.dop)
}

// -------------------------------------------------------------------

// InsertEdge

// string gname = 1;
inline void InsertEdge::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& InsertEdge::gname() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdge.gname)
  return _internal_gname();
}
inline void InsertEdge::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdge.gname)
}
inline std::string* InsertEdge::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdge.gname)
  return _internal_mutable_gname();
}
inline const std::string& InsertEdge::_internal_gname() const {
  return gname_.Get();
}
inline void InsertEdge::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InsertEdge::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.InsertEdge.gname)
}
inline void InsertEdge::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.InsertEdge.gname)
}
inline void InsertEdge::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.InsertEdge.gname)
}
inline std::string* InsertEdge::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InsertEdge::release_gname() {
  // @@protoc_insertion_point(field_release:dan.InsertEdge.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsertEdge::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdge.gname)
}

// .dan.Eval src = 2;
inline bool InsertEdge::_internal_has_src() const {
  return this != internal_default_instance() && src_ != nullptr;
}
inline bool InsertEdge::has_src() const {
  return _internal_has_src();
}
inline void InsertEdge::clear_src() {
  if (GetArena() == nullptr && src_ != nullptr) {
    delete src_;
  }
  src_ = nullptr;
}
inline const ::dan::Eval& InsertEdge::_internal_src() const {
  const ::dan::Eval* p = src_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Eval&>(
      ::dan::_Eval_default_instance_);
}
inline const ::dan::Eval& InsertEdge::src() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdge.src)
  return _internal_src();
}
inline void InsertEdge::unsafe_arena_set_allocated_src(
    ::dan::Eval* src) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  src_ = src;
  if (src) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdge.src)
}
inline ::dan::Eval* InsertEdge::release_src() {
  
  ::dan::Eval* temp = src_;
  src_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Eval* InsertEdge::unsafe_arena_release_src() {
  // @@protoc_insertion_point(field_release:dan.InsertEdge.src)
  
  ::dan::Eval* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::dan::Eval* InsertEdge::_internal_mutable_src() {
  
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Eval>(GetArena());
    src_ = p;
  }
  return src_;
}
inline ::dan::Eval* InsertEdge::mutable_src() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdge.src)
  return _internal_mutable_src();
}
inline void InsertEdge::set_allocated_src(::dan::Eval* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete src_;
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(src);
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    
  } else {
    
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdge.src)
}

// .dan.Eval dest = 3;
inline bool InsertEdge::_internal_has_dest() const {
  return this != internal_default_instance() && dest_ != nullptr;
}
inline bool InsertEdge::has_dest() const {
  return _internal_has_dest();
}
inline void InsertEdge::clear_dest() {
  if (GetArena() == nullptr && dest_ != nullptr) {
    delete dest_;
  }
  dest_ = nullptr;
}
inline const ::dan::Eval& InsertEdge::_internal_dest() const {
  const ::dan::Eval* p = dest_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Eval&>(
      ::dan::_Eval_default_instance_);
}
inline const ::dan::Eval& InsertEdge::dest() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdge.dest)
  return _internal_dest();
}
inline void InsertEdge::unsafe_arena_set_allocated_dest(
    ::dan::Eval* dest) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dest_);
  }
  dest_ = dest;
  if (dest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdge.dest)
}
inline ::dan::Eval* InsertEdge::release_dest() {
  
  ::dan::Eval* temp = dest_;
  dest_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Eval* InsertEdge::unsafe_arena_release_dest() {
  // @@protoc_insertion_point(field_release:dan.InsertEdge.dest)
  
  ::dan::Eval* temp = dest_;
  dest_ = nullptr;
  return temp;
}
inline ::dan::Eval* InsertEdge::_internal_mutable_dest() {
  
  if (dest_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Eval>(GetArena());
    dest_ = p;
  }
  return dest_;
}
inline ::dan::Eval* InsertEdge::mutable_dest() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdge.dest)
  return _internal_mutable_dest();
}
inline void InsertEdge::set_allocated_dest(::dan::Eval* dest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete dest_;
  }
  if (dest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dest);
    if (message_arena != submessage_arena) {
      dest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dest, submessage_arena);
    }
    
  } else {
    
  }
  dest_ = dest;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdge.dest)
}

// int32 src_vpid = 4;
inline void InsertEdge::clear_src_vpid() {
  src_vpid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertEdge::_internal_src_vpid() const {
  return src_vpid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertEdge::src_vpid() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdge.src_vpid)
  return _internal_src_vpid();
}
inline void InsertEdge::_internal_set_src_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  src_vpid_ = value;
}
inline void InsertEdge::set_src_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_src_vpid(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdge.src_vpid)
}

// int32 dest_vpid = 5;
inline void InsertEdge::clear_dest_vpid() {
  dest_vpid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertEdge::_internal_dest_vpid() const {
  return dest_vpid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertEdge::dest_vpid() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdge.dest_vpid)
  return _internal_dest_vpid();
}
inline void InsertEdge::_internal_set_dest_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dest_vpid_ = value;
}
inline void InsertEdge::set_dest_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dest_vpid(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdge.dest_vpid)
}

// .dan.Record eprop = 6;
inline bool InsertEdge::_internal_has_eprop() const {
  return this != internal_default_instance() && eprop_ != nullptr;
}
inline bool InsertEdge::has_eprop() const {
  return _internal_has_eprop();
}
inline void InsertEdge::clear_eprop() {
  if (GetArena() == nullptr && eprop_ != nullptr) {
    delete eprop_;
  }
  eprop_ = nullptr;
}
inline const ::dan::Record& InsertEdge::_internal_eprop() const {
  const ::dan::Record* p = eprop_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& InsertEdge::eprop() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdge.eprop)
  return _internal_eprop();
}
inline void InsertEdge::unsafe_arena_set_allocated_eprop(
    ::dan::Record* eprop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eprop_);
  }
  eprop_ = eprop;
  if (eprop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdge.eprop)
}
inline ::dan::Record* InsertEdge::release_eprop() {
  
  ::dan::Record* temp = eprop_;
  eprop_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* InsertEdge::unsafe_arena_release_eprop() {
  // @@protoc_insertion_point(field_release:dan.InsertEdge.eprop)
  
  ::dan::Record* temp = eprop_;
  eprop_ = nullptr;
  return temp;
}
inline ::dan::Record* InsertEdge::_internal_mutable_eprop() {
  
  if (eprop_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    eprop_ = p;
  }
  return eprop_;
}
inline ::dan::Record* InsertEdge::mutable_eprop() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdge.eprop)
  return _internal_mutable_eprop();
}
inline void InsertEdge::set_allocated_eprop(::dan::Record* eprop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete eprop_;
  }
  if (eprop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(eprop);
    if (message_arena != submessage_arena) {
      eprop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eprop, submessage_arena);
    }
    
  } else {
    
  }
  eprop_ = eprop;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdge.eprop)
}

// bool ignore_in = 7;
inline void InsertEdge::clear_ignore_in() {
  ignore_in_ = false;
}
inline bool InsertEdge::_internal_ignore_in() const {
  return ignore_in_;
}
inline bool InsertEdge::ignore_in() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdge.ignore_in)
  return _internal_ignore_in();
}
inline void InsertEdge::_internal_set_ignore_in(bool value) {
  
  ignore_in_ = value;
}
inline void InsertEdge::set_ignore_in(bool value) {
  _internal_set_ignore_in(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdge.ignore_in)
}

// bool only_in = 8;
inline void InsertEdge::clear_only_in() {
  only_in_ = false;
}
inline bool InsertEdge::_internal_only_in() const {
  return only_in_;
}
inline bool InsertEdge::only_in() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdge.only_in)
  return _internal_only_in();
}
inline void InsertEdge::_internal_set_only_in(bool value) {
  
  only_in_ = value;
}
inline void InsertEdge::set_only_in(bool value) {
  _internal_set_only_in(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdge.only_in)
}

// -------------------------------------------------------------------

// InsertEdgeVP

// string gname = 1;
inline void InsertEdgeVP::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& InsertEdgeVP::gname() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeVP.gname)
  return _internal_gname();
}
inline void InsertEdgeVP::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdgeVP.gname)
}
inline std::string* InsertEdgeVP::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeVP.gname)
  return _internal_mutable_gname();
}
inline const std::string& InsertEdgeVP::_internal_gname() const {
  return gname_.Get();
}
inline void InsertEdgeVP::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InsertEdgeVP::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.InsertEdgeVP.gname)
}
inline void InsertEdgeVP::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.InsertEdgeVP.gname)
}
inline void InsertEdgeVP::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.InsertEdgeVP.gname)
}
inline std::string* InsertEdgeVP::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InsertEdgeVP::release_gname() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeVP.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsertEdgeVP::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeVP.gname)
}

// .dan.Record src = 2;
inline bool InsertEdgeVP::_internal_has_src() const {
  return this != internal_default_instance() && src_ != nullptr;
}
inline bool InsertEdgeVP::has_src() const {
  return _internal_has_src();
}
inline void InsertEdgeVP::clear_src() {
  if (GetArena() == nullptr && src_ != nullptr) {
    delete src_;
  }
  src_ = nullptr;
}
inline const ::dan::Record& InsertEdgeVP::_internal_src() const {
  const ::dan::Record* p = src_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& InsertEdgeVP::src() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeVP.src)
  return _internal_src();
}
inline void InsertEdgeVP::unsafe_arena_set_allocated_src(
    ::dan::Record* src) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  src_ = src;
  if (src) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdgeVP.src)
}
inline ::dan::Record* InsertEdgeVP::release_src() {
  
  ::dan::Record* temp = src_;
  src_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* InsertEdgeVP::unsafe_arena_release_src() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeVP.src)
  
  ::dan::Record* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::dan::Record* InsertEdgeVP::_internal_mutable_src() {
  
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    src_ = p;
  }
  return src_;
}
inline ::dan::Record* InsertEdgeVP::mutable_src() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeVP.src)
  return _internal_mutable_src();
}
inline void InsertEdgeVP::set_allocated_src(::dan::Record* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete src_;
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(src);
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    
  } else {
    
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeVP.src)
}

// .dan.Record dest = 3;
inline bool InsertEdgeVP::_internal_has_dest() const {
  return this != internal_default_instance() && dest_ != nullptr;
}
inline bool InsertEdgeVP::has_dest() const {
  return _internal_has_dest();
}
inline void InsertEdgeVP::clear_dest() {
  if (GetArena() == nullptr && dest_ != nullptr) {
    delete dest_;
  }
  dest_ = nullptr;
}
inline const ::dan::Record& InsertEdgeVP::_internal_dest() const {
  const ::dan::Record* p = dest_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& InsertEdgeVP::dest() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeVP.dest)
  return _internal_dest();
}
inline void InsertEdgeVP::unsafe_arena_set_allocated_dest(
    ::dan::Record* dest) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dest_);
  }
  dest_ = dest;
  if (dest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdgeVP.dest)
}
inline ::dan::Record* InsertEdgeVP::release_dest() {
  
  ::dan::Record* temp = dest_;
  dest_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* InsertEdgeVP::unsafe_arena_release_dest() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeVP.dest)
  
  ::dan::Record* temp = dest_;
  dest_ = nullptr;
  return temp;
}
inline ::dan::Record* InsertEdgeVP::_internal_mutable_dest() {
  
  if (dest_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    dest_ = p;
  }
  return dest_;
}
inline ::dan::Record* InsertEdgeVP::mutable_dest() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeVP.dest)
  return _internal_mutable_dest();
}
inline void InsertEdgeVP::set_allocated_dest(::dan::Record* dest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete dest_;
  }
  if (dest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dest);
    if (message_arena != submessage_arena) {
      dest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dest, submessage_arena);
    }
    
  } else {
    
  }
  dest_ = dest;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeVP.dest)
}

// int32 src_vpid = 4;
inline void InsertEdgeVP::clear_src_vpid() {
  src_vpid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertEdgeVP::_internal_src_vpid() const {
  return src_vpid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertEdgeVP::src_vpid() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeVP.src_vpid)
  return _internal_src_vpid();
}
inline void InsertEdgeVP::_internal_set_src_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  src_vpid_ = value;
}
inline void InsertEdgeVP::set_src_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_src_vpid(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdgeVP.src_vpid)
}

// int32 dest_vpid = 5;
inline void InsertEdgeVP::clear_dest_vpid() {
  dest_vpid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertEdgeVP::_internal_dest_vpid() const {
  return dest_vpid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertEdgeVP::dest_vpid() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeVP.dest_vpid)
  return _internal_dest_vpid();
}
inline void InsertEdgeVP::_internal_set_dest_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dest_vpid_ = value;
}
inline void InsertEdgeVP::set_dest_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dest_vpid(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdgeVP.dest_vpid)
}

// .dan.Record eprop = 6;
inline bool InsertEdgeVP::_internal_has_eprop() const {
  return this != internal_default_instance() && eprop_ != nullptr;
}
inline bool InsertEdgeVP::has_eprop() const {
  return _internal_has_eprop();
}
inline void InsertEdgeVP::clear_eprop() {
  if (GetArena() == nullptr && eprop_ != nullptr) {
    delete eprop_;
  }
  eprop_ = nullptr;
}
inline const ::dan::Record& InsertEdgeVP::_internal_eprop() const {
  const ::dan::Record* p = eprop_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& InsertEdgeVP::eprop() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeVP.eprop)
  return _internal_eprop();
}
inline void InsertEdgeVP::unsafe_arena_set_allocated_eprop(
    ::dan::Record* eprop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eprop_);
  }
  eprop_ = eprop;
  if (eprop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdgeVP.eprop)
}
inline ::dan::Record* InsertEdgeVP::release_eprop() {
  
  ::dan::Record* temp = eprop_;
  eprop_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* InsertEdgeVP::unsafe_arena_release_eprop() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeVP.eprop)
  
  ::dan::Record* temp = eprop_;
  eprop_ = nullptr;
  return temp;
}
inline ::dan::Record* InsertEdgeVP::_internal_mutable_eprop() {
  
  if (eprop_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    eprop_ = p;
  }
  return eprop_;
}
inline ::dan::Record* InsertEdgeVP::mutable_eprop() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeVP.eprop)
  return _internal_mutable_eprop();
}
inline void InsertEdgeVP::set_allocated_eprop(::dan::Record* eprop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete eprop_;
  }
  if (eprop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(eprop);
    if (message_arena != submessage_arena) {
      eprop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eprop, submessage_arena);
    }
    
  } else {
    
  }
  eprop_ = eprop;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeVP.eprop)
}

// -------------------------------------------------------------------

// InsertEdgeNaive

// string gname = 1;
inline void InsertEdgeNaive::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& InsertEdgeNaive::gname() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeNaive.gname)
  return _internal_gname();
}
inline void InsertEdgeNaive::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdgeNaive.gname)
}
inline std::string* InsertEdgeNaive::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeNaive.gname)
  return _internal_mutable_gname();
}
inline const std::string& InsertEdgeNaive::_internal_gname() const {
  return gname_.Get();
}
inline void InsertEdgeNaive::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InsertEdgeNaive::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.InsertEdgeNaive.gname)
}
inline void InsertEdgeNaive::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.InsertEdgeNaive.gname)
}
inline void InsertEdgeNaive::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.InsertEdgeNaive.gname)
}
inline std::string* InsertEdgeNaive::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InsertEdgeNaive::release_gname() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeNaive.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsertEdgeNaive::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeNaive.gname)
}

// int64 src = 2;
inline void InsertEdgeNaive::clear_src() {
  src_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InsertEdgeNaive::_internal_src() const {
  return src_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InsertEdgeNaive::src() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeNaive.src)
  return _internal_src();
}
inline void InsertEdgeNaive::_internal_set_src(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  src_ = value;
}
inline void InsertEdgeNaive::set_src(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_src(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdgeNaive.src)
}

// int64 dest = 3;
inline void InsertEdgeNaive::clear_dest() {
  dest_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InsertEdgeNaive::_internal_dest() const {
  return dest_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InsertEdgeNaive::dest() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeNaive.dest)
  return _internal_dest();
}
inline void InsertEdgeNaive::_internal_set_dest(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  dest_ = value;
}
inline void InsertEdgeNaive::set_dest(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_dest(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdgeNaive.dest)
}

// .dan.Record eprop = 4;
inline bool InsertEdgeNaive::_internal_has_eprop() const {
  return this != internal_default_instance() && eprop_ != nullptr;
}
inline bool InsertEdgeNaive::has_eprop() const {
  return _internal_has_eprop();
}
inline void InsertEdgeNaive::clear_eprop() {
  if (GetArena() == nullptr && eprop_ != nullptr) {
    delete eprop_;
  }
  eprop_ = nullptr;
}
inline const ::dan::Record& InsertEdgeNaive::_internal_eprop() const {
  const ::dan::Record* p = eprop_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& InsertEdgeNaive::eprop() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeNaive.eprop)
  return _internal_eprop();
}
inline void InsertEdgeNaive::unsafe_arena_set_allocated_eprop(
    ::dan::Record* eprop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eprop_);
  }
  eprop_ = eprop;
  if (eprop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdgeNaive.eprop)
}
inline ::dan::Record* InsertEdgeNaive::release_eprop() {
  
  ::dan::Record* temp = eprop_;
  eprop_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* InsertEdgeNaive::unsafe_arena_release_eprop() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeNaive.eprop)
  
  ::dan::Record* temp = eprop_;
  eprop_ = nullptr;
  return temp;
}
inline ::dan::Record* InsertEdgeNaive::_internal_mutable_eprop() {
  
  if (eprop_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    eprop_ = p;
  }
  return eprop_;
}
inline ::dan::Record* InsertEdgeNaive::mutable_eprop() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeNaive.eprop)
  return _internal_mutable_eprop();
}
inline void InsertEdgeNaive::set_allocated_eprop(::dan::Record* eprop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete eprop_;
  }
  if (eprop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(eprop);
    if (message_arena != submessage_arena) {
      eprop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eprop, submessage_arena);
    }
    
  } else {
    
  }
  eprop_ = eprop;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeNaive.eprop)
}

// bool ignore_in = 5;
inline void InsertEdgeNaive::clear_ignore_in() {
  ignore_in_ = false;
}
inline bool InsertEdgeNaive::_internal_ignore_in() const {
  return ignore_in_;
}
inline bool InsertEdgeNaive::ignore_in() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeNaive.ignore_in)
  return _internal_ignore_in();
}
inline void InsertEdgeNaive::_internal_set_ignore_in(bool value) {
  
  ignore_in_ = value;
}
inline void InsertEdgeNaive::set_ignore_in(bool value) {
  _internal_set_ignore_in(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdgeNaive.ignore_in)
}

// bool only_in = 6;
inline void InsertEdgeNaive::clear_only_in() {
  only_in_ = false;
}
inline bool InsertEdgeNaive::_internal_only_in() const {
  return only_in_;
}
inline bool InsertEdgeNaive::only_in() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeNaive.only_in)
  return _internal_only_in();
}
inline void InsertEdgeNaive::_internal_set_only_in(bool value) {
  
  only_in_ = value;
}
inline void InsertEdgeNaive::set_only_in(bool value) {
  _internal_set_only_in(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdgeNaive.only_in)
}

// -------------------------------------------------------------------

// InsertEdgeBatch

// string gname = 1;
inline void InsertEdgeBatch::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& InsertEdgeBatch::gname() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeBatch.gname)
  return _internal_gname();
}
inline void InsertEdgeBatch::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdgeBatch.gname)
}
inline std::string* InsertEdgeBatch::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeBatch.gname)
  return _internal_mutable_gname();
}
inline const std::string& InsertEdgeBatch::_internal_gname() const {
  return gname_.Get();
}
inline void InsertEdgeBatch::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InsertEdgeBatch::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.InsertEdgeBatch.gname)
}
inline void InsertEdgeBatch::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.InsertEdgeBatch.gname)
}
inline void InsertEdgeBatch::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.InsertEdgeBatch.gname)
}
inline std::string* InsertEdgeBatch::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InsertEdgeBatch::release_gname() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeBatch.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsertEdgeBatch::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeBatch.gname)
}

// .dan.Record src = 2;
inline bool InsertEdgeBatch::_internal_has_src() const {
  return this != internal_default_instance() && src_ != nullptr;
}
inline bool InsertEdgeBatch::has_src() const {
  return _internal_has_src();
}
inline void InsertEdgeBatch::clear_src() {
  if (GetArena() == nullptr && src_ != nullptr) {
    delete src_;
  }
  src_ = nullptr;
}
inline const ::dan::Record& InsertEdgeBatch::_internal_src() const {
  const ::dan::Record* p = src_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& InsertEdgeBatch::src() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeBatch.src)
  return _internal_src();
}
inline void InsertEdgeBatch::unsafe_arena_set_allocated_src(
    ::dan::Record* src) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  src_ = src;
  if (src) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdgeBatch.src)
}
inline ::dan::Record* InsertEdgeBatch::release_src() {
  
  ::dan::Record* temp = src_;
  src_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* InsertEdgeBatch::unsafe_arena_release_src() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeBatch.src)
  
  ::dan::Record* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::dan::Record* InsertEdgeBatch::_internal_mutable_src() {
  
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    src_ = p;
  }
  return src_;
}
inline ::dan::Record* InsertEdgeBatch::mutable_src() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeBatch.src)
  return _internal_mutable_src();
}
inline void InsertEdgeBatch::set_allocated_src(::dan::Record* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete src_;
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(src);
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    
  } else {
    
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeBatch.src)
}

// .dan.Record dest = 3;
inline bool InsertEdgeBatch::_internal_has_dest() const {
  return this != internal_default_instance() && dest_ != nullptr;
}
inline bool InsertEdgeBatch::has_dest() const {
  return _internal_has_dest();
}
inline void InsertEdgeBatch::clear_dest() {
  if (GetArena() == nullptr && dest_ != nullptr) {
    delete dest_;
  }
  dest_ = nullptr;
}
inline const ::dan::Record& InsertEdgeBatch::_internal_dest() const {
  const ::dan::Record* p = dest_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& InsertEdgeBatch::dest() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeBatch.dest)
  return _internal_dest();
}
inline void InsertEdgeBatch::unsafe_arena_set_allocated_dest(
    ::dan::Record* dest) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dest_);
  }
  dest_ = dest;
  if (dest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdgeBatch.dest)
}
inline ::dan::Record* InsertEdgeBatch::release_dest() {
  
  ::dan::Record* temp = dest_;
  dest_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* InsertEdgeBatch::unsafe_arena_release_dest() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeBatch.dest)
  
  ::dan::Record* temp = dest_;
  dest_ = nullptr;
  return temp;
}
inline ::dan::Record* InsertEdgeBatch::_internal_mutable_dest() {
  
  if (dest_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    dest_ = p;
  }
  return dest_;
}
inline ::dan::Record* InsertEdgeBatch::mutable_dest() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeBatch.dest)
  return _internal_mutable_dest();
}
inline void InsertEdgeBatch::set_allocated_dest(::dan::Record* dest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete dest_;
  }
  if (dest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dest);
    if (message_arena != submessage_arena) {
      dest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dest, submessage_arena);
    }
    
  } else {
    
  }
  dest_ = dest;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeBatch.dest)
}

// .dan.Table eprop = 4;
inline bool InsertEdgeBatch::_internal_has_eprop() const {
  return this != internal_default_instance() && eprop_ != nullptr;
}
inline bool InsertEdgeBatch::has_eprop() const {
  return _internal_has_eprop();
}
inline void InsertEdgeBatch::clear_eprop() {
  if (GetArena() == nullptr && eprop_ != nullptr) {
    delete eprop_;
  }
  eprop_ = nullptr;
}
inline const ::dan::Table& InsertEdgeBatch::_internal_eprop() const {
  const ::dan::Table* p = eprop_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Table&>(
      ::dan::_Table_default_instance_);
}
inline const ::dan::Table& InsertEdgeBatch::eprop() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeBatch.eprop)
  return _internal_eprop();
}
inline void InsertEdgeBatch::unsafe_arena_set_allocated_eprop(
    ::dan::Table* eprop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eprop_);
  }
  eprop_ = eprop;
  if (eprop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdgeBatch.eprop)
}
inline ::dan::Table* InsertEdgeBatch::release_eprop() {
  
  ::dan::Table* temp = eprop_;
  eprop_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Table* InsertEdgeBatch::unsafe_arena_release_eprop() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeBatch.eprop)
  
  ::dan::Table* temp = eprop_;
  eprop_ = nullptr;
  return temp;
}
inline ::dan::Table* InsertEdgeBatch::_internal_mutable_eprop() {
  
  if (eprop_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Table>(GetArena());
    eprop_ = p;
  }
  return eprop_;
}
inline ::dan::Table* InsertEdgeBatch::mutable_eprop() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeBatch.eprop)
  return _internal_mutable_eprop();
}
inline void InsertEdgeBatch::set_allocated_eprop(::dan::Table* eprop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete eprop_;
  }
  if (eprop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(eprop);
    if (message_arena != submessage_arena) {
      eprop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eprop, submessage_arena);
    }
    
  } else {
    
  }
  eprop_ = eprop;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeBatch.eprop)
}

// .dan.IntVec src_vpid = 5;
inline bool InsertEdgeBatch::_internal_has_src_vpid() const {
  return this != internal_default_instance() && src_vpid_ != nullptr;
}
inline bool InsertEdgeBatch::has_src_vpid() const {
  return _internal_has_src_vpid();
}
inline void InsertEdgeBatch::clear_src_vpid() {
  if (GetArena() == nullptr && src_vpid_ != nullptr) {
    delete src_vpid_;
  }
  src_vpid_ = nullptr;
}
inline const ::dan::IntVec& InsertEdgeBatch::_internal_src_vpid() const {
  const ::dan::IntVec* p = src_vpid_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::IntVec&>(
      ::dan::_IntVec_default_instance_);
}
inline const ::dan::IntVec& InsertEdgeBatch::src_vpid() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeBatch.src_vpid)
  return _internal_src_vpid();
}
inline void InsertEdgeBatch::unsafe_arena_set_allocated_src_vpid(
    ::dan::IntVec* src_vpid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_vpid_);
  }
  src_vpid_ = src_vpid;
  if (src_vpid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdgeBatch.src_vpid)
}
inline ::dan::IntVec* InsertEdgeBatch::release_src_vpid() {
  
  ::dan::IntVec* temp = src_vpid_;
  src_vpid_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::IntVec* InsertEdgeBatch::unsafe_arena_release_src_vpid() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeBatch.src_vpid)
  
  ::dan::IntVec* temp = src_vpid_;
  src_vpid_ = nullptr;
  return temp;
}
inline ::dan::IntVec* InsertEdgeBatch::_internal_mutable_src_vpid() {
  
  if (src_vpid_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::IntVec>(GetArena());
    src_vpid_ = p;
  }
  return src_vpid_;
}
inline ::dan::IntVec* InsertEdgeBatch::mutable_src_vpid() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeBatch.src_vpid)
  return _internal_mutable_src_vpid();
}
inline void InsertEdgeBatch::set_allocated_src_vpid(::dan::IntVec* src_vpid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete src_vpid_;
  }
  if (src_vpid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(src_vpid);
    if (message_arena != submessage_arena) {
      src_vpid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src_vpid, submessage_arena);
    }
    
  } else {
    
  }
  src_vpid_ = src_vpid;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeBatch.src_vpid)
}

// .dan.IntVec dest_vpid = 6;
inline bool InsertEdgeBatch::_internal_has_dest_vpid() const {
  return this != internal_default_instance() && dest_vpid_ != nullptr;
}
inline bool InsertEdgeBatch::has_dest_vpid() const {
  return _internal_has_dest_vpid();
}
inline void InsertEdgeBatch::clear_dest_vpid() {
  if (GetArena() == nullptr && dest_vpid_ != nullptr) {
    delete dest_vpid_;
  }
  dest_vpid_ = nullptr;
}
inline const ::dan::IntVec& InsertEdgeBatch::_internal_dest_vpid() const {
  const ::dan::IntVec* p = dest_vpid_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::IntVec&>(
      ::dan::_IntVec_default_instance_);
}
inline const ::dan::IntVec& InsertEdgeBatch::dest_vpid() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeBatch.dest_vpid)
  return _internal_dest_vpid();
}
inline void InsertEdgeBatch::unsafe_arena_set_allocated_dest_vpid(
    ::dan::IntVec* dest_vpid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dest_vpid_);
  }
  dest_vpid_ = dest_vpid;
  if (dest_vpid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdgeBatch.dest_vpid)
}
inline ::dan::IntVec* InsertEdgeBatch::release_dest_vpid() {
  
  ::dan::IntVec* temp = dest_vpid_;
  dest_vpid_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::IntVec* InsertEdgeBatch::unsafe_arena_release_dest_vpid() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeBatch.dest_vpid)
  
  ::dan::IntVec* temp = dest_vpid_;
  dest_vpid_ = nullptr;
  return temp;
}
inline ::dan::IntVec* InsertEdgeBatch::_internal_mutable_dest_vpid() {
  
  if (dest_vpid_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::IntVec>(GetArena());
    dest_vpid_ = p;
  }
  return dest_vpid_;
}
inline ::dan::IntVec* InsertEdgeBatch::mutable_dest_vpid() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeBatch.dest_vpid)
  return _internal_mutable_dest_vpid();
}
inline void InsertEdgeBatch::set_allocated_dest_vpid(::dan::IntVec* dest_vpid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete dest_vpid_;
  }
  if (dest_vpid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dest_vpid);
    if (message_arena != submessage_arena) {
      dest_vpid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dest_vpid, submessage_arena);
    }
    
  } else {
    
  }
  dest_vpid_ = dest_vpid;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeBatch.dest_vpid)
}

// bool ignore_in = 7;
inline void InsertEdgeBatch::clear_ignore_in() {
  ignore_in_ = false;
}
inline bool InsertEdgeBatch::_internal_ignore_in() const {
  return ignore_in_;
}
inline bool InsertEdgeBatch::ignore_in() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeBatch.ignore_in)
  return _internal_ignore_in();
}
inline void InsertEdgeBatch::_internal_set_ignore_in(bool value) {
  
  ignore_in_ = value;
}
inline void InsertEdgeBatch::set_ignore_in(bool value) {
  _internal_set_ignore_in(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdgeBatch.ignore_in)
}

// bool only_in = 8;
inline void InsertEdgeBatch::clear_only_in() {
  only_in_ = false;
}
inline bool InsertEdgeBatch::_internal_only_in() const {
  return only_in_;
}
inline bool InsertEdgeBatch::only_in() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeBatch.only_in)
  return _internal_only_in();
}
inline void InsertEdgeBatch::_internal_set_only_in(bool value) {
  
  only_in_ = value;
}
inline void InsertEdgeBatch::set_only_in(bool value) {
  _internal_set_only_in(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdgeBatch.only_in)
}

// -------------------------------------------------------------------

// InsertEdgeBatchVP

// string gname = 1;
inline void InsertEdgeBatchVP::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& InsertEdgeBatchVP::gname() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeBatchVP.gname)
  return _internal_gname();
}
inline void InsertEdgeBatchVP::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.InsertEdgeBatchVP.gname)
}
inline std::string* InsertEdgeBatchVP::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeBatchVP.gname)
  return _internal_mutable_gname();
}
inline const std::string& InsertEdgeBatchVP::_internal_gname() const {
  return gname_.Get();
}
inline void InsertEdgeBatchVP::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InsertEdgeBatchVP::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.InsertEdgeBatchVP.gname)
}
inline void InsertEdgeBatchVP::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.InsertEdgeBatchVP.gname)
}
inline void InsertEdgeBatchVP::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.InsertEdgeBatchVP.gname)
}
inline std::string* InsertEdgeBatchVP::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InsertEdgeBatchVP::release_gname() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeBatchVP.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsertEdgeBatchVP::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeBatchVP.gname)
}

// .dan.Table src = 2;
inline bool InsertEdgeBatchVP::_internal_has_src() const {
  return this != internal_default_instance() && src_ != nullptr;
}
inline bool InsertEdgeBatchVP::has_src() const {
  return _internal_has_src();
}
inline void InsertEdgeBatchVP::clear_src() {
  if (GetArena() == nullptr && src_ != nullptr) {
    delete src_;
  }
  src_ = nullptr;
}
inline const ::dan::Table& InsertEdgeBatchVP::_internal_src() const {
  const ::dan::Table* p = src_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Table&>(
      ::dan::_Table_default_instance_);
}
inline const ::dan::Table& InsertEdgeBatchVP::src() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeBatchVP.src)
  return _internal_src();
}
inline void InsertEdgeBatchVP::unsafe_arena_set_allocated_src(
    ::dan::Table* src) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  src_ = src;
  if (src) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdgeBatchVP.src)
}
inline ::dan::Table* InsertEdgeBatchVP::release_src() {
  
  ::dan::Table* temp = src_;
  src_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Table* InsertEdgeBatchVP::unsafe_arena_release_src() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeBatchVP.src)
  
  ::dan::Table* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::dan::Table* InsertEdgeBatchVP::_internal_mutable_src() {
  
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Table>(GetArena());
    src_ = p;
  }
  return src_;
}
inline ::dan::Table* InsertEdgeBatchVP::mutable_src() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeBatchVP.src)
  return _internal_mutable_src();
}
inline void InsertEdgeBatchVP::set_allocated_src(::dan::Table* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete src_;
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(src);
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    
  } else {
    
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeBatchVP.src)
}

// .dan.Table dest = 3;
inline bool InsertEdgeBatchVP::_internal_has_dest() const {
  return this != internal_default_instance() && dest_ != nullptr;
}
inline bool InsertEdgeBatchVP::has_dest() const {
  return _internal_has_dest();
}
inline void InsertEdgeBatchVP::clear_dest() {
  if (GetArena() == nullptr && dest_ != nullptr) {
    delete dest_;
  }
  dest_ = nullptr;
}
inline const ::dan::Table& InsertEdgeBatchVP::_internal_dest() const {
  const ::dan::Table* p = dest_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Table&>(
      ::dan::_Table_default_instance_);
}
inline const ::dan::Table& InsertEdgeBatchVP::dest() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeBatchVP.dest)
  return _internal_dest();
}
inline void InsertEdgeBatchVP::unsafe_arena_set_allocated_dest(
    ::dan::Table* dest) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dest_);
  }
  dest_ = dest;
  if (dest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdgeBatchVP.dest)
}
inline ::dan::Table* InsertEdgeBatchVP::release_dest() {
  
  ::dan::Table* temp = dest_;
  dest_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Table* InsertEdgeBatchVP::unsafe_arena_release_dest() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeBatchVP.dest)
  
  ::dan::Table* temp = dest_;
  dest_ = nullptr;
  return temp;
}
inline ::dan::Table* InsertEdgeBatchVP::_internal_mutable_dest() {
  
  if (dest_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Table>(GetArena());
    dest_ = p;
  }
  return dest_;
}
inline ::dan::Table* InsertEdgeBatchVP::mutable_dest() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeBatchVP.dest)
  return _internal_mutable_dest();
}
inline void InsertEdgeBatchVP::set_allocated_dest(::dan::Table* dest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete dest_;
  }
  if (dest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dest);
    if (message_arena != submessage_arena) {
      dest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dest, submessage_arena);
    }
    
  } else {
    
  }
  dest_ = dest;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeBatchVP.dest)
}

// .dan.Table eprop = 4;
inline bool InsertEdgeBatchVP::_internal_has_eprop() const {
  return this != internal_default_instance() && eprop_ != nullptr;
}
inline bool InsertEdgeBatchVP::has_eprop() const {
  return _internal_has_eprop();
}
inline void InsertEdgeBatchVP::clear_eprop() {
  if (GetArena() == nullptr && eprop_ != nullptr) {
    delete eprop_;
  }
  eprop_ = nullptr;
}
inline const ::dan::Table& InsertEdgeBatchVP::_internal_eprop() const {
  const ::dan::Table* p = eprop_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Table&>(
      ::dan::_Table_default_instance_);
}
inline const ::dan::Table& InsertEdgeBatchVP::eprop() const {
  // @@protoc_insertion_point(field_get:dan.InsertEdgeBatchVP.eprop)
  return _internal_eprop();
}
inline void InsertEdgeBatchVP::unsafe_arena_set_allocated_eprop(
    ::dan::Table* eprop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eprop_);
  }
  eprop_ = eprop;
  if (eprop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.InsertEdgeBatchVP.eprop)
}
inline ::dan::Table* InsertEdgeBatchVP::release_eprop() {
  
  ::dan::Table* temp = eprop_;
  eprop_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Table* InsertEdgeBatchVP::unsafe_arena_release_eprop() {
  // @@protoc_insertion_point(field_release:dan.InsertEdgeBatchVP.eprop)
  
  ::dan::Table* temp = eprop_;
  eprop_ = nullptr;
  return temp;
}
inline ::dan::Table* InsertEdgeBatchVP::_internal_mutable_eprop() {
  
  if (eprop_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Table>(GetArena());
    eprop_ = p;
  }
  return eprop_;
}
inline ::dan::Table* InsertEdgeBatchVP::mutable_eprop() {
  // @@protoc_insertion_point(field_mutable:dan.InsertEdgeBatchVP.eprop)
  return _internal_mutable_eprop();
}
inline void InsertEdgeBatchVP::set_allocated_eprop(::dan::Table* eprop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete eprop_;
  }
  if (eprop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(eprop);
    if (message_arena != submessage_arena) {
      eprop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eprop, submessage_arena);
    }
    
  } else {
    
  }
  eprop_ = eprop;
  // @@protoc_insertion_point(field_set_allocated:dan.InsertEdgeBatchVP.eprop)
}

// -------------------------------------------------------------------

// TableScan

// string tname = 1;
inline void TableScan::clear_tname() {
  tname_.ClearToEmpty();
}
inline const std::string& TableScan::tname() const {
  // @@protoc_insertion_point(field_get:dan.TableScan.tname)
  return _internal_tname();
}
inline void TableScan::set_tname(const std::string& value) {
  _internal_set_tname(value);
  // @@protoc_insertion_point(field_set:dan.TableScan.tname)
}
inline std::string* TableScan::mutable_tname() {
  // @@protoc_insertion_point(field_mutable:dan.TableScan.tname)
  return _internal_mutable_tname();
}
inline const std::string& TableScan::_internal_tname() const {
  return tname_.Get();
}
inline void TableScan::_internal_set_tname(const std::string& value) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TableScan::set_tname(std::string&& value) {
  
  tname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.TableScan.tname)
}
inline void TableScan::set_tname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.TableScan.tname)
}
inline void TableScan::set_tname(const char* value,
    size_t size) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.TableScan.tname)
}
inline std::string* TableScan::_internal_mutable_tname() {
  
  return tname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TableScan::release_tname() {
  // @@protoc_insertion_point(field_release:dan.TableScan.tname)
  return tname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TableScan::set_allocated_tname(std::string* tname) {
  if (tname != nullptr) {
    
  } else {
    
  }
  tname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.TableScan.tname)
}

// .dan.IntVec fids = 2;
inline bool TableScan::_internal_has_fids() const {
  return this != internal_default_instance() && fids_ != nullptr;
}
inline bool TableScan::has_fids() const {
  return _internal_has_fids();
}
inline void TableScan::clear_fids() {
  if (GetArena() == nullptr && fids_ != nullptr) {
    delete fids_;
  }
  fids_ = nullptr;
}
inline const ::dan::IntVec& TableScan::_internal_fids() const {
  const ::dan::IntVec* p = fids_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::IntVec&>(
      ::dan::_IntVec_default_instance_);
}
inline const ::dan::IntVec& TableScan::fids() const {
  // @@protoc_insertion_point(field_get:dan.TableScan.fids)
  return _internal_fids();
}
inline void TableScan::unsafe_arena_set_allocated_fids(
    ::dan::IntVec* fids) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fids_);
  }
  fids_ = fids;
  if (fids) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.TableScan.fids)
}
inline ::dan::IntVec* TableScan::release_fids() {
  
  ::dan::IntVec* temp = fids_;
  fids_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::IntVec* TableScan::unsafe_arena_release_fids() {
  // @@protoc_insertion_point(field_release:dan.TableScan.fids)
  
  ::dan::IntVec* temp = fids_;
  fids_ = nullptr;
  return temp;
}
inline ::dan::IntVec* TableScan::_internal_mutable_fids() {
  
  if (fids_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::IntVec>(GetArena());
    fids_ = p;
  }
  return fids_;
}
inline ::dan::IntVec* TableScan::mutable_fids() {
  // @@protoc_insertion_point(field_mutable:dan.TableScan.fids)
  return _internal_mutable_fids();
}
inline void TableScan::set_allocated_fids(::dan::IntVec* fids) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fids_;
  }
  if (fids) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fids);
    if (message_arena != submessage_arena) {
      fids = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fids, submessage_arena);
    }
    
  } else {
    
  }
  fids_ = fids;
  // @@protoc_insertion_point(field_set_allocated:dan.TableScan.fids)
}

// int64 limit = 3;
inline void TableScan::clear_limit() {
  limit_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableScan::_internal_limit() const {
  return limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableScan::limit() const {
  // @@protoc_insertion_point(field_get:dan.TableScan.limit)
  return _internal_limit();
}
inline void TableScan::_internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  limit_ = value;
}
inline void TableScan::set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:dan.TableScan.limit)
}

// -------------------------------------------------------------------

// IndexSearch

// string tname = 1;
inline void IndexSearch::clear_tname() {
  tname_.ClearToEmpty();
}
inline const std::string& IndexSearch::tname() const {
  // @@protoc_insertion_point(field_get:dan.IndexSearch.tname)
  return _internal_tname();
}
inline void IndexSearch::set_tname(const std::string& value) {
  _internal_set_tname(value);
  // @@protoc_insertion_point(field_set:dan.IndexSearch.tname)
}
inline std::string* IndexSearch::mutable_tname() {
  // @@protoc_insertion_point(field_mutable:dan.IndexSearch.tname)
  return _internal_mutable_tname();
}
inline const std::string& IndexSearch::_internal_tname() const {
  return tname_.Get();
}
inline void IndexSearch::_internal_set_tname(const std::string& value) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void IndexSearch::set_tname(std::string&& value) {
  
  tname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.IndexSearch.tname)
}
inline void IndexSearch::set_tname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.IndexSearch.tname)
}
inline void IndexSearch::set_tname(const char* value,
    size_t size) {
  
  tname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.IndexSearch.tname)
}
inline std::string* IndexSearch::_internal_mutable_tname() {
  
  return tname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* IndexSearch::release_tname() {
  // @@protoc_insertion_point(field_release:dan.IndexSearch.tname)
  return tname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IndexSearch::set_allocated_tname(std::string* tname) {
  if (tname != nullptr) {
    
  } else {
    
  }
  tname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.IndexSearch.tname)
}

// int64 fid = 2;
inline void IndexSearch::clear_fid() {
  fid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexSearch::_internal_fid() const {
  return fid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexSearch::fid() const {
  // @@protoc_insertion_point(field_get:dan.IndexSearch.fid)
  return _internal_fid();
}
inline void IndexSearch::_internal_set_fid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  fid_ = value;
}
inline void IndexSearch::set_fid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:dan.IndexSearch.fid)
}

// .dan.Eval val = 3;
inline bool IndexSearch::_internal_has_val() const {
  return this != internal_default_instance() && val_ != nullptr;
}
inline bool IndexSearch::has_val() const {
  return _internal_has_val();
}
inline void IndexSearch::clear_val() {
  if (GetArena() == nullptr && val_ != nullptr) {
    delete val_;
  }
  val_ = nullptr;
}
inline const ::dan::Eval& IndexSearch::_internal_val() const {
  const ::dan::Eval* p = val_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Eval&>(
      ::dan::_Eval_default_instance_);
}
inline const ::dan::Eval& IndexSearch::val() const {
  // @@protoc_insertion_point(field_get:dan.IndexSearch.val)
  return _internal_val();
}
inline void IndexSearch::unsafe_arena_set_allocated_val(
    ::dan::Eval* val) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(val_);
  }
  val_ = val;
  if (val) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.IndexSearch.val)
}
inline ::dan::Eval* IndexSearch::release_val() {
  
  ::dan::Eval* temp = val_;
  val_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Eval* IndexSearch::unsafe_arena_release_val() {
  // @@protoc_insertion_point(field_release:dan.IndexSearch.val)
  
  ::dan::Eval* temp = val_;
  val_ = nullptr;
  return temp;
}
inline ::dan::Eval* IndexSearch::_internal_mutable_val() {
  
  if (val_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Eval>(GetArena());
    val_ = p;
  }
  return val_;
}
inline ::dan::Eval* IndexSearch::mutable_val() {
  // @@protoc_insertion_point(field_mutable:dan.IndexSearch.val)
  return _internal_mutable_val();
}
inline void IndexSearch::set_allocated_val(::dan::Eval* val) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete val_;
  }
  if (val) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(val);
    if (message_arena != submessage_arena) {
      val = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, val, submessage_arena);
    }
    
  } else {
    
  }
  val_ = val;
  // @@protoc_insertion_point(field_set_allocated:dan.IndexSearch.val)
}

// .dan.IntVec fids = 4;
inline bool IndexSearch::_internal_has_fids() const {
  return this != internal_default_instance() && fids_ != nullptr;
}
inline bool IndexSearch::has_fids() const {
  return _internal_has_fids();
}
inline void IndexSearch::clear_fids() {
  if (GetArena() == nullptr && fids_ != nullptr) {
    delete fids_;
  }
  fids_ = nullptr;
}
inline const ::dan::IntVec& IndexSearch::_internal_fids() const {
  const ::dan::IntVec* p = fids_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::IntVec&>(
      ::dan::_IntVec_default_instance_);
}
inline const ::dan::IntVec& IndexSearch::fids() const {
  // @@protoc_insertion_point(field_get:dan.IndexSearch.fids)
  return _internal_fids();
}
inline void IndexSearch::unsafe_arena_set_allocated_fids(
    ::dan::IntVec* fids) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fids_);
  }
  fids_ = fids;
  if (fids) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.IndexSearch.fids)
}
inline ::dan::IntVec* IndexSearch::release_fids() {
  
  ::dan::IntVec* temp = fids_;
  fids_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::IntVec* IndexSearch::unsafe_arena_release_fids() {
  // @@protoc_insertion_point(field_release:dan.IndexSearch.fids)
  
  ::dan::IntVec* temp = fids_;
  fids_ = nullptr;
  return temp;
}
inline ::dan::IntVec* IndexSearch::_internal_mutable_fids() {
  
  if (fids_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::IntVec>(GetArena());
    fids_ = p;
  }
  return fids_;
}
inline ::dan::IntVec* IndexSearch::mutable_fids() {
  // @@protoc_insertion_point(field_mutable:dan.IndexSearch.fids)
  return _internal_mutable_fids();
}
inline void IndexSearch::set_allocated_fids(::dan::IntVec* fids) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fids_;
  }
  if (fids) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fids);
    if (message_arena != submessage_arena) {
      fids = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fids, submessage_arena);
    }
    
  } else {
    
  }
  fids_ = fids;
  // @@protoc_insertion_point(field_set_allocated:dan.IndexSearch.fids)
}

// -------------------------------------------------------------------

// AdjacentList

// string gname = 1;
inline void AdjacentList::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& AdjacentList::gname() const {
  // @@protoc_insertion_point(field_get:dan.AdjacentList.gname)
  return _internal_gname();
}
inline void AdjacentList::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.AdjacentList.gname)
}
inline std::string* AdjacentList::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.AdjacentList.gname)
  return _internal_mutable_gname();
}
inline const std::string& AdjacentList::_internal_gname() const {
  return gname_.Get();
}
inline void AdjacentList::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AdjacentList::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.AdjacentList.gname)
}
inline void AdjacentList::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.AdjacentList.gname)
}
inline void AdjacentList::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.AdjacentList.gname)
}
inline std::string* AdjacentList::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AdjacentList::release_gname() {
  // @@protoc_insertion_point(field_release:dan.AdjacentList.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AdjacentList::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.AdjacentList.gname)
}

// .dan.Eval src = 2;
inline bool AdjacentList::_internal_has_src() const {
  return this != internal_default_instance() && src_ != nullptr;
}
inline bool AdjacentList::has_src() const {
  return _internal_has_src();
}
inline void AdjacentList::clear_src() {
  if (GetArena() == nullptr && src_ != nullptr) {
    delete src_;
  }
  src_ = nullptr;
}
inline const ::dan::Eval& AdjacentList::_internal_src() const {
  const ::dan::Eval* p = src_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Eval&>(
      ::dan::_Eval_default_instance_);
}
inline const ::dan::Eval& AdjacentList::src() const {
  // @@protoc_insertion_point(field_get:dan.AdjacentList.src)
  return _internal_src();
}
inline void AdjacentList::unsafe_arena_set_allocated_src(
    ::dan::Eval* src) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  src_ = src;
  if (src) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.AdjacentList.src)
}
inline ::dan::Eval* AdjacentList::release_src() {
  
  ::dan::Eval* temp = src_;
  src_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Eval* AdjacentList::unsafe_arena_release_src() {
  // @@protoc_insertion_point(field_release:dan.AdjacentList.src)
  
  ::dan::Eval* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::dan::Eval* AdjacentList::_internal_mutable_src() {
  
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Eval>(GetArena());
    src_ = p;
  }
  return src_;
}
inline ::dan::Eval* AdjacentList::mutable_src() {
  // @@protoc_insertion_point(field_mutable:dan.AdjacentList.src)
  return _internal_mutable_src();
}
inline void AdjacentList::set_allocated_src(::dan::Eval* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete src_;
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(src);
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    
  } else {
    
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:dan.AdjacentList.src)
}

// .dan.IntVec fids = 3;
inline bool AdjacentList::_internal_has_fids() const {
  return this != internal_default_instance() && fids_ != nullptr;
}
inline bool AdjacentList::has_fids() const {
  return _internal_has_fids();
}
inline void AdjacentList::clear_fids() {
  if (GetArena() == nullptr && fids_ != nullptr) {
    delete fids_;
  }
  fids_ = nullptr;
}
inline const ::dan::IntVec& AdjacentList::_internal_fids() const {
  const ::dan::IntVec* p = fids_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::IntVec&>(
      ::dan::_IntVec_default_instance_);
}
inline const ::dan::IntVec& AdjacentList::fids() const {
  // @@protoc_insertion_point(field_get:dan.AdjacentList.fids)
  return _internal_fids();
}
inline void AdjacentList::unsafe_arena_set_allocated_fids(
    ::dan::IntVec* fids) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fids_);
  }
  fids_ = fids;
  if (fids) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.AdjacentList.fids)
}
inline ::dan::IntVec* AdjacentList::release_fids() {
  
  ::dan::IntVec* temp = fids_;
  fids_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::IntVec* AdjacentList::unsafe_arena_release_fids() {
  // @@protoc_insertion_point(field_release:dan.AdjacentList.fids)
  
  ::dan::IntVec* temp = fids_;
  fids_ = nullptr;
  return temp;
}
inline ::dan::IntVec* AdjacentList::_internal_mutable_fids() {
  
  if (fids_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::IntVec>(GetArena());
    fids_ = p;
  }
  return fids_;
}
inline ::dan::IntVec* AdjacentList::mutable_fids() {
  // @@protoc_insertion_point(field_mutable:dan.AdjacentList.fids)
  return _internal_mutable_fids();
}
inline void AdjacentList::set_allocated_fids(::dan::IntVec* fids) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fids_;
  }
  if (fids) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fids);
    if (message_arena != submessage_arena) {
      fids = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fids, submessage_arena);
    }
    
  } else {
    
  }
  fids_ = fids;
  // @@protoc_insertion_point(field_set_allocated:dan.AdjacentList.fids)
}

// int32 vpid = 4;
inline void AdjacentList::clear_vpid() {
  vpid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AdjacentList::_internal_vpid() const {
  return vpid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AdjacentList::vpid() const {
  // @@protoc_insertion_point(field_get:dan.AdjacentList.vpid)
  return _internal_vpid();
}
inline void AdjacentList::_internal_set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vpid_ = value;
}
inline void AdjacentList::set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vpid(value);
  // @@protoc_insertion_point(field_set:dan.AdjacentList.vpid)
}

// bool incoming = 5;
inline void AdjacentList::clear_incoming() {
  incoming_ = false;
}
inline bool AdjacentList::_internal_incoming() const {
  return incoming_;
}
inline bool AdjacentList::incoming() const {
  // @@protoc_insertion_point(field_get:dan.AdjacentList.incoming)
  return _internal_incoming();
}
inline void AdjacentList::_internal_set_incoming(bool value) {
  
  incoming_ = value;
}
inline void AdjacentList::set_incoming(bool value) {
  _internal_set_incoming(value);
  // @@protoc_insertion_point(field_set:dan.AdjacentList.incoming)
}

// -------------------------------------------------------------------

// AdjacentListResult

// .dan.Table dests = 1;
inline bool AdjacentListResult::_internal_has_dests() const {
  return this != internal_default_instance() && dests_ != nullptr;
}
inline bool AdjacentListResult::has_dests() const {
  return _internal_has_dests();
}
inline void AdjacentListResult::clear_dests() {
  if (GetArena() == nullptr && dests_ != nullptr) {
    delete dests_;
  }
  dests_ = nullptr;
}
inline const ::dan::Table& AdjacentListResult::_internal_dests() const {
  const ::dan::Table* p = dests_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Table&>(
      ::dan::_Table_default_instance_);
}
inline const ::dan::Table& AdjacentListResult::dests() const {
  // @@protoc_insertion_point(field_get:dan.AdjacentListResult.dests)
  return _internal_dests();
}
inline void AdjacentListResult::unsafe_arena_set_allocated_dests(
    ::dan::Table* dests) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dests_);
  }
  dests_ = dests;
  if (dests) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.AdjacentListResult.dests)
}
inline ::dan::Table* AdjacentListResult::release_dests() {
  
  ::dan::Table* temp = dests_;
  dests_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Table* AdjacentListResult::unsafe_arena_release_dests() {
  // @@protoc_insertion_point(field_release:dan.AdjacentListResult.dests)
  
  ::dan::Table* temp = dests_;
  dests_ = nullptr;
  return temp;
}
inline ::dan::Table* AdjacentListResult::_internal_mutable_dests() {
  
  if (dests_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Table>(GetArena());
    dests_ = p;
  }
  return dests_;
}
inline ::dan::Table* AdjacentListResult::mutable_dests() {
  // @@protoc_insertion_point(field_mutable:dan.AdjacentListResult.dests)
  return _internal_mutable_dests();
}
inline void AdjacentListResult::set_allocated_dests(::dan::Table* dests) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete dests_;
  }
  if (dests) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dests);
    if (message_arena != submessage_arena) {
      dests = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dests, submessage_arena);
    }
    
  } else {
    
  }
  dests_ = dests;
  // @@protoc_insertion_point(field_set_allocated:dan.AdjacentListResult.dests)
}

// .dan.Record eprops = 2;
inline bool AdjacentListResult::_internal_has_eprops() const {
  return this != internal_default_instance() && eprops_ != nullptr;
}
inline bool AdjacentListResult::has_eprops() const {
  return _internal_has_eprops();
}
inline void AdjacentListResult::clear_eprops() {
  if (GetArena() == nullptr && eprops_ != nullptr) {
    delete eprops_;
  }
  eprops_ = nullptr;
}
inline const ::dan::Record& AdjacentListResult::_internal_eprops() const {
  const ::dan::Record* p = eprops_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& AdjacentListResult::eprops() const {
  // @@protoc_insertion_point(field_get:dan.AdjacentListResult.eprops)
  return _internal_eprops();
}
inline void AdjacentListResult::unsafe_arena_set_allocated_eprops(
    ::dan::Record* eprops) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eprops_);
  }
  eprops_ = eprops;
  if (eprops) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.AdjacentListResult.eprops)
}
inline ::dan::Record* AdjacentListResult::release_eprops() {
  
  ::dan::Record* temp = eprops_;
  eprops_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* AdjacentListResult::unsafe_arena_release_eprops() {
  // @@protoc_insertion_point(field_release:dan.AdjacentListResult.eprops)
  
  ::dan::Record* temp = eprops_;
  eprops_ = nullptr;
  return temp;
}
inline ::dan::Record* AdjacentListResult::_internal_mutable_eprops() {
  
  if (eprops_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    eprops_ = p;
  }
  return eprops_;
}
inline ::dan::Record* AdjacentListResult::mutable_eprops() {
  // @@protoc_insertion_point(field_mutable:dan.AdjacentListResult.eprops)
  return _internal_mutable_eprops();
}
inline void AdjacentListResult::set_allocated_eprops(::dan::Record* eprops) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete eprops_;
  }
  if (eprops) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(eprops);
    if (message_arena != submessage_arena) {
      eprops = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eprops, submessage_arena);
    }
    
  } else {
    
  }
  eprops_ = eprops;
  // @@protoc_insertion_point(field_set_allocated:dan.AdjacentListResult.eprops)
}

// .dan.StrVec nodes = 3;
inline bool AdjacentListResult::_internal_has_nodes() const {
  return this != internal_default_instance() && nodes_ != nullptr;
}
inline bool AdjacentListResult::has_nodes() const {
  return _internal_has_nodes();
}
inline void AdjacentListResult::clear_nodes() {
  if (GetArena() == nullptr && nodes_ != nullptr) {
    delete nodes_;
  }
  nodes_ = nullptr;
}
inline const ::dan::StrVec& AdjacentListResult::_internal_nodes() const {
  const ::dan::StrVec* p = nodes_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::StrVec&>(
      ::dan::_StrVec_default_instance_);
}
inline const ::dan::StrVec& AdjacentListResult::nodes() const {
  // @@protoc_insertion_point(field_get:dan.AdjacentListResult.nodes)
  return _internal_nodes();
}
inline void AdjacentListResult::unsafe_arena_set_allocated_nodes(
    ::dan::StrVec* nodes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodes_);
  }
  nodes_ = nodes;
  if (nodes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.AdjacentListResult.nodes)
}
inline ::dan::StrVec* AdjacentListResult::release_nodes() {
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::StrVec* AdjacentListResult::unsafe_arena_release_nodes() {
  // @@protoc_insertion_point(field_release:dan.AdjacentListResult.nodes)
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  return temp;
}
inline ::dan::StrVec* AdjacentListResult::_internal_mutable_nodes() {
  
  if (nodes_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::StrVec>(GetArena());
    nodes_ = p;
  }
  return nodes_;
}
inline ::dan::StrVec* AdjacentListResult::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable:dan.AdjacentListResult.nodes)
  return _internal_mutable_nodes();
}
inline void AdjacentListResult::set_allocated_nodes(::dan::StrVec* nodes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete nodes_;
  }
  if (nodes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(nodes);
    if (message_arena != submessage_arena) {
      nodes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodes, submessage_arena);
    }
    
  } else {
    
  }
  nodes_ = nodes;
  // @@protoc_insertion_point(field_set_allocated:dan.AdjacentListResult.nodes)
}

// -------------------------------------------------------------------

// GetVertex

// string gname = 1;
inline void GetVertex::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& GetVertex::gname() const {
  // @@protoc_insertion_point(field_get:dan.GetVertex.gname)
  return _internal_gname();
}
inline void GetVertex::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.GetVertex.gname)
}
inline std::string* GetVertex::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.GetVertex.gname)
  return _internal_mutable_gname();
}
inline const std::string& GetVertex::_internal_gname() const {
  return gname_.Get();
}
inline void GetVertex::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetVertex::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.GetVertex.gname)
}
inline void GetVertex::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.GetVertex.gname)
}
inline void GetVertex::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.GetVertex.gname)
}
inline std::string* GetVertex::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetVertex::release_gname() {
  // @@protoc_insertion_point(field_release:dan.GetVertex.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetVertex::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.GetVertex.gname)
}

// .dan.Eval vkey = 2;
inline bool GetVertex::_internal_has_vkey() const {
  return this != internal_default_instance() && vkey_ != nullptr;
}
inline bool GetVertex::has_vkey() const {
  return _internal_has_vkey();
}
inline void GetVertex::clear_vkey() {
  if (GetArena() == nullptr && vkey_ != nullptr) {
    delete vkey_;
  }
  vkey_ = nullptr;
}
inline const ::dan::Eval& GetVertex::_internal_vkey() const {
  const ::dan::Eval* p = vkey_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Eval&>(
      ::dan::_Eval_default_instance_);
}
inline const ::dan::Eval& GetVertex::vkey() const {
  // @@protoc_insertion_point(field_get:dan.GetVertex.vkey)
  return _internal_vkey();
}
inline void GetVertex::unsafe_arena_set_allocated_vkey(
    ::dan::Eval* vkey) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vkey_);
  }
  vkey_ = vkey;
  if (vkey) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.GetVertex.vkey)
}
inline ::dan::Eval* GetVertex::release_vkey() {
  
  ::dan::Eval* temp = vkey_;
  vkey_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Eval* GetVertex::unsafe_arena_release_vkey() {
  // @@protoc_insertion_point(field_release:dan.GetVertex.vkey)
  
  ::dan::Eval* temp = vkey_;
  vkey_ = nullptr;
  return temp;
}
inline ::dan::Eval* GetVertex::_internal_mutable_vkey() {
  
  if (vkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Eval>(GetArena());
    vkey_ = p;
  }
  return vkey_;
}
inline ::dan::Eval* GetVertex::mutable_vkey() {
  // @@protoc_insertion_point(field_mutable:dan.GetVertex.vkey)
  return _internal_mutable_vkey();
}
inline void GetVertex::set_allocated_vkey(::dan::Eval* vkey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vkey_;
  }
  if (vkey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vkey);
    if (message_arena != submessage_arena) {
      vkey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vkey, submessage_arena);
    }
    
  } else {
    
  }
  vkey_ = vkey;
  // @@protoc_insertion_point(field_set_allocated:dan.GetVertex.vkey)
}

// int32 vpid = 3;
inline void GetVertex::clear_vpid() {
  vpid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetVertex::_internal_vpid() const {
  return vpid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetVertex::vpid() const {
  // @@protoc_insertion_point(field_get:dan.GetVertex.vpid)
  return _internal_vpid();
}
inline void GetVertex::_internal_set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vpid_ = value;
}
inline void GetVertex::set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vpid(value);
  // @@protoc_insertion_point(field_set:dan.GetVertex.vpid)
}

// int64 vid = 4;
inline void GetVertex::clear_vid() {
  vid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetVertex::_internal_vid() const {
  return vid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetVertex::vid() const {
  // @@protoc_insertion_point(field_get:dan.GetVertex.vid)
  return _internal_vid();
}
inline void GetVertex::_internal_set_vid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  vid_ = value;
}
inline void GetVertex::set_vid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_vid(value);
  // @@protoc_insertion_point(field_set:dan.GetVertex.vid)
}

// .dan.IntVec fids = 5;
inline bool GetVertex::_internal_has_fids() const {
  return this != internal_default_instance() && fids_ != nullptr;
}
inline bool GetVertex::has_fids() const {
  return _internal_has_fids();
}
inline void GetVertex::clear_fids() {
  if (GetArena() == nullptr && fids_ != nullptr) {
    delete fids_;
  }
  fids_ = nullptr;
}
inline const ::dan::IntVec& GetVertex::_internal_fids() const {
  const ::dan::IntVec* p = fids_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::IntVec&>(
      ::dan::_IntVec_default_instance_);
}
inline const ::dan::IntVec& GetVertex::fids() const {
  // @@protoc_insertion_point(field_get:dan.GetVertex.fids)
  return _internal_fids();
}
inline void GetVertex::unsafe_arena_set_allocated_fids(
    ::dan::IntVec* fids) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fids_);
  }
  fids_ = fids;
  if (fids) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.GetVertex.fids)
}
inline ::dan::IntVec* GetVertex::release_fids() {
  
  ::dan::IntVec* temp = fids_;
  fids_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::IntVec* GetVertex::unsafe_arena_release_fids() {
  // @@protoc_insertion_point(field_release:dan.GetVertex.fids)
  
  ::dan::IntVec* temp = fids_;
  fids_ = nullptr;
  return temp;
}
inline ::dan::IntVec* GetVertex::_internal_mutable_fids() {
  
  if (fids_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::IntVec>(GetArena());
    fids_ = p;
  }
  return fids_;
}
inline ::dan::IntVec* GetVertex::mutable_fids() {
  // @@protoc_insertion_point(field_mutable:dan.GetVertex.fids)
  return _internal_mutable_fids();
}
inline void GetVertex::set_allocated_fids(::dan::IntVec* fids) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fids_;
  }
  if (fids) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fids);
    if (message_arena != submessage_arena) {
      fids = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fids, submessage_arena);
    }
    
  } else {
    
  }
  fids_ = fids;
  // @@protoc_insertion_point(field_set_allocated:dan.GetVertex.fids)
}

// -------------------------------------------------------------------

// VertexList

// .dan.Record vkey = 1;
inline bool VertexList::_internal_has_vkey() const {
  return this != internal_default_instance() && vkey_ != nullptr;
}
inline bool VertexList::has_vkey() const {
  return _internal_has_vkey();
}
inline void VertexList::clear_vkey() {
  if (GetArena() == nullptr && vkey_ != nullptr) {
    delete vkey_;
  }
  vkey_ = nullptr;
}
inline const ::dan::Record& VertexList::_internal_vkey() const {
  const ::dan::Record* p = vkey_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& VertexList::vkey() const {
  // @@protoc_insertion_point(field_get:dan.VertexList.vkey)
  return _internal_vkey();
}
inline void VertexList::unsafe_arena_set_allocated_vkey(
    ::dan::Record* vkey) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vkey_);
  }
  vkey_ = vkey;
  if (vkey) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.VertexList.vkey)
}
inline ::dan::Record* VertexList::release_vkey() {
  
  ::dan::Record* temp = vkey_;
  vkey_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* VertexList::unsafe_arena_release_vkey() {
  // @@protoc_insertion_point(field_release:dan.VertexList.vkey)
  
  ::dan::Record* temp = vkey_;
  vkey_ = nullptr;
  return temp;
}
inline ::dan::Record* VertexList::_internal_mutable_vkey() {
  
  if (vkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    vkey_ = p;
  }
  return vkey_;
}
inline ::dan::Record* VertexList::mutable_vkey() {
  // @@protoc_insertion_point(field_mutable:dan.VertexList.vkey)
  return _internal_mutable_vkey();
}
inline void VertexList::set_allocated_vkey(::dan::Record* vkey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vkey_;
  }
  if (vkey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vkey);
    if (message_arena != submessage_arena) {
      vkey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vkey, submessage_arena);
    }
    
  } else {
    
  }
  vkey_ = vkey;
  // @@protoc_insertion_point(field_set_allocated:dan.VertexList.vkey)
}

// .dan.IntVec vpid = 2;
inline bool VertexList::_internal_has_vpid() const {
  return this != internal_default_instance() && vpid_ != nullptr;
}
inline bool VertexList::has_vpid() const {
  return _internal_has_vpid();
}
inline void VertexList::clear_vpid() {
  if (GetArena() == nullptr && vpid_ != nullptr) {
    delete vpid_;
  }
  vpid_ = nullptr;
}
inline const ::dan::IntVec& VertexList::_internal_vpid() const {
  const ::dan::IntVec* p = vpid_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::IntVec&>(
      ::dan::_IntVec_default_instance_);
}
inline const ::dan::IntVec& VertexList::vpid() const {
  // @@protoc_insertion_point(field_get:dan.VertexList.vpid)
  return _internal_vpid();
}
inline void VertexList::unsafe_arena_set_allocated_vpid(
    ::dan::IntVec* vpid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vpid_);
  }
  vpid_ = vpid;
  if (vpid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.VertexList.vpid)
}
inline ::dan::IntVec* VertexList::release_vpid() {
  
  ::dan::IntVec* temp = vpid_;
  vpid_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::IntVec* VertexList::unsafe_arena_release_vpid() {
  // @@protoc_insertion_point(field_release:dan.VertexList.vpid)
  
  ::dan::IntVec* temp = vpid_;
  vpid_ = nullptr;
  return temp;
}
inline ::dan::IntVec* VertexList::_internal_mutable_vpid() {
  
  if (vpid_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::IntVec>(GetArena());
    vpid_ = p;
  }
  return vpid_;
}
inline ::dan::IntVec* VertexList::mutable_vpid() {
  // @@protoc_insertion_point(field_mutable:dan.VertexList.vpid)
  return _internal_mutable_vpid();
}
inline void VertexList::set_allocated_vpid(::dan::IntVec* vpid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vpid_;
  }
  if (vpid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vpid);
    if (message_arena != submessage_arena) {
      vpid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vpid, submessage_arena);
    }
    
  } else {
    
  }
  vpid_ = vpid;
  // @@protoc_insertion_point(field_set_allocated:dan.VertexList.vpid)
}

// .dan.Table vprop = 3;
inline bool VertexList::_internal_has_vprop() const {
  return this != internal_default_instance() && vprop_ != nullptr;
}
inline bool VertexList::has_vprop() const {
  return _internal_has_vprop();
}
inline void VertexList::clear_vprop() {
  if (GetArena() == nullptr && vprop_ != nullptr) {
    delete vprop_;
  }
  vprop_ = nullptr;
}
inline const ::dan::Table& VertexList::_internal_vprop() const {
  const ::dan::Table* p = vprop_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Table&>(
      ::dan::_Table_default_instance_);
}
inline const ::dan::Table& VertexList::vprop() const {
  // @@protoc_insertion_point(field_get:dan.VertexList.vprop)
  return _internal_vprop();
}
inline void VertexList::unsafe_arena_set_allocated_vprop(
    ::dan::Table* vprop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vprop_);
  }
  vprop_ = vprop;
  if (vprop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.VertexList.vprop)
}
inline ::dan::Table* VertexList::release_vprop() {
  
  ::dan::Table* temp = vprop_;
  vprop_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Table* VertexList::unsafe_arena_release_vprop() {
  // @@protoc_insertion_point(field_release:dan.VertexList.vprop)
  
  ::dan::Table* temp = vprop_;
  vprop_ = nullptr;
  return temp;
}
inline ::dan::Table* VertexList::_internal_mutable_vprop() {
  
  if (vprop_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Table>(GetArena());
    vprop_ = p;
  }
  return vprop_;
}
inline ::dan::Table* VertexList::mutable_vprop() {
  // @@protoc_insertion_point(field_mutable:dan.VertexList.vprop)
  return _internal_mutable_vprop();
}
inline void VertexList::set_allocated_vprop(::dan::Table* vprop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vprop_;
  }
  if (vprop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vprop);
    if (message_arena != submessage_arena) {
      vprop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vprop, submessage_arena);
    }
    
  } else {
    
  }
  vprop_ = vprop;
  // @@protoc_insertion_point(field_set_allocated:dan.VertexList.vprop)
}

// -------------------------------------------------------------------

// EdgeList

// .dan.Record src = 1;
inline bool EdgeList::_internal_has_src() const {
  return this != internal_default_instance() && src_ != nullptr;
}
inline bool EdgeList::has_src() const {
  return _internal_has_src();
}
inline void EdgeList::clear_src() {
  if (GetArena() == nullptr && src_ != nullptr) {
    delete src_;
  }
  src_ = nullptr;
}
inline const ::dan::Record& EdgeList::_internal_src() const {
  const ::dan::Record* p = src_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& EdgeList::src() const {
  // @@protoc_insertion_point(field_get:dan.EdgeList.src)
  return _internal_src();
}
inline void EdgeList::unsafe_arena_set_allocated_src(
    ::dan::Record* src) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  src_ = src;
  if (src) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.EdgeList.src)
}
inline ::dan::Record* EdgeList::release_src() {
  
  ::dan::Record* temp = src_;
  src_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* EdgeList::unsafe_arena_release_src() {
  // @@protoc_insertion_point(field_release:dan.EdgeList.src)
  
  ::dan::Record* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::dan::Record* EdgeList::_internal_mutable_src() {
  
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    src_ = p;
  }
  return src_;
}
inline ::dan::Record* EdgeList::mutable_src() {
  // @@protoc_insertion_point(field_mutable:dan.EdgeList.src)
  return _internal_mutable_src();
}
inline void EdgeList::set_allocated_src(::dan::Record* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete src_;
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(src);
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    
  } else {
    
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:dan.EdgeList.src)
}

// .dan.Record dst = 2;
inline bool EdgeList::_internal_has_dst() const {
  return this != internal_default_instance() && dst_ != nullptr;
}
inline bool EdgeList::has_dst() const {
  return _internal_has_dst();
}
inline void EdgeList::clear_dst() {
  if (GetArena() == nullptr && dst_ != nullptr) {
    delete dst_;
  }
  dst_ = nullptr;
}
inline const ::dan::Record& EdgeList::_internal_dst() const {
  const ::dan::Record* p = dst_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Record&>(
      ::dan::_Record_default_instance_);
}
inline const ::dan::Record& EdgeList::dst() const {
  // @@protoc_insertion_point(field_get:dan.EdgeList.dst)
  return _internal_dst();
}
inline void EdgeList::unsafe_arena_set_allocated_dst(
    ::dan::Record* dst) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dst_);
  }
  dst_ = dst;
  if (dst) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.EdgeList.dst)
}
inline ::dan::Record* EdgeList::release_dst() {
  
  ::dan::Record* temp = dst_;
  dst_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Record* EdgeList::unsafe_arena_release_dst() {
  // @@protoc_insertion_point(field_release:dan.EdgeList.dst)
  
  ::dan::Record* temp = dst_;
  dst_ = nullptr;
  return temp;
}
inline ::dan::Record* EdgeList::_internal_mutable_dst() {
  
  if (dst_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Record>(GetArena());
    dst_ = p;
  }
  return dst_;
}
inline ::dan::Record* EdgeList::mutable_dst() {
  // @@protoc_insertion_point(field_mutable:dan.EdgeList.dst)
  return _internal_mutable_dst();
}
inline void EdgeList::set_allocated_dst(::dan::Record* dst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete dst_;
  }
  if (dst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dst);
    if (message_arena != submessage_arena) {
      dst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst, submessage_arena);
    }
    
  } else {
    
  }
  dst_ = dst;
  // @@protoc_insertion_point(field_set_allocated:dan.EdgeList.dst)
}

// -------------------------------------------------------------------

// RemoteTask

// bytes func = 1;
inline void RemoteTask::clear_func() {
  func_.ClearToEmpty();
}
inline const std::string& RemoteTask::func() const {
  // @@protoc_insertion_point(field_get:dan.RemoteTask.func)
  return _internal_func();
}
inline void RemoteTask::set_func(const std::string& value) {
  _internal_set_func(value);
  // @@protoc_insertion_point(field_set:dan.RemoteTask.func)
}
inline std::string* RemoteTask::mutable_func() {
  // @@protoc_insertion_point(field_mutable:dan.RemoteTask.func)
  return _internal_mutable_func();
}
inline const std::string& RemoteTask::_internal_func() const {
  return func_.Get();
}
inline void RemoteTask::_internal_set_func(const std::string& value) {
  
  func_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RemoteTask::set_func(std::string&& value) {
  
  func_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.RemoteTask.func)
}
inline void RemoteTask::set_func(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  func_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.RemoteTask.func)
}
inline void RemoteTask::set_func(const void* value,
    size_t size) {
  
  func_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.RemoteTask.func)
}
inline std::string* RemoteTask::_internal_mutable_func() {
  
  return func_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RemoteTask::release_func() {
  // @@protoc_insertion_point(field_release:dan.RemoteTask.func)
  return func_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteTask::set_allocated_func(std::string* func) {
  if (func != nullptr) {
    
  } else {
    
  }
  func_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), func,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.RemoteTask.func)
}

// bytes args = 2;
inline void RemoteTask::clear_args() {
  args_.ClearToEmpty();
}
inline const std::string& RemoteTask::args() const {
  // @@protoc_insertion_point(field_get:dan.RemoteTask.args)
  return _internal_args();
}
inline void RemoteTask::set_args(const std::string& value) {
  _internal_set_args(value);
  // @@protoc_insertion_point(field_set:dan.RemoteTask.args)
}
inline std::string* RemoteTask::mutable_args() {
  // @@protoc_insertion_point(field_mutable:dan.RemoteTask.args)
  return _internal_mutable_args();
}
inline const std::string& RemoteTask::_internal_args() const {
  return args_.Get();
}
inline void RemoteTask::_internal_set_args(const std::string& value) {
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RemoteTask::set_args(std::string&& value) {
  
  args_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.RemoteTask.args)
}
inline void RemoteTask::set_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.RemoteTask.args)
}
inline void RemoteTask::set_args(const void* value,
    size_t size) {
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.RemoteTask.args)
}
inline std::string* RemoteTask::_internal_mutable_args() {
  
  return args_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RemoteTask::release_args() {
  // @@protoc_insertion_point(field_release:dan.RemoteTask.args)
  return args_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteTask::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  args_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), args,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.RemoteTask.args)
}

// bytes kargs = 3;
inline void RemoteTask::clear_kargs() {
  kargs_.ClearToEmpty();
}
inline const std::string& RemoteTask::kargs() const {
  // @@protoc_insertion_point(field_get:dan.RemoteTask.kargs)
  return _internal_kargs();
}
inline void RemoteTask::set_kargs(const std::string& value) {
  _internal_set_kargs(value);
  // @@protoc_insertion_point(field_set:dan.RemoteTask.kargs)
}
inline std::string* RemoteTask::mutable_kargs() {
  // @@protoc_insertion_point(field_mutable:dan.RemoteTask.kargs)
  return _internal_mutable_kargs();
}
inline const std::string& RemoteTask::_internal_kargs() const {
  return kargs_.Get();
}
inline void RemoteTask::_internal_set_kargs(const std::string& value) {
  
  kargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RemoteTask::set_kargs(std::string&& value) {
  
  kargs_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.RemoteTask.kargs)
}
inline void RemoteTask::set_kargs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  kargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.RemoteTask.kargs)
}
inline void RemoteTask::set_kargs(const void* value,
    size_t size) {
  
  kargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.RemoteTask.kargs)
}
inline std::string* RemoteTask::_internal_mutable_kargs() {
  
  return kargs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RemoteTask::release_kargs() {
  // @@protoc_insertion_point(field_release:dan.RemoteTask.kargs)
  return kargs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteTask::set_allocated_kargs(std::string* kargs) {
  if (kargs != nullptr) {
    
  } else {
    
  }
  kargs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kargs,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.RemoteTask.kargs)
}

// bool immediate_return = 4;
inline void RemoteTask::clear_immediate_return() {
  immediate_return_ = false;
}
inline bool RemoteTask::_internal_immediate_return() const {
  return immediate_return_;
}
inline bool RemoteTask::immediate_return() const {
  // @@protoc_insertion_point(field_get:dan.RemoteTask.immediate_return)
  return _internal_immediate_return();
}
inline void RemoteTask::_internal_set_immediate_return(bool value) {
  
  immediate_return_ = value;
}
inline void RemoteTask::set_immediate_return(bool value) {
  _internal_set_immediate_return(value);
  // @@protoc_insertion_point(field_set:dan.RemoteTask.immediate_return)
}

// -------------------------------------------------------------------

// RemoteResult

// bytes results = 1;
inline void RemoteResult::clear_results() {
  results_.ClearToEmpty();
}
inline const std::string& RemoteResult::results() const {
  // @@protoc_insertion_point(field_get:dan.RemoteResult.results)
  return _internal_results();
}
inline void RemoteResult::set_results(const std::string& value) {
  _internal_set_results(value);
  // @@protoc_insertion_point(field_set:dan.RemoteResult.results)
}
inline std::string* RemoteResult::mutable_results() {
  // @@protoc_insertion_point(field_mutable:dan.RemoteResult.results)
  return _internal_mutable_results();
}
inline const std::string& RemoteResult::_internal_results() const {
  return results_.Get();
}
inline void RemoteResult::_internal_set_results(const std::string& value) {
  
  results_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RemoteResult::set_results(std::string&& value) {
  
  results_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.RemoteResult.results)
}
inline void RemoteResult::set_results(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  results_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.RemoteResult.results)
}
inline void RemoteResult::set_results(const void* value,
    size_t size) {
  
  results_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.RemoteResult.results)
}
inline std::string* RemoteResult::_internal_mutable_results() {
  
  return results_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RemoteResult::release_results() {
  // @@protoc_insertion_point(field_release:dan.RemoteResult.results)
  return results_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteResult::set_allocated_results(std::string* results) {
  if (results != nullptr) {
    
  } else {
    
  }
  results_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), results,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.RemoteResult.results)
}

// -------------------------------------------------------------------

// RemoteObject

// bytes cls = 1;
inline void RemoteObject::clear_cls() {
  cls_.ClearToEmpty();
}
inline const std::string& RemoteObject::cls() const {
  // @@protoc_insertion_point(field_get:dan.RemoteObject.cls)
  return _internal_cls();
}
inline void RemoteObject::set_cls(const std::string& value) {
  _internal_set_cls(value);
  // @@protoc_insertion_point(field_set:dan.RemoteObject.cls)
}
inline std::string* RemoteObject::mutable_cls() {
  // @@protoc_insertion_point(field_mutable:dan.RemoteObject.cls)
  return _internal_mutable_cls();
}
inline const std::string& RemoteObject::_internal_cls() const {
  return cls_.Get();
}
inline void RemoteObject::_internal_set_cls(const std::string& value) {
  
  cls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RemoteObject::set_cls(std::string&& value) {
  
  cls_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.RemoteObject.cls)
}
inline void RemoteObject::set_cls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.RemoteObject.cls)
}
inline void RemoteObject::set_cls(const void* value,
    size_t size) {
  
  cls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.RemoteObject.cls)
}
inline std::string* RemoteObject::_internal_mutable_cls() {
  
  return cls_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RemoteObject::release_cls() {
  // @@protoc_insertion_point(field_release:dan.RemoteObject.cls)
  return cls_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteObject::set_allocated_cls(std::string* cls) {
  if (cls != nullptr) {
    
  } else {
    
  }
  cls_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cls,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.RemoteObject.cls)
}

// bytes args = 2;
inline void RemoteObject::clear_args() {
  args_.ClearToEmpty();
}
inline const std::string& RemoteObject::args() const {
  // @@protoc_insertion_point(field_get:dan.RemoteObject.args)
  return _internal_args();
}
inline void RemoteObject::set_args(const std::string& value) {
  _internal_set_args(value);
  // @@protoc_insertion_point(field_set:dan.RemoteObject.args)
}
inline std::string* RemoteObject::mutable_args() {
  // @@protoc_insertion_point(field_mutable:dan.RemoteObject.args)
  return _internal_mutable_args();
}
inline const std::string& RemoteObject::_internal_args() const {
  return args_.Get();
}
inline void RemoteObject::_internal_set_args(const std::string& value) {
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RemoteObject::set_args(std::string&& value) {
  
  args_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.RemoteObject.args)
}
inline void RemoteObject::set_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.RemoteObject.args)
}
inline void RemoteObject::set_args(const void* value,
    size_t size) {
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.RemoteObject.args)
}
inline std::string* RemoteObject::_internal_mutable_args() {
  
  return args_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RemoteObject::release_args() {
  // @@protoc_insertion_point(field_release:dan.RemoteObject.args)
  return args_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteObject::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  args_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), args,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.RemoteObject.args)
}

// bytes kargs = 3;
inline void RemoteObject::clear_kargs() {
  kargs_.ClearToEmpty();
}
inline const std::string& RemoteObject::kargs() const {
  // @@protoc_insertion_point(field_get:dan.RemoteObject.kargs)
  return _internal_kargs();
}
inline void RemoteObject::set_kargs(const std::string& value) {
  _internal_set_kargs(value);
  // @@protoc_insertion_point(field_set:dan.RemoteObject.kargs)
}
inline std::string* RemoteObject::mutable_kargs() {
  // @@protoc_insertion_point(field_mutable:dan.RemoteObject.kargs)
  return _internal_mutable_kargs();
}
inline const std::string& RemoteObject::_internal_kargs() const {
  return kargs_.Get();
}
inline void RemoteObject::_internal_set_kargs(const std::string& value) {
  
  kargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RemoteObject::set_kargs(std::string&& value) {
  
  kargs_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.RemoteObject.kargs)
}
inline void RemoteObject::set_kargs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  kargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.RemoteObject.kargs)
}
inline void RemoteObject::set_kargs(const void* value,
    size_t size) {
  
  kargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.RemoteObject.kargs)
}
inline std::string* RemoteObject::_internal_mutable_kargs() {
  
  return kargs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RemoteObject::release_kargs() {
  // @@protoc_insertion_point(field_release:dan.RemoteObject.kargs)
  return kargs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteObject::set_allocated_kargs(std::string* kargs) {
  if (kargs != nullptr) {
    
  } else {
    
  }
  kargs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kargs,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.RemoteObject.kargs)
}

// -------------------------------------------------------------------

// RemoteTaskResult

// int64 object_id = 1;
inline void RemoteTaskResult::clear_object_id() {
  object_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoteTaskResult::_internal_object_id() const {
  return object_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoteTaskResult::object_id() const {
  // @@protoc_insertion_point(field_get:dan.RemoteTaskResult.object_id)
  return _internal_object_id();
}
inline void RemoteTaskResult::_internal_set_object_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  object_id_ = value;
}
inline void RemoteTaskResult::set_object_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:dan.RemoteTaskResult.object_id)
}

// -------------------------------------------------------------------

// RemoteObjectTask

// int64 object_id = 1;
inline void RemoteObjectTask::clear_object_id() {
  object_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoteObjectTask::_internal_object_id() const {
  return object_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoteObjectTask::object_id() const {
  // @@protoc_insertion_point(field_get:dan.RemoteObjectTask.object_id)
  return _internal_object_id();
}
inline void RemoteObjectTask::_internal_set_object_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  object_id_ = value;
}
inline void RemoteObjectTask::set_object_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:dan.RemoteObjectTask.object_id)
}

// string fname = 2;
inline void RemoteObjectTask::clear_fname() {
  fname_.ClearToEmpty();
}
inline const std::string& RemoteObjectTask::fname() const {
  // @@protoc_insertion_point(field_get:dan.RemoteObjectTask.fname)
  return _internal_fname();
}
inline void RemoteObjectTask::set_fname(const std::string& value) {
  _internal_set_fname(value);
  // @@protoc_insertion_point(field_set:dan.RemoteObjectTask.fname)
}
inline std::string* RemoteObjectTask::mutable_fname() {
  // @@protoc_insertion_point(field_mutable:dan.RemoteObjectTask.fname)
  return _internal_mutable_fname();
}
inline const std::string& RemoteObjectTask::_internal_fname() const {
  return fname_.Get();
}
inline void RemoteObjectTask::_internal_set_fname(const std::string& value) {
  
  fname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RemoteObjectTask::set_fname(std::string&& value) {
  
  fname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.RemoteObjectTask.fname)
}
inline void RemoteObjectTask::set_fname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.RemoteObjectTask.fname)
}
inline void RemoteObjectTask::set_fname(const char* value,
    size_t size) {
  
  fname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.RemoteObjectTask.fname)
}
inline std::string* RemoteObjectTask::_internal_mutable_fname() {
  
  return fname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RemoteObjectTask::release_fname() {
  // @@protoc_insertion_point(field_release:dan.RemoteObjectTask.fname)
  return fname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteObjectTask::set_allocated_fname(std::string* fname) {
  if (fname != nullptr) {
    
  } else {
    
  }
  fname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.RemoteObjectTask.fname)
}

// bytes args = 3;
inline void RemoteObjectTask::clear_args() {
  args_.ClearToEmpty();
}
inline const std::string& RemoteObjectTask::args() const {
  // @@protoc_insertion_point(field_get:dan.RemoteObjectTask.args)
  return _internal_args();
}
inline void RemoteObjectTask::set_args(const std::string& value) {
  _internal_set_args(value);
  // @@protoc_insertion_point(field_set:dan.RemoteObjectTask.args)
}
inline std::string* RemoteObjectTask::mutable_args() {
  // @@protoc_insertion_point(field_mutable:dan.RemoteObjectTask.args)
  return _internal_mutable_args();
}
inline const std::string& RemoteObjectTask::_internal_args() const {
  return args_.Get();
}
inline void RemoteObjectTask::_internal_set_args(const std::string& value) {
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RemoteObjectTask::set_args(std::string&& value) {
  
  args_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.RemoteObjectTask.args)
}
inline void RemoteObjectTask::set_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.RemoteObjectTask.args)
}
inline void RemoteObjectTask::set_args(const void* value,
    size_t size) {
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.RemoteObjectTask.args)
}
inline std::string* RemoteObjectTask::_internal_mutable_args() {
  
  return args_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RemoteObjectTask::release_args() {
  // @@protoc_insertion_point(field_release:dan.RemoteObjectTask.args)
  return args_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteObjectTask::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  args_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), args,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.RemoteObjectTask.args)
}

// bytes kargs = 4;
inline void RemoteObjectTask::clear_kargs() {
  kargs_.ClearToEmpty();
}
inline const std::string& RemoteObjectTask::kargs() const {
  // @@protoc_insertion_point(field_get:dan.RemoteObjectTask.kargs)
  return _internal_kargs();
}
inline void RemoteObjectTask::set_kargs(const std::string& value) {
  _internal_set_kargs(value);
  // @@protoc_insertion_point(field_set:dan.RemoteObjectTask.kargs)
}
inline std::string* RemoteObjectTask::mutable_kargs() {
  // @@protoc_insertion_point(field_mutable:dan.RemoteObjectTask.kargs)
  return _internal_mutable_kargs();
}
inline const std::string& RemoteObjectTask::_internal_kargs() const {
  return kargs_.Get();
}
inline void RemoteObjectTask::_internal_set_kargs(const std::string& value) {
  
  kargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RemoteObjectTask::set_kargs(std::string&& value) {
  
  kargs_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.RemoteObjectTask.kargs)
}
inline void RemoteObjectTask::set_kargs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  kargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.RemoteObjectTask.kargs)
}
inline void RemoteObjectTask::set_kargs(const void* value,
    size_t size) {
  
  kargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.RemoteObjectTask.kargs)
}
inline std::string* RemoteObjectTask::_internal_mutable_kargs() {
  
  return kargs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RemoteObjectTask::release_kargs() {
  // @@protoc_insertion_point(field_release:dan.RemoteObjectTask.kargs)
  return kargs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteObjectTask::set_allocated_kargs(std::string* kargs) {
  if (kargs != nullptr) {
    
  } else {
    
  }
  kargs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kargs,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.RemoteObjectTask.kargs)
}

// bool immediate_return = 5;
inline void RemoteObjectTask::clear_immediate_return() {
  immediate_return_ = false;
}
inline bool RemoteObjectTask::_internal_immediate_return() const {
  return immediate_return_;
}
inline bool RemoteObjectTask::immediate_return() const {
  // @@protoc_insertion_point(field_get:dan.RemoteObjectTask.immediate_return)
  return _internal_immediate_return();
}
inline void RemoteObjectTask::_internal_set_immediate_return(bool value) {
  
  immediate_return_ = value;
}
inline void RemoteObjectTask::set_immediate_return(bool value) {
  _internal_set_immediate_return(value);
  // @@protoc_insertion_point(field_set:dan.RemoteObjectTask.immediate_return)
}

// -------------------------------------------------------------------

// LoadGraphFromFolder

// string folder = 1;
inline void LoadGraphFromFolder::clear_folder() {
  folder_.ClearToEmpty();
}
inline const std::string& LoadGraphFromFolder::folder() const {
  // @@protoc_insertion_point(field_get:dan.LoadGraphFromFolder.folder)
  return _internal_folder();
}
inline void LoadGraphFromFolder::set_folder(const std::string& value) {
  _internal_set_folder(value);
  // @@protoc_insertion_point(field_set:dan.LoadGraphFromFolder.folder)
}
inline std::string* LoadGraphFromFolder::mutable_folder() {
  // @@protoc_insertion_point(field_mutable:dan.LoadGraphFromFolder.folder)
  return _internal_mutable_folder();
}
inline const std::string& LoadGraphFromFolder::_internal_folder() const {
  return folder_.Get();
}
inline void LoadGraphFromFolder::_internal_set_folder(const std::string& value) {
  
  folder_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadGraphFromFolder::set_folder(std::string&& value) {
  
  folder_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.LoadGraphFromFolder.folder)
}
inline void LoadGraphFromFolder::set_folder(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  folder_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.LoadGraphFromFolder.folder)
}
inline void LoadGraphFromFolder::set_folder(const char* value,
    size_t size) {
  
  folder_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.LoadGraphFromFolder.folder)
}
inline std::string* LoadGraphFromFolder::_internal_mutable_folder() {
  
  return folder_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadGraphFromFolder::release_folder() {
  // @@protoc_insertion_point(field_release:dan.LoadGraphFromFolder.folder)
  return folder_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadGraphFromFolder::set_allocated_folder(std::string* folder) {
  if (folder != nullptr) {
    
  } else {
    
  }
  folder_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), folder,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.LoadGraphFromFolder.folder)
}

// string gname = 2;
inline void LoadGraphFromFolder::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& LoadGraphFromFolder::gname() const {
  // @@protoc_insertion_point(field_get:dan.LoadGraphFromFolder.gname)
  return _internal_gname();
}
inline void LoadGraphFromFolder::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.LoadGraphFromFolder.gname)
}
inline std::string* LoadGraphFromFolder::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.LoadGraphFromFolder.gname)
  return _internal_mutable_gname();
}
inline const std::string& LoadGraphFromFolder::_internal_gname() const {
  return gname_.Get();
}
inline void LoadGraphFromFolder::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadGraphFromFolder::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.LoadGraphFromFolder.gname)
}
inline void LoadGraphFromFolder::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.LoadGraphFromFolder.gname)
}
inline void LoadGraphFromFolder::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.LoadGraphFromFolder.gname)
}
inline std::string* LoadGraphFromFolder::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadGraphFromFolder::release_gname() {
  // @@protoc_insertion_point(field_release:dan.LoadGraphFromFolder.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadGraphFromFolder::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.LoadGraphFromFolder.gname)
}

// repeated .dan.Field eschema = 3;
inline int LoadGraphFromFolder::_internal_eschema_size() const {
  return eschema_.size();
}
inline int LoadGraphFromFolder::eschema_size() const {
  return _internal_eschema_size();
}
inline void LoadGraphFromFolder::clear_eschema() {
  eschema_.Clear();
}
inline ::dan::Field* LoadGraphFromFolder::mutable_eschema(int index) {
  // @@protoc_insertion_point(field_mutable:dan.LoadGraphFromFolder.eschema)
  return eschema_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >*
LoadGraphFromFolder::mutable_eschema() {
  // @@protoc_insertion_point(field_mutable_list:dan.LoadGraphFromFolder.eschema)
  return &eschema_;
}
inline const ::dan::Field& LoadGraphFromFolder::_internal_eschema(int index) const {
  return eschema_.Get(index);
}
inline const ::dan::Field& LoadGraphFromFolder::eschema(int index) const {
  // @@protoc_insertion_point(field_get:dan.LoadGraphFromFolder.eschema)
  return _internal_eschema(index);
}
inline ::dan::Field* LoadGraphFromFolder::_internal_add_eschema() {
  return eschema_.Add();
}
inline ::dan::Field* LoadGraphFromFolder::add_eschema() {
  // @@protoc_insertion_point(field_add:dan.LoadGraphFromFolder.eschema)
  return _internal_add_eschema();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dan::Field >&
LoadGraphFromFolder::eschema() const {
  // @@protoc_insertion_point(field_list:dan.LoadGraphFromFolder.eschema)
  return eschema_;
}

// string vptype = 4;
inline void LoadGraphFromFolder::clear_vptype() {
  vptype_.ClearToEmpty();
}
inline const std::string& LoadGraphFromFolder::vptype() const {
  // @@protoc_insertion_point(field_get:dan.LoadGraphFromFolder.vptype)
  return _internal_vptype();
}
inline void LoadGraphFromFolder::set_vptype(const std::string& value) {
  _internal_set_vptype(value);
  // @@protoc_insertion_point(field_set:dan.LoadGraphFromFolder.vptype)
}
inline std::string* LoadGraphFromFolder::mutable_vptype() {
  // @@protoc_insertion_point(field_mutable:dan.LoadGraphFromFolder.vptype)
  return _internal_mutable_vptype();
}
inline const std::string& LoadGraphFromFolder::_internal_vptype() const {
  return vptype_.Get();
}
inline void LoadGraphFromFolder::_internal_set_vptype(const std::string& value) {
  
  vptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadGraphFromFolder::set_vptype(std::string&& value) {
  
  vptype_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.LoadGraphFromFolder.vptype)
}
inline void LoadGraphFromFolder::set_vptype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.LoadGraphFromFolder.vptype)
}
inline void LoadGraphFromFolder::set_vptype(const char* value,
    size_t size) {
  
  vptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.LoadGraphFromFolder.vptype)
}
inline std::string* LoadGraphFromFolder::_internal_mutable_vptype() {
  
  return vptype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadGraphFromFolder::release_vptype() {
  // @@protoc_insertion_point(field_release:dan.LoadGraphFromFolder.vptype)
  return vptype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadGraphFromFolder::set_allocated_vptype(std::string* vptype) {
  if (vptype != nullptr) {
    
  } else {
    
  }
  vptype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vptype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.LoadGraphFromFolder.vptype)
}

// string eptype = 5;
inline void LoadGraphFromFolder::clear_eptype() {
  eptype_.ClearToEmpty();
}
inline const std::string& LoadGraphFromFolder::eptype() const {
  // @@protoc_insertion_point(field_get:dan.LoadGraphFromFolder.eptype)
  return _internal_eptype();
}
inline void LoadGraphFromFolder::set_eptype(const std::string& value) {
  _internal_set_eptype(value);
  // @@protoc_insertion_point(field_set:dan.LoadGraphFromFolder.eptype)
}
inline std::string* LoadGraphFromFolder::mutable_eptype() {
  // @@protoc_insertion_point(field_mutable:dan.LoadGraphFromFolder.eptype)
  return _internal_mutable_eptype();
}
inline const std::string& LoadGraphFromFolder::_internal_eptype() const {
  return eptype_.Get();
}
inline void LoadGraphFromFolder::_internal_set_eptype(const std::string& value) {
  
  eptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadGraphFromFolder::set_eptype(std::string&& value) {
  
  eptype_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.LoadGraphFromFolder.eptype)
}
inline void LoadGraphFromFolder::set_eptype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  eptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.LoadGraphFromFolder.eptype)
}
inline void LoadGraphFromFolder::set_eptype(const char* value,
    size_t size) {
  
  eptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.LoadGraphFromFolder.eptype)
}
inline std::string* LoadGraphFromFolder::_internal_mutable_eptype() {
  
  return eptype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadGraphFromFolder::release_eptype() {
  // @@protoc_insertion_point(field_release:dan.LoadGraphFromFolder.eptype)
  return eptype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadGraphFromFolder::set_allocated_eptype(std::string* eptype) {
  if (eptype != nullptr) {
    
  } else {
    
  }
  eptype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), eptype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.LoadGraphFromFolder.eptype)
}

// bool incoming = 6;
inline void LoadGraphFromFolder::clear_incoming() {
  incoming_ = false;
}
inline bool LoadGraphFromFolder::_internal_incoming() const {
  return incoming_;
}
inline bool LoadGraphFromFolder::incoming() const {
  // @@protoc_insertion_point(field_get:dan.LoadGraphFromFolder.incoming)
  return _internal_incoming();
}
inline void LoadGraphFromFolder::_internal_set_incoming(bool value) {
  
  incoming_ = value;
}
inline void LoadGraphFromFolder::set_incoming(bool value) {
  _internal_set_incoming(value);
  // @@protoc_insertion_point(field_set:dan.LoadGraphFromFolder.incoming)
}

// bool merge = 7;
inline void LoadGraphFromFolder::clear_merge() {
  merge_ = false;
}
inline bool LoadGraphFromFolder::_internal_merge() const {
  return merge_;
}
inline bool LoadGraphFromFolder::merge() const {
  // @@protoc_insertion_point(field_get:dan.LoadGraphFromFolder.merge)
  return _internal_merge();
}
inline void LoadGraphFromFolder::_internal_set_merge(bool value) {
  
  merge_ = value;
}
inline void LoadGraphFromFolder::set_merge(bool value) {
  _internal_set_merge(value);
  // @@protoc_insertion_point(field_set:dan.LoadGraphFromFolder.merge)
}

// bool is_partition = 8;
inline void LoadGraphFromFolder::clear_is_partition() {
  is_partition_ = false;
}
inline bool LoadGraphFromFolder::_internal_is_partition() const {
  return is_partition_;
}
inline bool LoadGraphFromFolder::is_partition() const {
  // @@protoc_insertion_point(field_get:dan.LoadGraphFromFolder.is_partition)
  return _internal_is_partition();
}
inline void LoadGraphFromFolder::_internal_set_is_partition(bool value) {
  
  is_partition_ = value;
}
inline void LoadGraphFromFolder::set_is_partition(bool value) {
  _internal_set_is_partition(value);
  // @@protoc_insertion_point(field_set:dan.LoadGraphFromFolder.is_partition)
}

// int32 part_type = 9;
inline void LoadGraphFromFolder::clear_part_type() {
  part_type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoadGraphFromFolder::_internal_part_type() const {
  return part_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoadGraphFromFolder::part_type() const {
  // @@protoc_insertion_point(field_get:dan.LoadGraphFromFolder.part_type)
  return _internal_part_type();
}
inline void LoadGraphFromFolder::_internal_set_part_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  part_type_ = value;
}
inline void LoadGraphFromFolder::set_part_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_part_type(value);
  // @@protoc_insertion_point(field_set:dan.LoadGraphFromFolder.part_type)
}

// .dan.StrVec nodes = 10;
inline bool LoadGraphFromFolder::_internal_has_nodes() const {
  return this != internal_default_instance() && nodes_ != nullptr;
}
inline bool LoadGraphFromFolder::has_nodes() const {
  return _internal_has_nodes();
}
inline void LoadGraphFromFolder::clear_nodes() {
  if (GetArena() == nullptr && nodes_ != nullptr) {
    delete nodes_;
  }
  nodes_ = nullptr;
}
inline const ::dan::StrVec& LoadGraphFromFolder::_internal_nodes() const {
  const ::dan::StrVec* p = nodes_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::StrVec&>(
      ::dan::_StrVec_default_instance_);
}
inline const ::dan::StrVec& LoadGraphFromFolder::nodes() const {
  // @@protoc_insertion_point(field_get:dan.LoadGraphFromFolder.nodes)
  return _internal_nodes();
}
inline void LoadGraphFromFolder::unsafe_arena_set_allocated_nodes(
    ::dan::StrVec* nodes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodes_);
  }
  nodes_ = nodes;
  if (nodes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.LoadGraphFromFolder.nodes)
}
inline ::dan::StrVec* LoadGraphFromFolder::release_nodes() {
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::StrVec* LoadGraphFromFolder::unsafe_arena_release_nodes() {
  // @@protoc_insertion_point(field_release:dan.LoadGraphFromFolder.nodes)
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  return temp;
}
inline ::dan::StrVec* LoadGraphFromFolder::_internal_mutable_nodes() {
  
  if (nodes_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::StrVec>(GetArena());
    nodes_ = p;
  }
  return nodes_;
}
inline ::dan::StrVec* LoadGraphFromFolder::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable:dan.LoadGraphFromFolder.nodes)
  return _internal_mutable_nodes();
}
inline void LoadGraphFromFolder::set_allocated_nodes(::dan::StrVec* nodes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete nodes_;
  }
  if (nodes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(nodes);
    if (message_arena != submessage_arena) {
      nodes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodes, submessage_arena);
    }
    
  } else {
    
  }
  nodes_ = nodes;
  // @@protoc_insertion_point(field_set_allocated:dan.LoadGraphFromFolder.nodes)
}

// -------------------------------------------------------------------

// VertexExists

// string gname = 1;
inline void VertexExists::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& VertexExists::gname() const {
  // @@protoc_insertion_point(field_get:dan.VertexExists.gname)
  return _internal_gname();
}
inline void VertexExists::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.VertexExists.gname)
}
inline std::string* VertexExists::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.VertexExists.gname)
  return _internal_mutable_gname();
}
inline const std::string& VertexExists::_internal_gname() const {
  return gname_.Get();
}
inline void VertexExists::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void VertexExists::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.VertexExists.gname)
}
inline void VertexExists::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.VertexExists.gname)
}
inline void VertexExists::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.VertexExists.gname)
}
inline std::string* VertexExists::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* VertexExists::release_gname() {
  // @@protoc_insertion_point(field_release:dan.VertexExists.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VertexExists::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.VertexExists.gname)
}

// .dan.Eval vkey = 2;
inline bool VertexExists::_internal_has_vkey() const {
  return this != internal_default_instance() && vkey_ != nullptr;
}
inline bool VertexExists::has_vkey() const {
  return _internal_has_vkey();
}
inline void VertexExists::clear_vkey() {
  if (GetArena() == nullptr && vkey_ != nullptr) {
    delete vkey_;
  }
  vkey_ = nullptr;
}
inline const ::dan::Eval& VertexExists::_internal_vkey() const {
  const ::dan::Eval* p = vkey_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Eval&>(
      ::dan::_Eval_default_instance_);
}
inline const ::dan::Eval& VertexExists::vkey() const {
  // @@protoc_insertion_point(field_get:dan.VertexExists.vkey)
  return _internal_vkey();
}
inline void VertexExists::unsafe_arena_set_allocated_vkey(
    ::dan::Eval* vkey) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vkey_);
  }
  vkey_ = vkey;
  if (vkey) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.VertexExists.vkey)
}
inline ::dan::Eval* VertexExists::release_vkey() {
  
  ::dan::Eval* temp = vkey_;
  vkey_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Eval* VertexExists::unsafe_arena_release_vkey() {
  // @@protoc_insertion_point(field_release:dan.VertexExists.vkey)
  
  ::dan::Eval* temp = vkey_;
  vkey_ = nullptr;
  return temp;
}
inline ::dan::Eval* VertexExists::_internal_mutable_vkey() {
  
  if (vkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Eval>(GetArena());
    vkey_ = p;
  }
  return vkey_;
}
inline ::dan::Eval* VertexExists::mutable_vkey() {
  // @@protoc_insertion_point(field_mutable:dan.VertexExists.vkey)
  return _internal_mutable_vkey();
}
inline void VertexExists::set_allocated_vkey(::dan::Eval* vkey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vkey_;
  }
  if (vkey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vkey);
    if (message_arena != submessage_arena) {
      vkey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vkey, submessage_arena);
    }
    
  } else {
    
  }
  vkey_ = vkey;
  // @@protoc_insertion_point(field_set_allocated:dan.VertexExists.vkey)
}

// int32 vpid = 3;
inline void VertexExists::clear_vpid() {
  vpid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VertexExists::_internal_vpid() const {
  return vpid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VertexExists::vpid() const {
  // @@protoc_insertion_point(field_get:dan.VertexExists.vpid)
  return _internal_vpid();
}
inline void VertexExists::_internal_set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vpid_ = value;
}
inline void VertexExists::set_vpid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vpid(value);
  // @@protoc_insertion_point(field_set:dan.VertexExists.vpid)
}

// -------------------------------------------------------------------

// TestStream

// .dan.Table data = 1;
inline bool TestStream::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool TestStream::has_data() const {
  return _internal_has_data();
}
inline void TestStream::clear_data() {
  if (GetArena() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
}
inline const ::dan::Table& TestStream::_internal_data() const {
  const ::dan::Table* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Table&>(
      ::dan::_Table_default_instance_);
}
inline const ::dan::Table& TestStream::data() const {
  // @@protoc_insertion_point(field_get:dan.TestStream.data)
  return _internal_data();
}
inline void TestStream::unsafe_arena_set_allocated_data(
    ::dan::Table* data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.TestStream.data)
}
inline ::dan::Table* TestStream::release_data() {
  
  ::dan::Table* temp = data_;
  data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Table* TestStream::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:dan.TestStream.data)
  
  ::dan::Table* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::dan::Table* TestStream::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Table>(GetArena());
    data_ = p;
  }
  return data_;
}
inline ::dan::Table* TestStream::mutable_data() {
  // @@protoc_insertion_point(field_mutable:dan.TestStream.data)
  return _internal_mutable_data();
}
inline void TestStream::set_allocated_data(::dan::Table* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:dan.TestStream.data)
}

// -------------------------------------------------------------------

// HostInfo

// string addr = 1;
inline void HostInfo::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& HostInfo::addr() const {
  // @@protoc_insertion_point(field_get:dan.HostInfo.addr)
  return _internal_addr();
}
inline void HostInfo::set_addr(const std::string& value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:dan.HostInfo.addr)
}
inline std::string* HostInfo::mutable_addr() {
  // @@protoc_insertion_point(field_mutable:dan.HostInfo.addr)
  return _internal_mutable_addr();
}
inline const std::string& HostInfo::_internal_addr() const {
  return addr_.Get();
}
inline void HostInfo::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HostInfo::set_addr(std::string&& value) {
  
  addr_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.HostInfo.addr)
}
inline void HostInfo::set_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.HostInfo.addr)
}
inline void HostInfo::set_addr(const char* value,
    size_t size) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.HostInfo.addr)
}
inline std::string* HostInfo::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HostInfo::release_addr() {
  // @@protoc_insertion_point(field_release:dan.HostInfo.addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HostInfo::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.HostInfo.addr)
}

// int32 port = 2;
inline void HostInfo::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HostInfo::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HostInfo::port() const {
  // @@protoc_insertion_point(field_get:dan.HostInfo.port)
  return _internal_port();
}
inline void HostInfo::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void HostInfo::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:dan.HostInfo.port)
}

// -------------------------------------------------------------------

// Binary

// bytes v = 1;
inline void Binary::clear_v() {
  v_.ClearToEmpty();
}
inline const std::string& Binary::v() const {
  // @@protoc_insertion_point(field_get:dan.Binary.v)
  return _internal_v();
}
inline void Binary::set_v(const std::string& value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:dan.Binary.v)
}
inline std::string* Binary::mutable_v() {
  // @@protoc_insertion_point(field_mutable:dan.Binary.v)
  return _internal_mutable_v();
}
inline const std::string& Binary::_internal_v() const {
  return v_.Get();
}
inline void Binary::_internal_set_v(const std::string& value) {
  
  v_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Binary::set_v(std::string&& value) {
  
  v_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.Binary.v)
}
inline void Binary::set_v(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  v_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.Binary.v)
}
inline void Binary::set_v(const void* value,
    size_t size) {
  
  v_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.Binary.v)
}
inline std::string* Binary::_internal_mutable_v() {
  
  return v_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Binary::release_v() {
  // @@protoc_insertion_point(field_release:dan.Binary.v)
  return v_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Binary::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  v_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), v,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.Binary.v)
}

// -------------------------------------------------------------------

// MergeInfo

// string gname = 1;
inline void MergeInfo::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& MergeInfo::gname() const {
  // @@protoc_insertion_point(field_get:dan.MergeInfo.gname)
  return _internal_gname();
}
inline void MergeInfo::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.MergeInfo.gname)
}
inline std::string* MergeInfo::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.MergeInfo.gname)
  return _internal_mutable_gname();
}
inline const std::string& MergeInfo::_internal_gname() const {
  return gname_.Get();
}
inline void MergeInfo::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MergeInfo::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.MergeInfo.gname)
}
inline void MergeInfo::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.MergeInfo.gname)
}
inline void MergeInfo::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.MergeInfo.gname)
}
inline std::string* MergeInfo::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MergeInfo::release_gname() {
  // @@protoc_insertion_point(field_release:dan.MergeInfo.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MergeInfo::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.MergeInfo.gname)
}

// int32 least = 2;
inline void MergeInfo::clear_least() {
  least_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MergeInfo::_internal_least() const {
  return least_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MergeInfo::least() const {
  // @@protoc_insertion_point(field_get:dan.MergeInfo.least)
  return _internal_least();
}
inline void MergeInfo::_internal_set_least(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  least_ = value;
}
inline void MergeInfo::set_least(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_least(value);
  // @@protoc_insertion_point(field_set:dan.MergeInfo.least)
}

// int32 num_split = 3;
inline void MergeInfo::clear_num_split() {
  num_split_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MergeInfo::_internal_num_split() const {
  return num_split_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MergeInfo::num_split() const {
  // @@protoc_insertion_point(field_get:dan.MergeInfo.num_split)
  return _internal_num_split();
}
inline void MergeInfo::_internal_set_num_split(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_split_ = value;
}
inline void MergeInfo::set_num_split(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_split(value);
  // @@protoc_insertion_point(field_set:dan.MergeInfo.num_split)
}

// -------------------------------------------------------------------

// TransferBinary

// int32 type = 1;
inline void TransferBinary::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransferBinary::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransferBinary::type() const {
  // @@protoc_insertion_point(field_get:dan.TransferBinary.type)
  return _internal_type();
}
inline void TransferBinary::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void TransferBinary::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:dan.TransferBinary.type)
}

// string name = 2;
inline void TransferBinary::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& TransferBinary::name() const {
  // @@protoc_insertion_point(field_get:dan.TransferBinary.name)
  return _internal_name();
}
inline void TransferBinary::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:dan.TransferBinary.name)
}
inline std::string* TransferBinary::mutable_name() {
  // @@protoc_insertion_point(field_mutable:dan.TransferBinary.name)
  return _internal_mutable_name();
}
inline const std::string& TransferBinary::_internal_name() const {
  return name_.Get();
}
inline void TransferBinary::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TransferBinary::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.TransferBinary.name)
}
inline void TransferBinary::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.TransferBinary.name)
}
inline void TransferBinary::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.TransferBinary.name)
}
inline std::string* TransferBinary::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TransferBinary::release_name() {
  // @@protoc_insertion_point(field_release:dan.TransferBinary.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TransferBinary::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.TransferBinary.name)
}

// int32 pa_id = 3;
inline void TransferBinary::clear_pa_id() {
  pa_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransferBinary::_internal_pa_id() const {
  return pa_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransferBinary::pa_id() const {
  // @@protoc_insertion_point(field_get:dan.TransferBinary.pa_id)
  return _internal_pa_id();
}
inline void TransferBinary::_internal_set_pa_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pa_id_ = value;
}
inline void TransferBinary::set_pa_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pa_id(value);
  // @@protoc_insertion_point(field_set:dan.TransferBinary.pa_id)
}

// int32 sgmt_id = 4;
inline void TransferBinary::clear_sgmt_id() {
  sgmt_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransferBinary::_internal_sgmt_id() const {
  return sgmt_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransferBinary::sgmt_id() const {
  // @@protoc_insertion_point(field_get:dan.TransferBinary.sgmt_id)
  return _internal_sgmt_id();
}
inline void TransferBinary::_internal_set_sgmt_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sgmt_id_ = value;
}
inline void TransferBinary::set_sgmt_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sgmt_id(value);
  // @@protoc_insertion_point(field_set:dan.TransferBinary.sgmt_id)
}

// .dan.Binary binary = 5;
inline bool TransferBinary::_internal_has_binary() const {
  return this != internal_default_instance() && binary_ != nullptr;
}
inline bool TransferBinary::has_binary() const {
  return _internal_has_binary();
}
inline void TransferBinary::clear_binary() {
  if (GetArena() == nullptr && binary_ != nullptr) {
    delete binary_;
  }
  binary_ = nullptr;
}
inline const ::dan::Binary& TransferBinary::_internal_binary() const {
  const ::dan::Binary* p = binary_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::Binary&>(
      ::dan::_Binary_default_instance_);
}
inline const ::dan::Binary& TransferBinary::binary() const {
  // @@protoc_insertion_point(field_get:dan.TransferBinary.binary)
  return _internal_binary();
}
inline void TransferBinary::unsafe_arena_set_allocated_binary(
    ::dan::Binary* binary) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(binary_);
  }
  binary_ = binary;
  if (binary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.TransferBinary.binary)
}
inline ::dan::Binary* TransferBinary::release_binary() {
  
  ::dan::Binary* temp = binary_;
  binary_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::Binary* TransferBinary::unsafe_arena_release_binary() {
  // @@protoc_insertion_point(field_release:dan.TransferBinary.binary)
  
  ::dan::Binary* temp = binary_;
  binary_ = nullptr;
  return temp;
}
inline ::dan::Binary* TransferBinary::_internal_mutable_binary() {
  
  if (binary_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::Binary>(GetArena());
    binary_ = p;
  }
  return binary_;
}
inline ::dan::Binary* TransferBinary::mutable_binary() {
  // @@protoc_insertion_point(field_mutable:dan.TransferBinary.binary)
  return _internal_mutable_binary();
}
inline void TransferBinary::set_allocated_binary(::dan::Binary* binary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete binary_;
  }
  if (binary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(binary);
    if (message_arena != submessage_arena) {
      binary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binary, submessage_arena);
    }
    
  } else {
    
  }
  binary_ = binary;
  // @@protoc_insertion_point(field_set_allocated:dan.TransferBinary.binary)
}

// -------------------------------------------------------------------

// MemoryStat

// bool verbose = 1;
inline void MemoryStat::clear_verbose() {
  verbose_ = false;
}
inline bool MemoryStat::_internal_verbose() const {
  return verbose_;
}
inline bool MemoryStat::verbose() const {
  // @@protoc_insertion_point(field_get:dan.MemoryStat.verbose)
  return _internal_verbose();
}
inline void MemoryStat::_internal_set_verbose(bool value) {
  
  verbose_ = value;
}
inline void MemoryStat::set_verbose(bool value) {
  _internal_set_verbose(value);
  // @@protoc_insertion_point(field_set:dan.MemoryStat.verbose)
}

// string path = 2;
inline void MemoryStat::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& MemoryStat::path() const {
  // @@protoc_insertion_point(field_get:dan.MemoryStat.path)
  return _internal_path();
}
inline void MemoryStat::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:dan.MemoryStat.path)
}
inline std::string* MemoryStat::mutable_path() {
  // @@protoc_insertion_point(field_mutable:dan.MemoryStat.path)
  return _internal_mutable_path();
}
inline const std::string& MemoryStat::_internal_path() const {
  return path_.Get();
}
inline void MemoryStat::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MemoryStat::set_path(std::string&& value) {
  
  path_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.MemoryStat.path)
}
inline void MemoryStat::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.MemoryStat.path)
}
inline void MemoryStat::set_path(const char* value,
    size_t size) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.MemoryStat.path)
}
inline std::string* MemoryStat::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MemoryStat::release_path() {
  // @@protoc_insertion_point(field_release:dan.MemoryStat.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MemoryStat::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.MemoryStat.path)
}

// int32 level = 3;
inline void MemoryStat::clear_level() {
  level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MemoryStat::_internal_level() const {
  return level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MemoryStat::level() const {
  // @@protoc_insertion_point(field_get:dan.MemoryStat.level)
  return _internal_level();
}
inline void MemoryStat::_internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  level_ = value;
}
inline void MemoryStat::set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:dan.MemoryStat.level)
}

// .dan.StrVec nodes = 4;
inline bool MemoryStat::_internal_has_nodes() const {
  return this != internal_default_instance() && nodes_ != nullptr;
}
inline bool MemoryStat::has_nodes() const {
  return _internal_has_nodes();
}
inline void MemoryStat::clear_nodes() {
  if (GetArena() == nullptr && nodes_ != nullptr) {
    delete nodes_;
  }
  nodes_ = nullptr;
}
inline const ::dan::StrVec& MemoryStat::_internal_nodes() const {
  const ::dan::StrVec* p = nodes_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::StrVec&>(
      ::dan::_StrVec_default_instance_);
}
inline const ::dan::StrVec& MemoryStat::nodes() const {
  // @@protoc_insertion_point(field_get:dan.MemoryStat.nodes)
  return _internal_nodes();
}
inline void MemoryStat::unsafe_arena_set_allocated_nodes(
    ::dan::StrVec* nodes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodes_);
  }
  nodes_ = nodes;
  if (nodes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.MemoryStat.nodes)
}
inline ::dan::StrVec* MemoryStat::release_nodes() {
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::StrVec* MemoryStat::unsafe_arena_release_nodes() {
  // @@protoc_insertion_point(field_release:dan.MemoryStat.nodes)
  
  ::dan::StrVec* temp = nodes_;
  nodes_ = nullptr;
  return temp;
}
inline ::dan::StrVec* MemoryStat::_internal_mutable_nodes() {
  
  if (nodes_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::StrVec>(GetArena());
    nodes_ = p;
  }
  return nodes_;
}
inline ::dan::StrVec* MemoryStat::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable:dan.MemoryStat.nodes)
  return _internal_mutable_nodes();
}
inline void MemoryStat::set_allocated_nodes(::dan::StrVec* nodes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete nodes_;
  }
  if (nodes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(nodes);
    if (message_arena != submessage_arena) {
      nodes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodes, submessage_arena);
    }
    
  } else {
    
  }
  nodes_ = nodes;
  // @@protoc_insertion_point(field_set_allocated:dan.MemoryStat.nodes)
}

// -------------------------------------------------------------------

// APPNP

// float alpha = 1;
inline void APPNP::clear_alpha() {
  alpha_ = 0;
}
inline float APPNP::_internal_alpha() const {
  return alpha_;
}
inline float APPNP::alpha() const {
  // @@protoc_insertion_point(field_get:dan.APPNP.alpha)
  return _internal_alpha();
}
inline void APPNP::_internal_set_alpha(float value) {
  
  alpha_ = value;
}
inline void APPNP::set_alpha(float value) {
  _internal_set_alpha(value);
  // @@protoc_insertion_point(field_set:dan.APPNP.alpha)
}

// int32 k = 2;
inline void APPNP::clear_k() {
  k_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 APPNP::_internal_k() const {
  return k_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 APPNP::k() const {
  // @@protoc_insertion_point(field_get:dan.APPNP.k)
  return _internal_k();
}
inline void APPNP::_internal_set_k(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  k_ = value;
}
inline void APPNP::set_k(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_k(value);
  // @@protoc_insertion_point(field_set:dan.APPNP.k)
}

// -------------------------------------------------------------------

// GAT

// int32 num_head = 1;
inline void GAT::clear_num_head() {
  num_head_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GAT::_internal_num_head() const {
  return num_head_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GAT::num_head() const {
  // @@protoc_insertion_point(field_get:dan.GAT.num_head)
  return _internal_num_head();
}
inline void GAT::_internal_set_num_head(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_head_ = value;
}
inline void GAT::set_num_head(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_head(value);
  // @@protoc_insertion_point(field_set:dan.GAT.num_head)
}

// bool agg = 2;
inline void GAT::clear_agg() {
  agg_ = false;
}
inline bool GAT::_internal_agg() const {
  return agg_;
}
inline bool GAT::agg() const {
  // @@protoc_insertion_point(field_get:dan.GAT.agg)
  return _internal_agg();
}
inline void GAT::_internal_set_agg(bool value) {
  
  agg_ = value;
}
inline void GAT::set_agg(bool value) {
  _internal_set_agg(value);
  // @@protoc_insertion_point(field_set:dan.GAT.agg)
}

// int32 importance_spl = 3;
inline void GAT::clear_importance_spl() {
  importance_spl_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GAT::_internal_importance_spl() const {
  return importance_spl_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GAT::importance_spl() const {
  // @@protoc_insertion_point(field_get:dan.GAT.importance_spl)
  return _internal_importance_spl();
}
inline void GAT::_internal_set_importance_spl(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  importance_spl_ = value;
}
inline void GAT::set_importance_spl(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_importance_spl(value);
  // @@protoc_insertion_point(field_set:dan.GAT.importance_spl)
}

// -------------------------------------------------------------------

// ModelInfo

// .dan.APPNP appnp = 1;
inline bool ModelInfo::_internal_has_appnp() const {
  return m_case() == kAppnp;
}
inline bool ModelInfo::has_appnp() const {
  return _internal_has_appnp();
}
inline void ModelInfo::set_has_appnp() {
  _oneof_case_[0] = kAppnp;
}
inline void ModelInfo::clear_appnp() {
  if (_internal_has_appnp()) {
    if (GetArena() == nullptr) {
      delete m_.appnp_;
    }
    clear_has_m();
  }
}
inline ::dan::APPNP* ModelInfo::release_appnp() {
  // @@protoc_insertion_point(field_release:dan.ModelInfo.appnp)
  if (_internal_has_appnp()) {
    clear_has_m();
      ::dan::APPNP* temp = m_.appnp_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    m_.appnp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dan::APPNP& ModelInfo::_internal_appnp() const {
  return _internal_has_appnp()
      ? *m_.appnp_
      : reinterpret_cast< ::dan::APPNP&>(::dan::_APPNP_default_instance_);
}
inline const ::dan::APPNP& ModelInfo::appnp() const {
  // @@protoc_insertion_point(field_get:dan.ModelInfo.appnp)
  return _internal_appnp();
}
inline ::dan::APPNP* ModelInfo::unsafe_arena_release_appnp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dan.ModelInfo.appnp)
  if (_internal_has_appnp()) {
    clear_has_m();
    ::dan::APPNP* temp = m_.appnp_;
    m_.appnp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelInfo::unsafe_arena_set_allocated_appnp(::dan::APPNP* appnp) {
  clear_m();
  if (appnp) {
    set_has_appnp();
    m_.appnp_ = appnp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.ModelInfo.appnp)
}
inline ::dan::APPNP* ModelInfo::_internal_mutable_appnp() {
  if (!_internal_has_appnp()) {
    clear_m();
    set_has_appnp();
    m_.appnp_ = CreateMaybeMessage< ::dan::APPNP >(GetArena());
  }
  return m_.appnp_;
}
inline ::dan::APPNP* ModelInfo::mutable_appnp() {
  // @@protoc_insertion_point(field_mutable:dan.ModelInfo.appnp)
  return _internal_mutable_appnp();
}

// .dan.GAT gat = 2;
inline bool ModelInfo::_internal_has_gat() const {
  return m_case() == kGat;
}
inline bool ModelInfo::has_gat() const {
  return _internal_has_gat();
}
inline void ModelInfo::set_has_gat() {
  _oneof_case_[0] = kGat;
}
inline void ModelInfo::clear_gat() {
  if (_internal_has_gat()) {
    if (GetArena() == nullptr) {
      delete m_.gat_;
    }
    clear_has_m();
  }
}
inline ::dan::GAT* ModelInfo::release_gat() {
  // @@protoc_insertion_point(field_release:dan.ModelInfo.gat)
  if (_internal_has_gat()) {
    clear_has_m();
      ::dan::GAT* temp = m_.gat_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    m_.gat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dan::GAT& ModelInfo::_internal_gat() const {
  return _internal_has_gat()
      ? *m_.gat_
      : reinterpret_cast< ::dan::GAT&>(::dan::_GAT_default_instance_);
}
inline const ::dan::GAT& ModelInfo::gat() const {
  // @@protoc_insertion_point(field_get:dan.ModelInfo.gat)
  return _internal_gat();
}
inline ::dan::GAT* ModelInfo::unsafe_arena_release_gat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dan.ModelInfo.gat)
  if (_internal_has_gat()) {
    clear_has_m();
    ::dan::GAT* temp = m_.gat_;
    m_.gat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelInfo::unsafe_arena_set_allocated_gat(::dan::GAT* gat) {
  clear_m();
  if (gat) {
    set_has_gat();
    m_.gat_ = gat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.ModelInfo.gat)
}
inline ::dan::GAT* ModelInfo::_internal_mutable_gat() {
  if (!_internal_has_gat()) {
    clear_m();
    set_has_gat();
    m_.gat_ = CreateMaybeMessage< ::dan::GAT >(GetArena());
  }
  return m_.gat_;
}
inline ::dan::GAT* ModelInfo::mutable_gat() {
  // @@protoc_insertion_point(field_mutable:dan.ModelInfo.gat)
  return _internal_mutable_gat();
}

inline bool ModelInfo::has_m() const {
  return m_case() != M_NOT_SET;
}
inline void ModelInfo::clear_has_m() {
  _oneof_case_[0] = M_NOT_SET;
}
inline ModelInfo::MCase ModelInfo::m_case() const {
  return ModelInfo::MCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NodeClassifierInfo

// string gname = 1;
inline void NodeClassifierInfo::clear_gname() {
  gname_.ClearToEmpty();
}
inline const std::string& NodeClassifierInfo::gname() const {
  // @@protoc_insertion_point(field_get:dan.NodeClassifierInfo.gname)
  return _internal_gname();
}
inline void NodeClassifierInfo::set_gname(const std::string& value) {
  _internal_set_gname(value);
  // @@protoc_insertion_point(field_set:dan.NodeClassifierInfo.gname)
}
inline std::string* NodeClassifierInfo::mutable_gname() {
  // @@protoc_insertion_point(field_mutable:dan.NodeClassifierInfo.gname)
  return _internal_mutable_gname();
}
inline const std::string& NodeClassifierInfo::_internal_gname() const {
  return gname_.Get();
}
inline void NodeClassifierInfo::_internal_set_gname(const std::string& value) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeClassifierInfo::set_gname(std::string&& value) {
  
  gname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.NodeClassifierInfo.gname)
}
inline void NodeClassifierInfo::set_gname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.NodeClassifierInfo.gname)
}
inline void NodeClassifierInfo::set_gname(const char* value,
    size_t size) {
  
  gname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.NodeClassifierInfo.gname)
}
inline std::string* NodeClassifierInfo::_internal_mutable_gname() {
  
  return gname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeClassifierInfo::release_gname() {
  // @@protoc_insertion_point(field_release:dan.NodeClassifierInfo.gname)
  return gname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeClassifierInfo::set_allocated_gname(std::string* gname) {
  if (gname != nullptr) {
    
  } else {
    
  }
  gname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.NodeClassifierInfo.gname)
}

// .dan.IntVec fids = 2;
inline bool NodeClassifierInfo::_internal_has_fids() const {
  return this != internal_default_instance() && fids_ != nullptr;
}
inline bool NodeClassifierInfo::has_fids() const {
  return _internal_has_fids();
}
inline void NodeClassifierInfo::clear_fids() {
  if (GetArena() == nullptr && fids_ != nullptr) {
    delete fids_;
  }
  fids_ = nullptr;
}
inline const ::dan::IntVec& NodeClassifierInfo::_internal_fids() const {
  const ::dan::IntVec* p = fids_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::IntVec&>(
      ::dan::_IntVec_default_instance_);
}
inline const ::dan::IntVec& NodeClassifierInfo::fids() const {
  // @@protoc_insertion_point(field_get:dan.NodeClassifierInfo.fids)
  return _internal_fids();
}
inline void NodeClassifierInfo::unsafe_arena_set_allocated_fids(
    ::dan::IntVec* fids) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fids_);
  }
  fids_ = fids;
  if (fids) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.NodeClassifierInfo.fids)
}
inline ::dan::IntVec* NodeClassifierInfo::release_fids() {
  
  ::dan::IntVec* temp = fids_;
  fids_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::IntVec* NodeClassifierInfo::unsafe_arena_release_fids() {
  // @@protoc_insertion_point(field_release:dan.NodeClassifierInfo.fids)
  
  ::dan::IntVec* temp = fids_;
  fids_ = nullptr;
  return temp;
}
inline ::dan::IntVec* NodeClassifierInfo::_internal_mutable_fids() {
  
  if (fids_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::IntVec>(GetArena());
    fids_ = p;
  }
  return fids_;
}
inline ::dan::IntVec* NodeClassifierInfo::mutable_fids() {
  // @@protoc_insertion_point(field_mutable:dan.NodeClassifierInfo.fids)
  return _internal_mutable_fids();
}
inline void NodeClassifierInfo::set_allocated_fids(::dan::IntVec* fids) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fids_;
  }
  if (fids) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fids);
    if (message_arena != submessage_arena) {
      fids = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fids, submessage_arena);
    }
    
  } else {
    
  }
  fids_ = fids;
  // @@protoc_insertion_point(field_set_allocated:dan.NodeClassifierInfo.fids)
}

// int32 input_size = 3;
inline void NodeClassifierInfo::clear_input_size() {
  input_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeClassifierInfo::_internal_input_size() const {
  return input_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeClassifierInfo::input_size() const {
  // @@protoc_insertion_point(field_get:dan.NodeClassifierInfo.input_size)
  return _internal_input_size();
}
inline void NodeClassifierInfo::_internal_set_input_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  input_size_ = value;
}
inline void NodeClassifierInfo::set_input_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_input_size(value);
  // @@protoc_insertion_point(field_set:dan.NodeClassifierInfo.input_size)
}

// int32 hidden_size = 4;
inline void NodeClassifierInfo::clear_hidden_size() {
  hidden_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeClassifierInfo::_internal_hidden_size() const {
  return hidden_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeClassifierInfo::hidden_size() const {
  // @@protoc_insertion_point(field_get:dan.NodeClassifierInfo.hidden_size)
  return _internal_hidden_size();
}
inline void NodeClassifierInfo::_internal_set_hidden_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hidden_size_ = value;
}
inline void NodeClassifierInfo::set_hidden_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hidden_size(value);
  // @@protoc_insertion_point(field_set:dan.NodeClassifierInfo.hidden_size)
}

// int32 num_class = 5;
inline void NodeClassifierInfo::clear_num_class() {
  num_class_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeClassifierInfo::_internal_num_class() const {
  return num_class_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeClassifierInfo::num_class() const {
  // @@protoc_insertion_point(field_get:dan.NodeClassifierInfo.num_class)
  return _internal_num_class();
}
inline void NodeClassifierInfo::_internal_set_num_class(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_class_ = value;
}
inline void NodeClassifierInfo::set_num_class(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_class(value);
  // @@protoc_insertion_point(field_set:dan.NodeClassifierInfo.num_class)
}

// float dropout = 6;
inline void NodeClassifierInfo::clear_dropout() {
  dropout_ = 0;
}
inline float NodeClassifierInfo::_internal_dropout() const {
  return dropout_;
}
inline float NodeClassifierInfo::dropout() const {
  // @@protoc_insertion_point(field_get:dan.NodeClassifierInfo.dropout)
  return _internal_dropout();
}
inline void NodeClassifierInfo::_internal_set_dropout(float value) {
  
  dropout_ = value;
}
inline void NodeClassifierInfo::set_dropout(float value) {
  _internal_set_dropout(value);
  // @@protoc_insertion_point(field_set:dan.NodeClassifierInfo.dropout)
}

// float learning_rate = 7;
inline void NodeClassifierInfo::clear_learning_rate() {
  learning_rate_ = 0;
}
inline float NodeClassifierInfo::_internal_learning_rate() const {
  return learning_rate_;
}
inline float NodeClassifierInfo::learning_rate() const {
  // @@protoc_insertion_point(field_get:dan.NodeClassifierInfo.learning_rate)
  return _internal_learning_rate();
}
inline void NodeClassifierInfo::_internal_set_learning_rate(float value) {
  
  learning_rate_ = value;
}
inline void NodeClassifierInfo::set_learning_rate(float value) {
  _internal_set_learning_rate(value);
  // @@protoc_insertion_point(field_set:dan.NodeClassifierInfo.learning_rate)
}

// int32 data_update_interval = 8;
inline void NodeClassifierInfo::clear_data_update_interval() {
  data_update_interval_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeClassifierInfo::_internal_data_update_interval() const {
  return data_update_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeClassifierInfo::data_update_interval() const {
  // @@protoc_insertion_point(field_get:dan.NodeClassifierInfo.data_update_interval)
  return _internal_data_update_interval();
}
inline void NodeClassifierInfo::_internal_set_data_update_interval(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  data_update_interval_ = value;
}
inline void NodeClassifierInfo::set_data_update_interval(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_data_update_interval(value);
  // @@protoc_insertion_point(field_set:dan.NodeClassifierInfo.data_update_interval)
}

// bool merge_manually = 9;
inline void NodeClassifierInfo::clear_merge_manually() {
  merge_manually_ = false;
}
inline bool NodeClassifierInfo::_internal_merge_manually() const {
  return merge_manually_;
}
inline bool NodeClassifierInfo::merge_manually() const {
  // @@protoc_insertion_point(field_get:dan.NodeClassifierInfo.merge_manually)
  return _internal_merge_manually();
}
inline void NodeClassifierInfo::_internal_set_merge_manually(bool value) {
  
  merge_manually_ = value;
}
inline void NodeClassifierInfo::set_merge_manually(bool value) {
  _internal_set_merge_manually(value);
  // @@protoc_insertion_point(field_set:dan.NodeClassifierInfo.merge_manually)
}

// int32 num_epochs = 10;
inline void NodeClassifierInfo::clear_num_epochs() {
  num_epochs_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeClassifierInfo::_internal_num_epochs() const {
  return num_epochs_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeClassifierInfo::num_epochs() const {
  // @@protoc_insertion_point(field_get:dan.NodeClassifierInfo.num_epochs)
  return _internal_num_epochs();
}
inline void NodeClassifierInfo::_internal_set_num_epochs(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_epochs_ = value;
}
inline void NodeClassifierInfo::set_num_epochs(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_epochs(value);
  // @@protoc_insertion_point(field_set:dan.NodeClassifierInfo.num_epochs)
}

// .dan.ModelInfo model_info = 11;
inline bool NodeClassifierInfo::_internal_has_model_info() const {
  return this != internal_default_instance() && model_info_ != nullptr;
}
inline bool NodeClassifierInfo::has_model_info() const {
  return _internal_has_model_info();
}
inline void NodeClassifierInfo::clear_model_info() {
  if (GetArena() == nullptr && model_info_ != nullptr) {
    delete model_info_;
  }
  model_info_ = nullptr;
}
inline const ::dan::ModelInfo& NodeClassifierInfo::_internal_model_info() const {
  const ::dan::ModelInfo* p = model_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::dan::ModelInfo&>(
      ::dan::_ModelInfo_default_instance_);
}
inline const ::dan::ModelInfo& NodeClassifierInfo::model_info() const {
  // @@protoc_insertion_point(field_get:dan.NodeClassifierInfo.model_info)
  return _internal_model_info();
}
inline void NodeClassifierInfo::unsafe_arena_set_allocated_model_info(
    ::dan::ModelInfo* model_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_info_);
  }
  model_info_ = model_info;
  if (model_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dan.NodeClassifierInfo.model_info)
}
inline ::dan::ModelInfo* NodeClassifierInfo::release_model_info() {
  
  ::dan::ModelInfo* temp = model_info_;
  model_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::dan::ModelInfo* NodeClassifierInfo::unsafe_arena_release_model_info() {
  // @@protoc_insertion_point(field_release:dan.NodeClassifierInfo.model_info)
  
  ::dan::ModelInfo* temp = model_info_;
  model_info_ = nullptr;
  return temp;
}
inline ::dan::ModelInfo* NodeClassifierInfo::_internal_mutable_model_info() {
  
  if (model_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::dan::ModelInfo>(GetArena());
    model_info_ = p;
  }
  return model_info_;
}
inline ::dan::ModelInfo* NodeClassifierInfo::mutable_model_info() {
  // @@protoc_insertion_point(field_mutable:dan.NodeClassifierInfo.model_info)
  return _internal_mutable_model_info();
}
inline void NodeClassifierInfo::set_allocated_model_info(::dan::ModelInfo* model_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete model_info_;
  }
  if (model_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(model_info);
    if (message_arena != submessage_arena) {
      model_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_info, submessage_arena);
    }
    
  } else {
    
  }
  model_info_ = model_info;
  // @@protoc_insertion_point(field_set_allocated:dan.NodeClassifierInfo.model_info)
}

// string log_file = 12;
inline void NodeClassifierInfo::clear_log_file() {
  log_file_.ClearToEmpty();
}
inline const std::string& NodeClassifierInfo::log_file() const {
  // @@protoc_insertion_point(field_get:dan.NodeClassifierInfo.log_file)
  return _internal_log_file();
}
inline void NodeClassifierInfo::set_log_file(const std::string& value) {
  _internal_set_log_file(value);
  // @@protoc_insertion_point(field_set:dan.NodeClassifierInfo.log_file)
}
inline std::string* NodeClassifierInfo::mutable_log_file() {
  // @@protoc_insertion_point(field_mutable:dan.NodeClassifierInfo.log_file)
  return _internal_mutable_log_file();
}
inline const std::string& NodeClassifierInfo::_internal_log_file() const {
  return log_file_.Get();
}
inline void NodeClassifierInfo::_internal_set_log_file(const std::string& value) {
  
  log_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeClassifierInfo::set_log_file(std::string&& value) {
  
  log_file_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dan.NodeClassifierInfo.log_file)
}
inline void NodeClassifierInfo::set_log_file(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  log_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:dan.NodeClassifierInfo.log_file)
}
inline void NodeClassifierInfo::set_log_file(const char* value,
    size_t size) {
  
  log_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dan.NodeClassifierInfo.log_file)
}
inline std::string* NodeClassifierInfo::_internal_mutable_log_file() {
  
  return log_file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeClassifierInfo::release_log_file() {
  // @@protoc_insertion_point(field_release:dan.NodeClassifierInfo.log_file)
  return log_file_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeClassifierInfo::set_allocated_log_file(std::string* log_file) {
  if (log_file != nullptr) {
    
  } else {
    
  }
  log_file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), log_file,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dan.NodeClassifierInfo.log_file)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dan

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::dan::Code_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dan::Code_Status>() {
  return ::dan::Code_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_interface_2eproto
