// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: interface.proto

#include "interface.pb.h"
#include "interface.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace dan {

static const char* DANInterface_method_names[] = {
  "/dan.DANInterface/ping",
  "/dan.DANInterface/test_stream",
  "/dan.DANInterface/test_multiunary",
  "/dan.DANInterface/test_size",
  "/dan.DANInterface/archive",
  "/dan.DANInterface/recover",
  "/dan.DANInterface/request_node_list",
  "/dan.DANInterface/request_register_node",
  "/dan.DANInterface/request_socket",
  "/dan.DANInterface/memory_statistics",
  "/dan.DANInterface/create_table",
  "/dan.DANInterface/drop_table",
  "/dan.DANInterface/drop_table_if_exists",
  "/dan.DANInterface/load_table",
  "/dan.DANInterface/create_index",
  "/dan.DANInterface/table_partition",
  "/dan.DANInterface/set_partition",
  "/dan.DANInterface/create_graph",
  "/dan.DANInterface/drop_graph",
  "/dan.DANInterface/drop_graph_if_exists",
  "/dan.DANInterface/define_vertex",
  "/dan.DANInterface/graph_partition",
  "/dan.DANInterface/graph_merge",
  "/dan.DANInterface/transfer_data",
  "/dan.DANInterface/insert_record",
  "/dan.DANInterface/insert_record_batch",
  "/dan.DANInterface/import_vertex",
  "/dan.DANInterface/insert_vertex",
  "/dan.DANInterface/insert_vertex_batch",
  "/dan.DANInterface/import_edge",
  "/dan.DANInterface/insert_edge",
  "/dan.DANInterface/insert_edge_vp",
  "/dan.DANInterface/insert_edge_naive",
  "/dan.DANInterface/insert_edge_batch",
  "/dan.DANInterface/insert_edge_batch_vp",
  "/dan.DANInterface/get_table_info",
  "/dan.DANInterface/get_num_records",
  "/dan.DANInterface/table_scan",
  "/dan.DANInterface/index_search",
  "/dan.DANInterface/get_graph_info",
  "/dan.DANInterface/get_num_vertex",
  "/dan.DANInterface/get_num_edges",
  "/dan.DANInterface/adjacent_list",
  "/dan.DANInterface/get_edge_list",
  "/dan.DANInterface/get_vertex",
  "/dan.DANInterface/get_vertex_list",
  "/dan.DANInterface/vertex_exists",
  "/dan.DANInterface/remote_task",
  "/dan.DANInterface/remote_object",
  "/dan.DANInterface/remove_remote_object",
  "/dan.DANInterface/remote_object_task",
  "/dan.DANInterface/remote_task_result",
  "/dan.DANInterface/remove_task_result",
  "/dan.DANInterface/load_graph_from_folder",
  "/dan.DANInterface/train_node_classifier",
};

std::unique_ptr< DANInterface::Stub> DANInterface::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< DANInterface::Stub> stub(new DANInterface::Stub(channel));
  return stub;
}

DANInterface::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_ping_(DANInterface_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_test_stream_(DANInterface_method_names[1], ::grpc::internal::RpcMethod::CLIENT_STREAMING, channel)
  , rpcmethod_test_multiunary_(DANInterface_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_test_size_(DANInterface_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_archive_(DANInterface_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_recover_(DANInterface_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_request_node_list_(DANInterface_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_request_register_node_(DANInterface_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_request_socket_(DANInterface_method_names[8], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_memory_statistics_(DANInterface_method_names[9], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_create_table_(DANInterface_method_names[10], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_drop_table_(DANInterface_method_names[11], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_drop_table_if_exists_(DANInterface_method_names[12], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_load_table_(DANInterface_method_names[13], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_create_index_(DANInterface_method_names[14], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_table_partition_(DANInterface_method_names[15], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_set_partition_(DANInterface_method_names[16], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_create_graph_(DANInterface_method_names[17], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_drop_graph_(DANInterface_method_names[18], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_drop_graph_if_exists_(DANInterface_method_names[19], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_define_vertex_(DANInterface_method_names[20], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_graph_partition_(DANInterface_method_names[21], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_graph_merge_(DANInterface_method_names[22], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_transfer_data_(DANInterface_method_names[23], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_insert_record_(DANInterface_method_names[24], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_insert_record_batch_(DANInterface_method_names[25], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_import_vertex_(DANInterface_method_names[26], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_insert_vertex_(DANInterface_method_names[27], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_insert_vertex_batch_(DANInterface_method_names[28], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_import_edge_(DANInterface_method_names[29], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_insert_edge_(DANInterface_method_names[30], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_insert_edge_vp_(DANInterface_method_names[31], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_insert_edge_naive_(DANInterface_method_names[32], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_insert_edge_batch_(DANInterface_method_names[33], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_insert_edge_batch_vp_(DANInterface_method_names[34], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_table_info_(DANInterface_method_names[35], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_num_records_(DANInterface_method_names[36], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_table_scan_(DANInterface_method_names[37], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_index_search_(DANInterface_method_names[38], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_graph_info_(DANInterface_method_names[39], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_num_vertex_(DANInterface_method_names[40], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_num_edges_(DANInterface_method_names[41], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_adjacent_list_(DANInterface_method_names[42], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_edge_list_(DANInterface_method_names[43], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_get_vertex_(DANInterface_method_names[44], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_vertex_list_(DANInterface_method_names[45], ::grpc::internal::RpcMethod::SERVER_STREAMING, channel)
  , rpcmethod_vertex_exists_(DANInterface_method_names[46], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_remote_task_(DANInterface_method_names[47], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_remote_object_(DANInterface_method_names[48], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_remove_remote_object_(DANInterface_method_names[49], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_remote_object_task_(DANInterface_method_names[50], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_remote_task_result_(DANInterface_method_names[51], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_remove_task_result_(DANInterface_method_names[52], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_load_graph_from_folder_(DANInterface_method_names[53], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_train_node_classifier_(DANInterface_method_names[54], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status DANInterface::Stub::ping(::grpc::ClientContext* context, const ::dan::Void& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ping_, context, request, response);
}

void DANInterface::Stub::experimental_async::ping(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ping_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::ping(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ping_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::ping(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ping_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::ping(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ping_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::AsyncpingRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_ping_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncpingRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_ping_, context, request, false);
}

::grpc::ClientWriter< ::dan::TestStream>* DANInterface::Stub::test_streamRaw(::grpc::ClientContext* context, ::dan::Code* response) {
  return ::grpc::internal::ClientWriterFactory< ::dan::TestStream>::Create(channel_.get(), rpcmethod_test_stream_, context, response);
}

void DANInterface::Stub::experimental_async::test_stream(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::experimental::ClientWriteReactor< ::dan::TestStream>* reactor) {
  ::grpc::internal::ClientCallbackWriterFactory< ::dan::TestStream>::Create(stub_->channel_.get(), stub_->rpcmethod_test_stream_, context, response, reactor);
}

::grpc::ClientAsyncWriter< ::dan::TestStream>* DANInterface::Stub::Asynctest_streamRaw(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc::internal::ClientAsyncWriterFactory< ::dan::TestStream>::Create(channel_.get(), cq, rpcmethod_test_stream_, context, response, true, tag);
}

::grpc::ClientAsyncWriter< ::dan::TestStream>* DANInterface::Stub::PrepareAsynctest_streamRaw(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncWriterFactory< ::dan::TestStream>::Create(channel_.get(), cq, rpcmethod_test_stream_, context, response, false, nullptr);
}

::grpc::Status DANInterface::Stub::test_multiunary(::grpc::ClientContext* context, const ::dan::TestStream& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_test_multiunary_, context, request, response);
}

void DANInterface::Stub::experimental_async::test_multiunary(::grpc::ClientContext* context, const ::dan::TestStream* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_test_multiunary_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::test_multiunary(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_test_multiunary_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::test_multiunary(::grpc::ClientContext* context, const ::dan::TestStream* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_test_multiunary_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::test_multiunary(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_test_multiunary_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asynctest_multiunaryRaw(::grpc::ClientContext* context, const ::dan::TestStream& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_test_multiunary_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsynctest_multiunaryRaw(::grpc::ClientContext* context, const ::dan::TestStream& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_test_multiunary_, context, request, false);
}

::grpc::Status DANInterface::Stub::test_size(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::dan::DoubleVec* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_test_size_, context, request, response);
}

void DANInterface::Stub::experimental_async::test_size(::grpc::ClientContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_test_size_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::test_size(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::DoubleVec* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_test_size_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::test_size(::grpc::ClientContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_test_size_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::test_size(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::DoubleVec* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_test_size_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::DoubleVec>* DANInterface::Stub::Asynctest_sizeRaw(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::DoubleVec>::Create(channel_.get(), cq, rpcmethod_test_size_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::DoubleVec>* DANInterface::Stub::PrepareAsynctest_sizeRaw(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::DoubleVec>::Create(channel_.get(), cq, rpcmethod_test_size_, context, request, false);
}

::grpc::Status DANInterface::Stub::archive(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_archive_, context, request, response);
}

void DANInterface::Stub::experimental_async::archive(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_archive_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::archive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_archive_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::archive(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_archive_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::archive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_archive_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::AsyncarchiveRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_archive_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncarchiveRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_archive_, context, request, false);
}

::grpc::Status DANInterface::Stub::recover(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_recover_, context, request, response);
}

void DANInterface::Stub::experimental_async::recover(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_recover_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_recover_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::recover(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_recover_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_recover_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::AsyncrecoverRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_recover_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncrecoverRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_recover_, context, request, false);
}

::grpc::Status DANInterface::Stub::request_node_list(::grpc::ClientContext* context, const ::dan::Void& request, ::dan::NodeInfoVec* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_request_node_list_, context, request, response);
}

void DANInterface::Stub::experimental_async::request_node_list(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_request_node_list_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::request_node_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::NodeInfoVec* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_request_node_list_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::request_node_list(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_request_node_list_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::request_node_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::NodeInfoVec* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_request_node_list_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::NodeInfoVec>* DANInterface::Stub::Asyncrequest_node_listRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::NodeInfoVec>::Create(channel_.get(), cq, rpcmethod_request_node_list_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::NodeInfoVec>* DANInterface::Stub::PrepareAsyncrequest_node_listRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::NodeInfoVec>::Create(channel_.get(), cq, rpcmethod_request_node_list_, context, request, false);
}

::grpc::Status DANInterface::Stub::request_register_node(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_request_register_node_, context, request, response);
}

void DANInterface::Stub::experimental_async::request_register_node(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_request_register_node_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::request_register_node(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_request_register_node_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::request_register_node(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_request_register_node_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::request_register_node(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_request_register_node_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncrequest_register_nodeRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_request_register_node_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncrequest_register_nodeRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_request_register_node_, context, request, false);
}

::grpc::Status DANInterface::Stub::request_socket(::grpc::ClientContext* context, const ::dan::Void& request, ::dan::HostInfo* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_request_socket_, context, request, response);
}

void DANInterface::Stub::experimental_async::request_socket(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::HostInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_request_socket_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::request_socket(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::HostInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_request_socket_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::request_socket(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::HostInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_request_socket_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::request_socket(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::HostInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_request_socket_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::HostInfo>* DANInterface::Stub::Asyncrequest_socketRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::HostInfo>::Create(channel_.get(), cq, rpcmethod_request_socket_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::HostInfo>* DANInterface::Stub::PrepareAsyncrequest_socketRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::HostInfo>::Create(channel_.get(), cq, rpcmethod_request_socket_, context, request, false);
}

::grpc::Status DANInterface::Stub::memory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_memory_statistics_, context, request, response);
}

void DANInterface::Stub::experimental_async::memory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_memory_statistics_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::memory_statistics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_memory_statistics_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::memory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_memory_statistics_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::memory_statistics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_memory_statistics_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncmemory_statisticsRaw(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_memory_statistics_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncmemory_statisticsRaw(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_memory_statistics_, context, request, false);
}

::grpc::Status DANInterface::Stub::create_table(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_create_table_, context, request, response);
}

void DANInterface::Stub::experimental_async::create_table(::grpc::ClientContext* context, const ::dan::CreateTable* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_create_table_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::create_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_create_table_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::create_table(::grpc::ClientContext* context, const ::dan::CreateTable* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_create_table_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::create_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_create_table_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asynccreate_tableRaw(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_create_table_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsynccreate_tableRaw(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_create_table_, context, request, false);
}

::grpc::Status DANInterface::Stub::drop_table(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_drop_table_, context, request, response);
}

void DANInterface::Stub::experimental_async::drop_table(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_drop_table_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::drop_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_drop_table_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::drop_table(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_drop_table_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::drop_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_drop_table_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncdrop_tableRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_drop_table_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncdrop_tableRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_drop_table_, context, request, false);
}

::grpc::Status DANInterface::Stub::drop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_drop_table_if_exists_, context, request, response);
}

void DANInterface::Stub::experimental_async::drop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_drop_table_if_exists_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::drop_table_if_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_drop_table_if_exists_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::drop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_drop_table_if_exists_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::drop_table_if_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_drop_table_if_exists_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncdrop_table_if_existsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_drop_table_if_exists_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncdrop_table_if_existsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_drop_table_if_exists_, context, request, false);
}

::grpc::Status DANInterface::Stub::load_table(::grpc::ClientContext* context, const ::dan::StrVec& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_load_table_, context, request, response);
}

void DANInterface::Stub::experimental_async::load_table(::grpc::ClientContext* context, const ::dan::StrVec* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_load_table_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::load_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_load_table_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::load_table(::grpc::ClientContext* context, const ::dan::StrVec* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_load_table_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::load_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_load_table_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncload_tableRaw(::grpc::ClientContext* context, const ::dan::StrVec& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_load_table_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncload_tableRaw(::grpc::ClientContext* context, const ::dan::StrVec& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_load_table_, context, request, false);
}

::grpc::Status DANInterface::Stub::create_index(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_create_index_, context, request, response);
}

void DANInterface::Stub::experimental_async::create_index(::grpc::ClientContext* context, const ::dan::CreateIndex* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_create_index_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::create_index(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_create_index_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::create_index(::grpc::ClientContext* context, const ::dan::CreateIndex* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_create_index_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::create_index(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_create_index_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asynccreate_indexRaw(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_create_index_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsynccreate_indexRaw(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_create_index_, context, request, false);
}

::grpc::Status DANInterface::Stub::table_partition(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_table_partition_, context, request, response);
}

void DANInterface::Stub::experimental_async::table_partition(::grpc::ClientContext* context, const ::dan::TablePartition* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_table_partition_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::table_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_table_partition_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::table_partition(::grpc::ClientContext* context, const ::dan::TablePartition* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_table_partition_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::table_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_table_partition_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asynctable_partitionRaw(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_table_partition_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsynctable_partitionRaw(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_table_partition_, context, request, false);
}

::grpc::Status DANInterface::Stub::set_partition(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_set_partition_, context, request, response);
}

void DANInterface::Stub::experimental_async::set_partition(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_set_partition_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::set_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_set_partition_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::set_partition(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_set_partition_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::set_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_set_partition_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncset_partitionRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_set_partition_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncset_partitionRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_set_partition_, context, request, false);
}

::grpc::Status DANInterface::Stub::create_graph(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_create_graph_, context, request, response);
}

void DANInterface::Stub::experimental_async::create_graph(::grpc::ClientContext* context, const ::dan::CreateGraph* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_create_graph_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::create_graph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_create_graph_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::create_graph(::grpc::ClientContext* context, const ::dan::CreateGraph* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_create_graph_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::create_graph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_create_graph_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asynccreate_graphRaw(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_create_graph_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsynccreate_graphRaw(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_create_graph_, context, request, false);
}

::grpc::Status DANInterface::Stub::drop_graph(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_drop_graph_, context, request, response);
}

void DANInterface::Stub::experimental_async::drop_graph(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_drop_graph_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::drop_graph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_drop_graph_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::drop_graph(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_drop_graph_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::drop_graph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_drop_graph_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncdrop_graphRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_drop_graph_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncdrop_graphRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_drop_graph_, context, request, false);
}

::grpc::Status DANInterface::Stub::drop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_drop_graph_if_exists_, context, request, response);
}

void DANInterface::Stub::experimental_async::drop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_drop_graph_if_exists_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::drop_graph_if_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_drop_graph_if_exists_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::drop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_drop_graph_if_exists_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::drop_graph_if_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_drop_graph_if_exists_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncdrop_graph_if_existsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_drop_graph_if_exists_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncdrop_graph_if_existsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_drop_graph_if_exists_, context, request, false);
}

::grpc::Status DANInterface::Stub::define_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_define_vertex_, context, request, response);
}

void DANInterface::Stub::experimental_async::define_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_define_vertex_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::define_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_define_vertex_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::define_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_define_vertex_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::define_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_define_vertex_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncdefine_vertexRaw(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_define_vertex_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncdefine_vertexRaw(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_define_vertex_, context, request, false);
}

::grpc::Status DANInterface::Stub::graph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_graph_partition_, context, request, response);
}

void DANInterface::Stub::experimental_async::graph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_graph_partition_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::graph_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_graph_partition_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::graph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_graph_partition_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::graph_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_graph_partition_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncgraph_partitionRaw(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_graph_partition_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncgraph_partitionRaw(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_graph_partition_, context, request, false);
}

::grpc::Status DANInterface::Stub::graph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_graph_merge_, context, request, response);
}

void DANInterface::Stub::experimental_async::graph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_graph_merge_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::graph_merge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_graph_merge_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::graph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_graph_merge_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::graph_merge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_graph_merge_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncgraph_mergeRaw(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_graph_merge_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncgraph_mergeRaw(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_graph_merge_, context, request, false);
}

::grpc::Status DANInterface::Stub::transfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_transfer_data_, context, request, response);
}

void DANInterface::Stub::experimental_async::transfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_transfer_data_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::transfer_data(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_transfer_data_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::transfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_transfer_data_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::transfer_data(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_transfer_data_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asynctransfer_dataRaw(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_transfer_data_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsynctransfer_dataRaw(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_transfer_data_, context, request, false);
}

::grpc::Status DANInterface::Stub::insert_record(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::dan::Str* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_insert_record_, context, request, response);
}

void DANInterface::Stub::experimental_async::insert_record(::grpc::ClientContext* context, const ::dan::InsertRecord* request, ::dan::Str* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_record_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_record(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Str* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_record_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_record(::grpc::ClientContext* context, const ::dan::InsertRecord* request, ::dan::Str* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_record_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::insert_record(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Str* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_record_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Str>* DANInterface::Stub::Asyncinsert_recordRaw(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Str>::Create(channel_.get(), cq, rpcmethod_insert_record_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Str>* DANInterface::Stub::PrepareAsyncinsert_recordRaw(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Str>::Create(channel_.get(), cq, rpcmethod_insert_record_, context, request, false);
}

::grpc::Status DANInterface::Stub::insert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_insert_record_batch_, context, request, response);
}

void DANInterface::Stub::experimental_async::insert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_record_batch_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_record_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_record_batch_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_record_batch_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::insert_record_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_record_batch_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncinsert_record_batchRaw(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_record_batch_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncinsert_record_batchRaw(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_record_batch_, context, request, false);
}

::grpc::Status DANInterface::Stub::import_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_import_vertex_, context, request, response);
}

void DANInterface::Stub::experimental_async::import_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_import_vertex_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::import_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_import_vertex_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::import_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_import_vertex_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::import_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_import_vertex_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncimport_vertexRaw(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_import_vertex_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncimport_vertexRaw(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_import_vertex_, context, request, false);
}

::grpc::Status DANInterface::Stub::insert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::dan::Long* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_insert_vertex_, context, request, response);
}

void DANInterface::Stub::experimental_async::insert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex* request, ::dan::Long* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_vertex_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_vertex_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_vertex_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::insert_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_vertex_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Long>* DANInterface::Stub::Asyncinsert_vertexRaw(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Long>::Create(channel_.get(), cq, rpcmethod_insert_vertex_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Long>* DANInterface::Stub::PrepareAsyncinsert_vertexRaw(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Long>::Create(channel_.get(), cq, rpcmethod_insert_vertex_, context, request, false);
}

::grpc::Status DANInterface::Stub::insert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_insert_vertex_batch_, context, request, response);
}

void DANInterface::Stub::experimental_async::insert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_vertex_batch_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_vertex_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_vertex_batch_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_vertex_batch_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::insert_vertex_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_vertex_batch_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncinsert_vertex_batchRaw(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_vertex_batch_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncinsert_vertex_batchRaw(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_vertex_batch_, context, request, false);
}

::grpc::Status DANInterface::Stub::import_edge(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_import_edge_, context, request, response);
}

void DANInterface::Stub::experimental_async::import_edge(::grpc::ClientContext* context, const ::dan::ImportEdge* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_import_edge_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::import_edge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_import_edge_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::import_edge(::grpc::ClientContext* context, const ::dan::ImportEdge* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_import_edge_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::import_edge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_import_edge_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncimport_edgeRaw(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_import_edge_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncimport_edgeRaw(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_import_edge_, context, request, false);
}

::grpc::Status DANInterface::Stub::insert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_insert_edge_, context, request, response);
}

void DANInterface::Stub::experimental_async::insert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_edge_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_edge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_edge_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_edge_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::insert_edge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_edge_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncinsert_edgeRaw(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_edge_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncinsert_edgeRaw(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_edge_, context, request, false);
}

::grpc::Status DANInterface::Stub::insert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_insert_edge_vp_, context, request, response);
}

void DANInterface::Stub::experimental_async::insert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_edge_vp_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_edge_vp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_edge_vp_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_edge_vp_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::insert_edge_vp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_edge_vp_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncinsert_edge_vpRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_edge_vp_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncinsert_edge_vpRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_edge_vp_, context, request, false);
}

::grpc::Status DANInterface::Stub::insert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_insert_edge_naive_, context, request, response);
}

void DANInterface::Stub::experimental_async::insert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_edge_naive_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_edge_naive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_edge_naive_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_edge_naive_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::insert_edge_naive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_edge_naive_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncinsert_edge_naiveRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_edge_naive_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncinsert_edge_naiveRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_edge_naive_, context, request, false);
}

::grpc::Status DANInterface::Stub::insert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_insert_edge_batch_, context, request, response);
}

void DANInterface::Stub::experimental_async::insert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_edge_batch_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_edge_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_edge_batch_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_edge_batch_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::insert_edge_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_edge_batch_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncinsert_edge_batchRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_edge_batch_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncinsert_edge_batchRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_edge_batch_, context, request, false);
}

::grpc::Status DANInterface::Stub::insert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_insert_edge_batch_vp_, context, request, response);
}

void DANInterface::Stub::experimental_async::insert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_edge_batch_vp_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_edge_batch_vp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_insert_edge_batch_vp_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::insert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_edge_batch_vp_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::insert_edge_batch_vp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_insert_edge_batch_vp_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncinsert_edge_batch_vpRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_edge_batch_vp_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncinsert_edge_batch_vpRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_insert_edge_batch_vp_, context, request, false);
}

::grpc::Status DANInterface::Stub::get_table_info(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::TableInfo* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_table_info_, context, request, response);
}

void DANInterface::Stub::experimental_async::get_table_info(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::TableInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_table_info_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::get_table_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::TableInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_table_info_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::get_table_info(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::TableInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_table_info_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::get_table_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::TableInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_table_info_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::TableInfo>* DANInterface::Stub::Asyncget_table_infoRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::TableInfo>::Create(channel_.get(), cq, rpcmethod_get_table_info_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::TableInfo>* DANInterface::Stub::PrepareAsyncget_table_infoRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::TableInfo>::Create(channel_.get(), cq, rpcmethod_get_table_info_, context, request, false);
}

::grpc::Status DANInterface::Stub::get_num_records(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Long* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_num_records_, context, request, response);
}

void DANInterface::Stub::experimental_async::get_num_records(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_num_records_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::get_num_records(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_num_records_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::get_num_records(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_num_records_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::get_num_records(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_num_records_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Long>* DANInterface::Stub::Asyncget_num_recordsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Long>::Create(channel_.get(), cq, rpcmethod_get_num_records_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Long>* DANInterface::Stub::PrepareAsyncget_num_recordsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Long>::Create(channel_.get(), cq, rpcmethod_get_num_records_, context, request, false);
}

::grpc::Status DANInterface::Stub::table_scan(::grpc::ClientContext* context, const ::dan::TableScan& request, ::dan::Table* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_table_scan_, context, request, response);
}

void DANInterface::Stub::experimental_async::table_scan(::grpc::ClientContext* context, const ::dan::TableScan* request, ::dan::Table* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_table_scan_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::table_scan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Table* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_table_scan_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::table_scan(::grpc::ClientContext* context, const ::dan::TableScan* request, ::dan::Table* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_table_scan_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::table_scan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Table* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_table_scan_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Table>* DANInterface::Stub::Asynctable_scanRaw(::grpc::ClientContext* context, const ::dan::TableScan& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Table>::Create(channel_.get(), cq, rpcmethod_table_scan_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Table>* DANInterface::Stub::PrepareAsynctable_scanRaw(::grpc::ClientContext* context, const ::dan::TableScan& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Table>::Create(channel_.get(), cq, rpcmethod_table_scan_, context, request, false);
}

::grpc::Status DANInterface::Stub::index_search(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::dan::Table* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_index_search_, context, request, response);
}

void DANInterface::Stub::experimental_async::index_search(::grpc::ClientContext* context, const ::dan::IndexSearch* request, ::dan::Table* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_index_search_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::index_search(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Table* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_index_search_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::index_search(::grpc::ClientContext* context, const ::dan::IndexSearch* request, ::dan::Table* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_index_search_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::index_search(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Table* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_index_search_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Table>* DANInterface::Stub::Asyncindex_searchRaw(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Table>::Create(channel_.get(), cq, rpcmethod_index_search_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Table>* DANInterface::Stub::PrepareAsyncindex_searchRaw(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Table>::Create(channel_.get(), cq, rpcmethod_index_search_, context, request, false);
}

::grpc::Status DANInterface::Stub::get_graph_info(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::GraphInfo* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_graph_info_, context, request, response);
}

void DANInterface::Stub::experimental_async::get_graph_info(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::GraphInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_graph_info_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::get_graph_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::GraphInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_graph_info_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::get_graph_info(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::GraphInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_graph_info_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::get_graph_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::GraphInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_graph_info_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::GraphInfo>* DANInterface::Stub::Asyncget_graph_infoRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::GraphInfo>::Create(channel_.get(), cq, rpcmethod_get_graph_info_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::GraphInfo>* DANInterface::Stub::PrepareAsyncget_graph_infoRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::GraphInfo>::Create(channel_.get(), cq, rpcmethod_get_graph_info_, context, request, false);
}

::grpc::Status DANInterface::Stub::get_num_vertex(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Long* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_num_vertex_, context, request, response);
}

void DANInterface::Stub::experimental_async::get_num_vertex(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_num_vertex_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::get_num_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_num_vertex_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::get_num_vertex(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_num_vertex_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::get_num_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_num_vertex_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Long>* DANInterface::Stub::Asyncget_num_vertexRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Long>::Create(channel_.get(), cq, rpcmethod_get_num_vertex_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Long>* DANInterface::Stub::PrepareAsyncget_num_vertexRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Long>::Create(channel_.get(), cq, rpcmethod_get_num_vertex_, context, request, false);
}

::grpc::Status DANInterface::Stub::get_num_edges(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Long* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_num_edges_, context, request, response);
}

void DANInterface::Stub::experimental_async::get_num_edges(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_num_edges_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::get_num_edges(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_num_edges_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::get_num_edges(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_num_edges_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::get_num_edges(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_num_edges_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Long>* DANInterface::Stub::Asyncget_num_edgesRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Long>::Create(channel_.get(), cq, rpcmethod_get_num_edges_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Long>* DANInterface::Stub::PrepareAsyncget_num_edgesRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Long>::Create(channel_.get(), cq, rpcmethod_get_num_edges_, context, request, false);
}

::grpc::Status DANInterface::Stub::adjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::dan::AdjacentListResult* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_adjacent_list_, context, request, response);
}

void DANInterface::Stub::experimental_async::adjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_adjacent_list_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::adjacent_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::AdjacentListResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_adjacent_list_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::adjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_adjacent_list_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::adjacent_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::AdjacentListResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_adjacent_list_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::AdjacentListResult>* DANInterface::Stub::Asyncadjacent_listRaw(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::AdjacentListResult>::Create(channel_.get(), cq, rpcmethod_adjacent_list_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::AdjacentListResult>* DANInterface::Stub::PrepareAsyncadjacent_listRaw(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::AdjacentListResult>::Create(channel_.get(), cq, rpcmethod_adjacent_list_, context, request, false);
}

::grpc::ClientReader< ::dan::EdgeList>* DANInterface::Stub::get_edge_listRaw(::grpc::ClientContext* context, const ::dan::Str& request) {
  return ::grpc::internal::ClientReaderFactory< ::dan::EdgeList>::Create(channel_.get(), rpcmethod_get_edge_list_, context, request);
}

void DANInterface::Stub::experimental_async::get_edge_list(::grpc::ClientContext* context, ::dan::Str* request, ::grpc::experimental::ClientReadReactor< ::dan::EdgeList>* reactor) {
  ::grpc::internal::ClientCallbackReaderFactory< ::dan::EdgeList>::Create(stub_->channel_.get(), stub_->rpcmethod_get_edge_list_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::dan::EdgeList>* DANInterface::Stub::Asyncget_edge_listRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc::internal::ClientAsyncReaderFactory< ::dan::EdgeList>::Create(channel_.get(), cq, rpcmethod_get_edge_list_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::dan::EdgeList>* DANInterface::Stub::PrepareAsyncget_edge_listRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncReaderFactory< ::dan::EdgeList>::Create(channel_.get(), cq, rpcmethod_get_edge_list_, context, request, false, nullptr);
}

::grpc::Status DANInterface::Stub::get_vertex(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::dan::Record* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_vertex_, context, request, response);
}

void DANInterface::Stub::experimental_async::get_vertex(::grpc::ClientContext* context, const ::dan::GetVertex* request, ::dan::Record* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_vertex_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::get_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Record* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_vertex_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::get_vertex(::grpc::ClientContext* context, const ::dan::GetVertex* request, ::dan::Record* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_vertex_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::get_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Record* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_vertex_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Record>* DANInterface::Stub::Asyncget_vertexRaw(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Record>::Create(channel_.get(), cq, rpcmethod_get_vertex_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Record>* DANInterface::Stub::PrepareAsyncget_vertexRaw(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Record>::Create(channel_.get(), cq, rpcmethod_get_vertex_, context, request, false);
}

::grpc::ClientReader< ::dan::VertexList>* DANInterface::Stub::get_vertex_listRaw(::grpc::ClientContext* context, const ::dan::Str& request) {
  return ::grpc::internal::ClientReaderFactory< ::dan::VertexList>::Create(channel_.get(), rpcmethod_get_vertex_list_, context, request);
}

void DANInterface::Stub::experimental_async::get_vertex_list(::grpc::ClientContext* context, ::dan::Str* request, ::grpc::experimental::ClientReadReactor< ::dan::VertexList>* reactor) {
  ::grpc::internal::ClientCallbackReaderFactory< ::dan::VertexList>::Create(stub_->channel_.get(), stub_->rpcmethod_get_vertex_list_, context, request, reactor);
}

::grpc::ClientAsyncReader< ::dan::VertexList>* DANInterface::Stub::Asyncget_vertex_listRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc::internal::ClientAsyncReaderFactory< ::dan::VertexList>::Create(channel_.get(), cq, rpcmethod_get_vertex_list_, context, request, true, tag);
}

::grpc::ClientAsyncReader< ::dan::VertexList>* DANInterface::Stub::PrepareAsyncget_vertex_listRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncReaderFactory< ::dan::VertexList>::Create(channel_.get(), cq, rpcmethod_get_vertex_list_, context, request, false, nullptr);
}

::grpc::Status DANInterface::Stub::vertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_vertex_exists_, context, request, response);
}

void DANInterface::Stub::experimental_async::vertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_vertex_exists_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::vertex_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_vertex_exists_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::vertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_vertex_exists_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::vertex_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_vertex_exists_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncvertex_existsRaw(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_vertex_exists_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncvertex_existsRaw(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_vertex_exists_, context, request, false);
}

::grpc::Status DANInterface::Stub::remote_task(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::dan::RemoteResult* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_remote_task_, context, request, response);
}

void DANInterface::Stub::experimental_async::remote_task(::grpc::ClientContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_remote_task_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::remote_task(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_remote_task_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::remote_task(::grpc::ClientContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_remote_task_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::remote_task(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_remote_task_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* DANInterface::Stub::Asyncremote_taskRaw(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::RemoteResult>::Create(channel_.get(), cq, rpcmethod_remote_task_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* DANInterface::Stub::PrepareAsyncremote_taskRaw(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::RemoteResult>::Create(channel_.get(), cq, rpcmethod_remote_task_, context, request, false);
}

::grpc::Status DANInterface::Stub::remote_object(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::dan::RemoteResult* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_remote_object_, context, request, response);
}

void DANInterface::Stub::experimental_async::remote_object(::grpc::ClientContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_remote_object_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::remote_object(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_remote_object_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::remote_object(::grpc::ClientContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_remote_object_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::remote_object(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_remote_object_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* DANInterface::Stub::Asyncremote_objectRaw(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::RemoteResult>::Create(channel_.get(), cq, rpcmethod_remote_object_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* DANInterface::Stub::PrepareAsyncremote_objectRaw(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::RemoteResult>::Create(channel_.get(), cq, rpcmethod_remote_object_, context, request, false);
}

::grpc::Status DANInterface::Stub::remove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_remove_remote_object_, context, request, response);
}

void DANInterface::Stub::experimental_async::remove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_remove_remote_object_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::remove_remote_object(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_remove_remote_object_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::remove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_remove_remote_object_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::remove_remote_object(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_remove_remote_object_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncremove_remote_objectRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_remove_remote_object_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncremove_remote_objectRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_remove_remote_object_, context, request, false);
}

::grpc::Status DANInterface::Stub::remote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::dan::RemoteResult* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_remote_object_task_, context, request, response);
}

void DANInterface::Stub::experimental_async::remote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_remote_object_task_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::remote_object_task(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_remote_object_task_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::remote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_remote_object_task_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::remote_object_task(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_remote_object_task_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* DANInterface::Stub::Asyncremote_object_taskRaw(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::RemoteResult>::Create(channel_.get(), cq, rpcmethod_remote_object_task_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* DANInterface::Stub::PrepareAsyncremote_object_taskRaw(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::RemoteResult>::Create(channel_.get(), cq, rpcmethod_remote_object_task_, context, request, false);
}

::grpc::Status DANInterface::Stub::remote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::dan::RemoteResult* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_remote_task_result_, context, request, response);
}

void DANInterface::Stub::experimental_async::remote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_remote_task_result_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::remote_task_result(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_remote_task_result_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::remote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_remote_task_result_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::remote_task_result(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_remote_task_result_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* DANInterface::Stub::Asyncremote_task_resultRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::RemoteResult>::Create(channel_.get(), cq, rpcmethod_remote_task_result_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* DANInterface::Stub::PrepareAsyncremote_task_resultRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::RemoteResult>::Create(channel_.get(), cq, rpcmethod_remote_task_result_, context, request, false);
}

::grpc::Status DANInterface::Stub::remove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_remove_task_result_, context, request, response);
}

void DANInterface::Stub::experimental_async::remove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_remove_task_result_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::remove_task_result(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_remove_task_result_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::remove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_remove_task_result_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::remove_task_result(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_remove_task_result_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncremove_task_resultRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_remove_task_result_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncremove_task_resultRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_remove_task_result_, context, request, false);
}

::grpc::Status DANInterface::Stub::load_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_load_graph_from_folder_, context, request, response);
}

void DANInterface::Stub::experimental_async::load_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_load_graph_from_folder_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::load_graph_from_folder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_load_graph_from_folder_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::load_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_load_graph_from_folder_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::load_graph_from_folder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_load_graph_from_folder_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asyncload_graph_from_folderRaw(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_load_graph_from_folder_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsyncload_graph_from_folderRaw(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_load_graph_from_folder_, context, request, false);
}

::grpc::Status DANInterface::Stub::train_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::dan::Code* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_train_node_classifier_, context, request, response);
}

void DANInterface::Stub::experimental_async::train_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_train_node_classifier_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::train_node_classifier(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_train_node_classifier_, context, request, response, std::move(f));
}

void DANInterface::Stub::experimental_async::train_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_train_node_classifier_, context, request, response, reactor);
}

void DANInterface::Stub::experimental_async::train_node_classifier(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_train_node_classifier_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::Asynctrain_node_classifierRaw(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_train_node_classifier_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::dan::Code>* DANInterface::Stub::PrepareAsynctrain_node_classifierRaw(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::dan::Code>::Create(channel_.get(), cq, rpcmethod_train_node_classifier_, context, request, false);
}

DANInterface::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Void, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::ping), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[1],
      ::grpc::internal::RpcMethod::CLIENT_STREAMING,
      new ::grpc::internal::ClientStreamingHandler< DANInterface::Service, ::dan::TestStream, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::test_stream), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::TestStream, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::test_multiunary), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::DoubleVec, ::dan::DoubleVec>(
          std::mem_fn(&DANInterface::Service::test_size), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::archive), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::recover), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Void, ::dan::NodeInfoVec>(
          std::mem_fn(&DANInterface::Service::request_node_list), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::request_register_node), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Void, ::dan::HostInfo>(
          std::mem_fn(&DANInterface::Service::request_socket), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::MemoryStat, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::memory_statistics), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::CreateTable, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::create_table), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::drop_table), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::drop_table_if_exists), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::StrVec, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::load_table), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::CreateIndex, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::create_index), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::TablePartition, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::table_partition), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[16],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::set_partition), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[17],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::CreateGraph, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::create_graph), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[18],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::drop_graph), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[19],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::drop_graph_if_exists), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[20],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::DefineVertex, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::define_vertex), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[21],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::GraphPartition, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::graph_partition), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[22],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::MergeInfo, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::graph_merge), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[23],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::TransferBinary, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::transfer_data), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[24],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::InsertRecord, ::dan::Str>(
          std::mem_fn(&DANInterface::Service::insert_record), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[25],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::InsertRecordBatch, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::insert_record_batch), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[26],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::ImportVertex, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::import_vertex), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[27],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::InsertVertex, ::dan::Long>(
          std::mem_fn(&DANInterface::Service::insert_vertex), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[28],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::InsertVertexBatch, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::insert_vertex_batch), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[29],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::ImportEdge, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::import_edge), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[30],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::InsertEdge, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::insert_edge), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[31],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::InsertEdgeVP, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::insert_edge_vp), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[32],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::InsertEdgeNaive, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::insert_edge_naive), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[33],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::InsertEdgeBatch, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::insert_edge_batch), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[34],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::InsertEdgeBatchVP, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::insert_edge_batch_vp), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[35],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::TableInfo>(
          std::mem_fn(&DANInterface::Service::get_table_info), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[36],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::Long>(
          std::mem_fn(&DANInterface::Service::get_num_records), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[37],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::TableScan, ::dan::Table>(
          std::mem_fn(&DANInterface::Service::table_scan), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[38],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::IndexSearch, ::dan::Table>(
          std::mem_fn(&DANInterface::Service::index_search), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[39],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::GraphInfo>(
          std::mem_fn(&DANInterface::Service::get_graph_info), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[40],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::Long>(
          std::mem_fn(&DANInterface::Service::get_num_vertex), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[41],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::Str, ::dan::Long>(
          std::mem_fn(&DANInterface::Service::get_num_edges), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[42],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::AdjacentList, ::dan::AdjacentListResult>(
          std::mem_fn(&DANInterface::Service::adjacent_list), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[43],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< DANInterface::Service, ::dan::Str, ::dan::EdgeList>(
          std::mem_fn(&DANInterface::Service::get_edge_list), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[44],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::GetVertex, ::dan::Record>(
          std::mem_fn(&DANInterface::Service::get_vertex), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[45],
      ::grpc::internal::RpcMethod::SERVER_STREAMING,
      new ::grpc::internal::ServerStreamingHandler< DANInterface::Service, ::dan::Str, ::dan::VertexList>(
          std::mem_fn(&DANInterface::Service::get_vertex_list), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[46],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::VertexExists, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::vertex_exists), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[47],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::RemoteTask, ::dan::RemoteResult>(
          std::mem_fn(&DANInterface::Service::remote_task), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[48],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::RemoteObject, ::dan::RemoteResult>(
          std::mem_fn(&DANInterface::Service::remote_object), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[49],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::RemoteTaskResult, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::remove_remote_object), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[50],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::RemoteObjectTask, ::dan::RemoteResult>(
          std::mem_fn(&DANInterface::Service::remote_object_task), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[51],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::RemoteTaskResult, ::dan::RemoteResult>(
          std::mem_fn(&DANInterface::Service::remote_task_result), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[52],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::RemoteTaskResult, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::remove_task_result), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[53],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::LoadGraphFromFolder, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::load_graph_from_folder), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DANInterface_method_names[54],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DANInterface::Service, ::dan::NodeClassifierInfo, ::dan::Code>(
          std::mem_fn(&DANInterface::Service::train_node_classifier), this)));
}

DANInterface::Service::~Service() {
}

::grpc::Status DANInterface::Service::ping(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::test_stream(::grpc::ServerContext* context, ::grpc::ServerReader< ::dan::TestStream>* reader, ::dan::Code* response) {
  (void) context;
  (void) reader;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::test_multiunary(::grpc::ServerContext* context, const ::dan::TestStream* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::test_size(::grpc::ServerContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::archive(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::recover(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::request_node_list(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::request_register_node(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::request_socket(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::HostInfo* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::memory_statistics(::grpc::ServerContext* context, const ::dan::MemoryStat* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::create_table(::grpc::ServerContext* context, const ::dan::CreateTable* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::drop_table(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::drop_table_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::load_table(::grpc::ServerContext* context, const ::dan::StrVec* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::create_index(::grpc::ServerContext* context, const ::dan::CreateIndex* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::table_partition(::grpc::ServerContext* context, const ::dan::TablePartition* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::set_partition(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::create_graph(::grpc::ServerContext* context, const ::dan::CreateGraph* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::drop_graph(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::drop_graph_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::define_vertex(::grpc::ServerContext* context, const ::dan::DefineVertex* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::graph_partition(::grpc::ServerContext* context, const ::dan::GraphPartition* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::graph_merge(::grpc::ServerContext* context, const ::dan::MergeInfo* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::transfer_data(::grpc::ServerContext* context, const ::dan::TransferBinary* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::insert_record(::grpc::ServerContext* context, const ::dan::InsertRecord* request, ::dan::Str* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::insert_record_batch(::grpc::ServerContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::import_vertex(::grpc::ServerContext* context, const ::dan::ImportVertex* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::insert_vertex(::grpc::ServerContext* context, const ::dan::InsertVertex* request, ::dan::Long* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::insert_vertex_batch(::grpc::ServerContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::import_edge(::grpc::ServerContext* context, const ::dan::ImportEdge* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::insert_edge(::grpc::ServerContext* context, const ::dan::InsertEdge* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::insert_edge_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::insert_edge_naive(::grpc::ServerContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::insert_edge_batch(::grpc::ServerContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::insert_edge_batch_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::get_table_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::TableInfo* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::get_num_records(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::table_scan(::grpc::ServerContext* context, const ::dan::TableScan* request, ::dan::Table* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::index_search(::grpc::ServerContext* context, const ::dan::IndexSearch* request, ::dan::Table* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::get_graph_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::GraphInfo* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::get_num_vertex(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::get_num_edges(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::adjacent_list(::grpc::ServerContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::get_edge_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::EdgeList>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::get_vertex(::grpc::ServerContext* context, const ::dan::GetVertex* request, ::dan::Record* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::get_vertex_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::VertexList>* writer) {
  (void) context;
  (void) request;
  (void) writer;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::vertex_exists(::grpc::ServerContext* context, const ::dan::VertexExists* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::remote_task(::grpc::ServerContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::remote_object(::grpc::ServerContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::remove_remote_object(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::remote_object_task(::grpc::ServerContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::remote_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::remove_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::load_graph_from_folder(::grpc::ServerContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DANInterface::Service::train_node_classifier(::grpc::ServerContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace dan

