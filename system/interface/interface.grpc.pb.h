// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: interface.proto
// Original file comments:
// Copyright 2020 PIDL(Petabyte-scale In-memory Database Lab) http://kdb.snu.ac.kr
//
#ifndef GRPC_interface_2eproto__INCLUDED
#define GRPC_interface_2eproto__INCLUDED

#include "interface.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class CompletionQueue;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc

namespace dan {

class DANInterface final {
 public:
  static constexpr char const* service_full_name() {
    return "dan.DANInterface";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // system API
    virtual ::grpc::Status ping(::grpc::ClientContext* context, const ::dan::Void& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncping(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(AsyncpingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncping(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncpingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriterInterface< ::dan::TestStream>> test_stream(::grpc::ClientContext* context, ::dan::Code* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::dan::TestStream>>(test_streamRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::dan::TestStream>> Asynctest_stream(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::dan::TestStream>>(Asynctest_streamRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::dan::TestStream>> PrepareAsynctest_stream(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::dan::TestStream>>(PrepareAsynctest_streamRaw(context, response, cq));
    }
    virtual ::grpc::Status test_multiunary(::grpc::ClientContext* context, const ::dan::TestStream& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asynctest_multiunary(::grpc::ClientContext* context, const ::dan::TestStream& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asynctest_multiunaryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsynctest_multiunary(::grpc::ClientContext* context, const ::dan::TestStream& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsynctest_multiunaryRaw(context, request, cq));
    }
    virtual ::grpc::Status test_size(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::dan::DoubleVec* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::DoubleVec>> Asynctest_size(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::DoubleVec>>(Asynctest_sizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::DoubleVec>> PrepareAsynctest_size(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::DoubleVec>>(PrepareAsynctest_sizeRaw(context, request, cq));
    }
    virtual ::grpc::Status archive(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncarchive(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(AsyncarchiveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncarchive(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncarchiveRaw(context, request, cq));
    }
    virtual ::grpc::Status recover(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncrecover(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(AsyncrecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncrecover(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncrecoverRaw(context, request, cq));
    }
    virtual ::grpc::Status request_node_list(::grpc::ClientContext* context, const ::dan::Void& request, ::dan::NodeInfoVec* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::NodeInfoVec>> Asyncrequest_node_list(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::NodeInfoVec>>(Asyncrequest_node_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::NodeInfoVec>> PrepareAsyncrequest_node_list(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::NodeInfoVec>>(PrepareAsyncrequest_node_listRaw(context, request, cq));
    }
    virtual ::grpc::Status request_register_node(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncrequest_register_node(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncrequest_register_nodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncrequest_register_node(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncrequest_register_nodeRaw(context, request, cq));
    }
    virtual ::grpc::Status request_socket(::grpc::ClientContext* context, const ::dan::Void& request, ::dan::HostInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::HostInfo>> Asyncrequest_socket(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::HostInfo>>(Asyncrequest_socketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::HostInfo>> PrepareAsyncrequest_socket(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::HostInfo>>(PrepareAsyncrequest_socketRaw(context, request, cq));
    }
    virtual ::grpc::Status memory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncmemory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncmemory_statisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncmemory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncmemory_statisticsRaw(context, request, cq));
    }
    // ddl API
    virtual ::grpc::Status create_table(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asynccreate_table(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asynccreate_tableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsynccreate_table(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsynccreate_tableRaw(context, request, cq));
    }
    virtual ::grpc::Status drop_table(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncdrop_table(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncdrop_tableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncdrop_table(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncdrop_tableRaw(context, request, cq));
    }
    virtual ::grpc::Status drop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncdrop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncdrop_table_if_existsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncdrop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncdrop_table_if_existsRaw(context, request, cq));
    }
    virtual ::grpc::Status load_table(::grpc::ClientContext* context, const ::dan::StrVec& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncload_table(::grpc::ClientContext* context, const ::dan::StrVec& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncload_tableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncload_table(::grpc::ClientContext* context, const ::dan::StrVec& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncload_tableRaw(context, request, cq));
    }
    virtual ::grpc::Status create_index(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asynccreate_index(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asynccreate_indexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsynccreate_index(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsynccreate_indexRaw(context, request, cq));
    }
    virtual ::grpc::Status table_partition(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asynctable_partition(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asynctable_partitionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsynctable_partition(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsynctable_partitionRaw(context, request, cq));
    }
    virtual ::grpc::Status set_partition(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncset_partition(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncset_partitionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncset_partition(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncset_partitionRaw(context, request, cq));
    }
    virtual ::grpc::Status create_graph(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asynccreate_graph(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asynccreate_graphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsynccreate_graph(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsynccreate_graphRaw(context, request, cq));
    }
    virtual ::grpc::Status drop_graph(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncdrop_graph(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncdrop_graphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncdrop_graph(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncdrop_graphRaw(context, request, cq));
    }
    virtual ::grpc::Status drop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncdrop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncdrop_graph_if_existsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncdrop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncdrop_graph_if_existsRaw(context, request, cq));
    }
    virtual ::grpc::Status define_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncdefine_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncdefine_vertexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncdefine_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncdefine_vertexRaw(context, request, cq));
    }
    virtual ::grpc::Status graph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncgraph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncgraph_partitionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncgraph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncgraph_partitionRaw(context, request, cq));
    }
    virtual ::grpc::Status graph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncgraph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncgraph_mergeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncgraph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncgraph_mergeRaw(context, request, cq));
    }
    virtual ::grpc::Status transfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asynctransfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asynctransfer_dataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsynctransfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsynctransfer_dataRaw(context, request, cq));
    }
    // dml API
    virtual ::grpc::Status insert_record(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::dan::Str* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Str>> Asyncinsert_record(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Str>>(Asyncinsert_recordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Str>> PrepareAsyncinsert_record(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Str>>(PrepareAsyncinsert_recordRaw(context, request, cq));
    }
    virtual ::grpc::Status insert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncinsert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncinsert_record_batchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncinsert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncinsert_record_batchRaw(context, request, cq));
    }
    virtual ::grpc::Status import_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncimport_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncimport_vertexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncimport_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncimport_vertexRaw(context, request, cq));
    }
    virtual ::grpc::Status insert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::dan::Long* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>> Asyncinsert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>>(Asyncinsert_vertexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>> PrepareAsyncinsert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>>(PrepareAsyncinsert_vertexRaw(context, request, cq));
    }
    virtual ::grpc::Status insert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncinsert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncinsert_vertex_batchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncinsert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncinsert_vertex_batchRaw(context, request, cq));
    }
    virtual ::grpc::Status import_edge(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncimport_edge(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncimport_edgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncimport_edge(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncimport_edgeRaw(context, request, cq));
    }
    virtual ::grpc::Status insert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncinsert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncinsert_edgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncinsert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncinsert_edgeRaw(context, request, cq));
    }
    virtual ::grpc::Status insert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncinsert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncinsert_edge_vpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncinsert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncinsert_edge_vpRaw(context, request, cq));
    }
    virtual ::grpc::Status insert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncinsert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncinsert_edge_naiveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncinsert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncinsert_edge_naiveRaw(context, request, cq));
    }
    virtual ::grpc::Status insert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncinsert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncinsert_edge_batchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncinsert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncinsert_edge_batchRaw(context, request, cq));
    }
    virtual ::grpc::Status insert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncinsert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncinsert_edge_batch_vpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncinsert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncinsert_edge_batch_vpRaw(context, request, cq));
    }
    virtual ::grpc::Status get_table_info(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::TableInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::TableInfo>> Asyncget_table_info(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::TableInfo>>(Asyncget_table_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::TableInfo>> PrepareAsyncget_table_info(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::TableInfo>>(PrepareAsyncget_table_infoRaw(context, request, cq));
    }
    virtual ::grpc::Status get_num_records(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Long* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>> Asyncget_num_records(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>>(Asyncget_num_recordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>> PrepareAsyncget_num_records(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>>(PrepareAsyncget_num_recordsRaw(context, request, cq));
    }
    virtual ::grpc::Status table_scan(::grpc::ClientContext* context, const ::dan::TableScan& request, ::dan::Table* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Table>> Asynctable_scan(::grpc::ClientContext* context, const ::dan::TableScan& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Table>>(Asynctable_scanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Table>> PrepareAsynctable_scan(::grpc::ClientContext* context, const ::dan::TableScan& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Table>>(PrepareAsynctable_scanRaw(context, request, cq));
    }
    virtual ::grpc::Status index_search(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::dan::Table* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Table>> Asyncindex_search(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Table>>(Asyncindex_searchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Table>> PrepareAsyncindex_search(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Table>>(PrepareAsyncindex_searchRaw(context, request, cq));
    }
    virtual ::grpc::Status get_graph_info(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::GraphInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::GraphInfo>> Asyncget_graph_info(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::GraphInfo>>(Asyncget_graph_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::GraphInfo>> PrepareAsyncget_graph_info(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::GraphInfo>>(PrepareAsyncget_graph_infoRaw(context, request, cq));
    }
    virtual ::grpc::Status get_num_vertex(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Long* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>> Asyncget_num_vertex(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>>(Asyncget_num_vertexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>> PrepareAsyncget_num_vertex(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>>(PrepareAsyncget_num_vertexRaw(context, request, cq));
    }
    virtual ::grpc::Status get_num_edges(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Long* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>> Asyncget_num_edges(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>>(Asyncget_num_edgesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>> PrepareAsyncget_num_edges(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>>(PrepareAsyncget_num_edgesRaw(context, request, cq));
    }
    virtual ::grpc::Status adjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::dan::AdjacentListResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::AdjacentListResult>> Asyncadjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::AdjacentListResult>>(Asyncadjacent_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::AdjacentListResult>> PrepareAsyncadjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::AdjacentListResult>>(PrepareAsyncadjacent_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::dan::EdgeList>> get_edge_list(::grpc::ClientContext* context, const ::dan::Str& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::dan::EdgeList>>(get_edge_listRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::dan::EdgeList>> Asyncget_edge_list(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::dan::EdgeList>>(Asyncget_edge_listRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::dan::EdgeList>> PrepareAsyncget_edge_list(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::dan::EdgeList>>(PrepareAsyncget_edge_listRaw(context, request, cq));
    }
    virtual ::grpc::Status get_vertex(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::dan::Record* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Record>> Asyncget_vertex(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Record>>(Asyncget_vertexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Record>> PrepareAsyncget_vertex(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Record>>(PrepareAsyncget_vertexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::dan::VertexList>> get_vertex_list(::grpc::ClientContext* context, const ::dan::Str& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::dan::VertexList>>(get_vertex_listRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::dan::VertexList>> Asyncget_vertex_list(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::dan::VertexList>>(Asyncget_vertex_listRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::dan::VertexList>> PrepareAsyncget_vertex_list(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::dan::VertexList>>(PrepareAsyncget_vertex_listRaw(context, request, cq));
    }
    virtual ::grpc::Status vertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncvertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncvertex_existsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncvertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncvertex_existsRaw(context, request, cq));
    }
    // remote execution
    virtual ::grpc::Status remote_task(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::dan::RemoteResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>> Asyncremote_task(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>>(Asyncremote_taskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>> PrepareAsyncremote_task(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>>(PrepareAsyncremote_taskRaw(context, request, cq));
    }
    virtual ::grpc::Status remote_object(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::dan::RemoteResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>> Asyncremote_object(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>>(Asyncremote_objectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>> PrepareAsyncremote_object(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>>(PrepareAsyncremote_objectRaw(context, request, cq));
    }
    virtual ::grpc::Status remove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncremove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncremove_remote_objectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncremove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncremove_remote_objectRaw(context, request, cq));
    }
    virtual ::grpc::Status remote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::dan::RemoteResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>> Asyncremote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>>(Asyncremote_object_taskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>> PrepareAsyncremote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>>(PrepareAsyncremote_object_taskRaw(context, request, cq));
    }
    virtual ::grpc::Status remote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::dan::RemoteResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>> Asyncremote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>>(Asyncremote_task_resultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>> PrepareAsyncremote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>>(PrepareAsyncremote_task_resultRaw(context, request, cq));
    }
    virtual ::grpc::Status remove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncremove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncremove_task_resultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncremove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncremove_task_resultRaw(context, request, cq));
    }
    virtual ::grpc::Status load_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asyncload_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asyncload_graph_from_folderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsyncload_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsyncload_graph_from_folderRaw(context, request, cq));
    }
    virtual ::grpc::Status train_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::dan::Code* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> Asynctrain_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(Asynctrain_node_classifierRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>> PrepareAsynctrain_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>>(PrepareAsynctrain_node_classifierRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // system API
      virtual void ping(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ping(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ping(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ping(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void test_stream(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::experimental::ClientWriteReactor< ::dan::TestStream>* reactor) = 0;
      virtual void test_multiunary(::grpc::ClientContext* context, const ::dan::TestStream* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void test_multiunary(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void test_multiunary(::grpc::ClientContext* context, const ::dan::TestStream* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void test_multiunary(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void test_size(::grpc::ClientContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response, std::function<void(::grpc::Status)>) = 0;
      virtual void test_size(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::DoubleVec* response, std::function<void(::grpc::Status)>) = 0;
      virtual void test_size(::grpc::ClientContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void test_size(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::DoubleVec* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void archive(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void archive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void archive(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void archive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void recover(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void recover(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void request_node_list(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response, std::function<void(::grpc::Status)>) = 0;
      virtual void request_node_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::NodeInfoVec* response, std::function<void(::grpc::Status)>) = 0;
      virtual void request_node_list(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void request_node_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::NodeInfoVec* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void request_register_node(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void request_register_node(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void request_register_node(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void request_register_node(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void request_socket(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::HostInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void request_socket(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::HostInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void request_socket(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::HostInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void request_socket(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::HostInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void memory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void memory_statistics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void memory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void memory_statistics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // ddl API
      virtual void create_table(::grpc::ClientContext* context, const ::dan::CreateTable* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void create_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void create_table(::grpc::ClientContext* context, const ::dan::CreateTable* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void create_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void drop_table(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void drop_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void drop_table(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void drop_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void drop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void drop_table_if_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void drop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void drop_table_if_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void load_table(::grpc::ClientContext* context, const ::dan::StrVec* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void load_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void load_table(::grpc::ClientContext* context, const ::dan::StrVec* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void load_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void create_index(::grpc::ClientContext* context, const ::dan::CreateIndex* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void create_index(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void create_index(::grpc::ClientContext* context, const ::dan::CreateIndex* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void create_index(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void table_partition(::grpc::ClientContext* context, const ::dan::TablePartition* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void table_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void table_partition(::grpc::ClientContext* context, const ::dan::TablePartition* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void table_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void set_partition(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_partition(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void set_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void create_graph(::grpc::ClientContext* context, const ::dan::CreateGraph* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void create_graph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void create_graph(::grpc::ClientContext* context, const ::dan::CreateGraph* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void create_graph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void drop_graph(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void drop_graph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void drop_graph(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void drop_graph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void drop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void drop_graph_if_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void drop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void drop_graph_if_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void define_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void define_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void define_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void define_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void graph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void graph_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void graph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void graph_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void graph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void graph_merge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void graph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void graph_merge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void transfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void transfer_data(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void transfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void transfer_data(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // dml API
      virtual void insert_record(::grpc::ClientContext* context, const ::dan::InsertRecord* request, ::dan::Str* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_record(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Str* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_record(::grpc::ClientContext* context, const ::dan::InsertRecord* request, ::dan::Str* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_record(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Str* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_record_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_record_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void import_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void import_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void import_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void import_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex* request, ::dan::Long* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_vertex_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_vertex_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void import_edge(::grpc::ClientContext* context, const ::dan::ImportEdge* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void import_edge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void import_edge(::grpc::ClientContext* context, const ::dan::ImportEdge* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void import_edge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_edge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_edge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_edge_vp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_edge_vp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_edge_naive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_edge_naive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_edge_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_edge_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_edge_batch_vp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void insert_edge_batch_vp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_table_info(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::TableInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_table_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::TableInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_table_info(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::TableInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_table_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::TableInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_num_records(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_num_records(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_num_records(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_num_records(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void table_scan(::grpc::ClientContext* context, const ::dan::TableScan* request, ::dan::Table* response, std::function<void(::grpc::Status)>) = 0;
      virtual void table_scan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Table* response, std::function<void(::grpc::Status)>) = 0;
      virtual void table_scan(::grpc::ClientContext* context, const ::dan::TableScan* request, ::dan::Table* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void table_scan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Table* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void index_search(::grpc::ClientContext* context, const ::dan::IndexSearch* request, ::dan::Table* response, std::function<void(::grpc::Status)>) = 0;
      virtual void index_search(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Table* response, std::function<void(::grpc::Status)>) = 0;
      virtual void index_search(::grpc::ClientContext* context, const ::dan::IndexSearch* request, ::dan::Table* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void index_search(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Table* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_graph_info(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::GraphInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_graph_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::GraphInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_graph_info(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::GraphInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_graph_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::GraphInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_num_vertex(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_num_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_num_vertex(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_num_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_num_edges(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_num_edges(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_num_edges(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_num_edges(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void adjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void adjacent_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::AdjacentListResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void adjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void adjacent_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::AdjacentListResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_edge_list(::grpc::ClientContext* context, ::dan::Str* request, ::grpc::experimental::ClientReadReactor< ::dan::EdgeList>* reactor) = 0;
      virtual void get_vertex(::grpc::ClientContext* context, const ::dan::GetVertex* request, ::dan::Record* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Record* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_vertex(::grpc::ClientContext* context, const ::dan::GetVertex* request, ::dan::Record* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Record* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void get_vertex_list(::grpc::ClientContext* context, ::dan::Str* request, ::grpc::experimental::ClientReadReactor< ::dan::VertexList>* reactor) = 0;
      virtual void vertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void vertex_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void vertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void vertex_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // remote execution
      virtual void remote_task(::grpc::ClientContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remote_task(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remote_task(::grpc::ClientContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void remote_task(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void remote_object(::grpc::ClientContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remote_object(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remote_object(::grpc::ClientContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void remote_object(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void remove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remove_remote_object(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void remove_remote_object(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void remote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remote_object_task(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void remote_object_task(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void remote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remote_task_result(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void remote_task_result(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void remove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remove_task_result(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void remove_task_result(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void load_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void load_graph_from_folder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void load_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void load_graph_from_folder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void train_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void train_node_classifier(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) = 0;
      virtual void train_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void train_node_classifier(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* AsyncpingRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncpingRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::dan::TestStream>* test_streamRaw(::grpc::ClientContext* context, ::dan::Code* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::dan::TestStream>* Asynctest_streamRaw(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::dan::TestStream>* PrepareAsynctest_streamRaw(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asynctest_multiunaryRaw(::grpc::ClientContext* context, const ::dan::TestStream& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsynctest_multiunaryRaw(::grpc::ClientContext* context, const ::dan::TestStream& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::DoubleVec>* Asynctest_sizeRaw(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::DoubleVec>* PrepareAsynctest_sizeRaw(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* AsyncarchiveRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncarchiveRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* AsyncrecoverRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncrecoverRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::NodeInfoVec>* Asyncrequest_node_listRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::NodeInfoVec>* PrepareAsyncrequest_node_listRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncrequest_register_nodeRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncrequest_register_nodeRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::HostInfo>* Asyncrequest_socketRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::HostInfo>* PrepareAsyncrequest_socketRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncmemory_statisticsRaw(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncmemory_statisticsRaw(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asynccreate_tableRaw(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsynccreate_tableRaw(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncdrop_tableRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncdrop_tableRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncdrop_table_if_existsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncdrop_table_if_existsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncload_tableRaw(::grpc::ClientContext* context, const ::dan::StrVec& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncload_tableRaw(::grpc::ClientContext* context, const ::dan::StrVec& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asynccreate_indexRaw(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsynccreate_indexRaw(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asynctable_partitionRaw(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsynctable_partitionRaw(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncset_partitionRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncset_partitionRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asynccreate_graphRaw(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsynccreate_graphRaw(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncdrop_graphRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncdrop_graphRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncdrop_graph_if_existsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncdrop_graph_if_existsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncdefine_vertexRaw(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncdefine_vertexRaw(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncgraph_partitionRaw(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncgraph_partitionRaw(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncgraph_mergeRaw(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncgraph_mergeRaw(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asynctransfer_dataRaw(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsynctransfer_dataRaw(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Str>* Asyncinsert_recordRaw(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Str>* PrepareAsyncinsert_recordRaw(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncinsert_record_batchRaw(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncinsert_record_batchRaw(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncimport_vertexRaw(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncimport_vertexRaw(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>* Asyncinsert_vertexRaw(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>* PrepareAsyncinsert_vertexRaw(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncinsert_vertex_batchRaw(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncinsert_vertex_batchRaw(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncimport_edgeRaw(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncimport_edgeRaw(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncinsert_edgeRaw(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncinsert_edgeRaw(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncinsert_edge_vpRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncinsert_edge_vpRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncinsert_edge_naiveRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncinsert_edge_naiveRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncinsert_edge_batchRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncinsert_edge_batchRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncinsert_edge_batch_vpRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncinsert_edge_batch_vpRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::TableInfo>* Asyncget_table_infoRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::TableInfo>* PrepareAsyncget_table_infoRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>* Asyncget_num_recordsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>* PrepareAsyncget_num_recordsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Table>* Asynctable_scanRaw(::grpc::ClientContext* context, const ::dan::TableScan& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Table>* PrepareAsynctable_scanRaw(::grpc::ClientContext* context, const ::dan::TableScan& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Table>* Asyncindex_searchRaw(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Table>* PrepareAsyncindex_searchRaw(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::GraphInfo>* Asyncget_graph_infoRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::GraphInfo>* PrepareAsyncget_graph_infoRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>* Asyncget_num_vertexRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>* PrepareAsyncget_num_vertexRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>* Asyncget_num_edgesRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Long>* PrepareAsyncget_num_edgesRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::AdjacentListResult>* Asyncadjacent_listRaw(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::AdjacentListResult>* PrepareAsyncadjacent_listRaw(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::dan::EdgeList>* get_edge_listRaw(::grpc::ClientContext* context, const ::dan::Str& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::dan::EdgeList>* Asyncget_edge_listRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::dan::EdgeList>* PrepareAsyncget_edge_listRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Record>* Asyncget_vertexRaw(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Record>* PrepareAsyncget_vertexRaw(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::dan::VertexList>* get_vertex_listRaw(::grpc::ClientContext* context, const ::dan::Str& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::dan::VertexList>* Asyncget_vertex_listRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::dan::VertexList>* PrepareAsyncget_vertex_listRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncvertex_existsRaw(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncvertex_existsRaw(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>* Asyncremote_taskRaw(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>* PrepareAsyncremote_taskRaw(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>* Asyncremote_objectRaw(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>* PrepareAsyncremote_objectRaw(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncremove_remote_objectRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncremove_remote_objectRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>* Asyncremote_object_taskRaw(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>* PrepareAsyncremote_object_taskRaw(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>* Asyncremote_task_resultRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::RemoteResult>* PrepareAsyncremote_task_resultRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncremove_task_resultRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncremove_task_resultRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asyncload_graph_from_folderRaw(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsyncload_graph_from_folderRaw(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* Asynctrain_node_classifierRaw(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dan::Code>* PrepareAsynctrain_node_classifierRaw(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status ping(::grpc::ClientContext* context, const ::dan::Void& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncping(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(AsyncpingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncping(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncpingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::dan::TestStream>> test_stream(::grpc::ClientContext* context, ::dan::Code* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::dan::TestStream>>(test_streamRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::dan::TestStream>> Asynctest_stream(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::dan::TestStream>>(Asynctest_streamRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::dan::TestStream>> PrepareAsynctest_stream(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::dan::TestStream>>(PrepareAsynctest_streamRaw(context, response, cq));
    }
    ::grpc::Status test_multiunary(::grpc::ClientContext* context, const ::dan::TestStream& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asynctest_multiunary(::grpc::ClientContext* context, const ::dan::TestStream& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asynctest_multiunaryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsynctest_multiunary(::grpc::ClientContext* context, const ::dan::TestStream& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsynctest_multiunaryRaw(context, request, cq));
    }
    ::grpc::Status test_size(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::dan::DoubleVec* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::DoubleVec>> Asynctest_size(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::DoubleVec>>(Asynctest_sizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::DoubleVec>> PrepareAsynctest_size(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::DoubleVec>>(PrepareAsynctest_sizeRaw(context, request, cq));
    }
    ::grpc::Status archive(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncarchive(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(AsyncarchiveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncarchive(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncarchiveRaw(context, request, cq));
    }
    ::grpc::Status recover(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncrecover(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(AsyncrecoverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncrecover(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncrecoverRaw(context, request, cq));
    }
    ::grpc::Status request_node_list(::grpc::ClientContext* context, const ::dan::Void& request, ::dan::NodeInfoVec* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::NodeInfoVec>> Asyncrequest_node_list(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::NodeInfoVec>>(Asyncrequest_node_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::NodeInfoVec>> PrepareAsyncrequest_node_list(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::NodeInfoVec>>(PrepareAsyncrequest_node_listRaw(context, request, cq));
    }
    ::grpc::Status request_register_node(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncrequest_register_node(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncrequest_register_nodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncrequest_register_node(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncrequest_register_nodeRaw(context, request, cq));
    }
    ::grpc::Status request_socket(::grpc::ClientContext* context, const ::dan::Void& request, ::dan::HostInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::HostInfo>> Asyncrequest_socket(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::HostInfo>>(Asyncrequest_socketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::HostInfo>> PrepareAsyncrequest_socket(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::HostInfo>>(PrepareAsyncrequest_socketRaw(context, request, cq));
    }
    ::grpc::Status memory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncmemory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncmemory_statisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncmemory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncmemory_statisticsRaw(context, request, cq));
    }
    ::grpc::Status create_table(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asynccreate_table(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asynccreate_tableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsynccreate_table(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsynccreate_tableRaw(context, request, cq));
    }
    ::grpc::Status drop_table(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncdrop_table(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncdrop_tableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncdrop_table(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncdrop_tableRaw(context, request, cq));
    }
    ::grpc::Status drop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncdrop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncdrop_table_if_existsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncdrop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncdrop_table_if_existsRaw(context, request, cq));
    }
    ::grpc::Status load_table(::grpc::ClientContext* context, const ::dan::StrVec& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncload_table(::grpc::ClientContext* context, const ::dan::StrVec& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncload_tableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncload_table(::grpc::ClientContext* context, const ::dan::StrVec& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncload_tableRaw(context, request, cq));
    }
    ::grpc::Status create_index(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asynccreate_index(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asynccreate_indexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsynccreate_index(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsynccreate_indexRaw(context, request, cq));
    }
    ::grpc::Status table_partition(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asynctable_partition(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asynctable_partitionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsynctable_partition(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsynctable_partitionRaw(context, request, cq));
    }
    ::grpc::Status set_partition(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncset_partition(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncset_partitionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncset_partition(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncset_partitionRaw(context, request, cq));
    }
    ::grpc::Status create_graph(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asynccreate_graph(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asynccreate_graphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsynccreate_graph(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsynccreate_graphRaw(context, request, cq));
    }
    ::grpc::Status drop_graph(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncdrop_graph(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncdrop_graphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncdrop_graph(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncdrop_graphRaw(context, request, cq));
    }
    ::grpc::Status drop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncdrop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncdrop_graph_if_existsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncdrop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncdrop_graph_if_existsRaw(context, request, cq));
    }
    ::grpc::Status define_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncdefine_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncdefine_vertexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncdefine_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncdefine_vertexRaw(context, request, cq));
    }
    ::grpc::Status graph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncgraph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncgraph_partitionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncgraph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncgraph_partitionRaw(context, request, cq));
    }
    ::grpc::Status graph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncgraph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncgraph_mergeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncgraph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncgraph_mergeRaw(context, request, cq));
    }
    ::grpc::Status transfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asynctransfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asynctransfer_dataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsynctransfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsynctransfer_dataRaw(context, request, cq));
    }
    ::grpc::Status insert_record(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::dan::Str* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Str>> Asyncinsert_record(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Str>>(Asyncinsert_recordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Str>> PrepareAsyncinsert_record(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Str>>(PrepareAsyncinsert_recordRaw(context, request, cq));
    }
    ::grpc::Status insert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncinsert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncinsert_record_batchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncinsert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncinsert_record_batchRaw(context, request, cq));
    }
    ::grpc::Status import_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncimport_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncimport_vertexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncimport_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncimport_vertexRaw(context, request, cq));
    }
    ::grpc::Status insert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::dan::Long* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>> Asyncinsert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>>(Asyncinsert_vertexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>> PrepareAsyncinsert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>>(PrepareAsyncinsert_vertexRaw(context, request, cq));
    }
    ::grpc::Status insert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncinsert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncinsert_vertex_batchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncinsert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncinsert_vertex_batchRaw(context, request, cq));
    }
    ::grpc::Status import_edge(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncimport_edge(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncimport_edgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncimport_edge(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncimport_edgeRaw(context, request, cq));
    }
    ::grpc::Status insert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncinsert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncinsert_edgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncinsert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncinsert_edgeRaw(context, request, cq));
    }
    ::grpc::Status insert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncinsert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncinsert_edge_vpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncinsert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncinsert_edge_vpRaw(context, request, cq));
    }
    ::grpc::Status insert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncinsert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncinsert_edge_naiveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncinsert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncinsert_edge_naiveRaw(context, request, cq));
    }
    ::grpc::Status insert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncinsert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncinsert_edge_batchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncinsert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncinsert_edge_batchRaw(context, request, cq));
    }
    ::grpc::Status insert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncinsert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncinsert_edge_batch_vpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncinsert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncinsert_edge_batch_vpRaw(context, request, cq));
    }
    ::grpc::Status get_table_info(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::TableInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::TableInfo>> Asyncget_table_info(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::TableInfo>>(Asyncget_table_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::TableInfo>> PrepareAsyncget_table_info(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::TableInfo>>(PrepareAsyncget_table_infoRaw(context, request, cq));
    }
    ::grpc::Status get_num_records(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Long* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>> Asyncget_num_records(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>>(Asyncget_num_recordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>> PrepareAsyncget_num_records(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>>(PrepareAsyncget_num_recordsRaw(context, request, cq));
    }
    ::grpc::Status table_scan(::grpc::ClientContext* context, const ::dan::TableScan& request, ::dan::Table* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Table>> Asynctable_scan(::grpc::ClientContext* context, const ::dan::TableScan& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Table>>(Asynctable_scanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Table>> PrepareAsynctable_scan(::grpc::ClientContext* context, const ::dan::TableScan& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Table>>(PrepareAsynctable_scanRaw(context, request, cq));
    }
    ::grpc::Status index_search(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::dan::Table* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Table>> Asyncindex_search(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Table>>(Asyncindex_searchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Table>> PrepareAsyncindex_search(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Table>>(PrepareAsyncindex_searchRaw(context, request, cq));
    }
    ::grpc::Status get_graph_info(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::GraphInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::GraphInfo>> Asyncget_graph_info(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::GraphInfo>>(Asyncget_graph_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::GraphInfo>> PrepareAsyncget_graph_info(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::GraphInfo>>(PrepareAsyncget_graph_infoRaw(context, request, cq));
    }
    ::grpc::Status get_num_vertex(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Long* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>> Asyncget_num_vertex(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>>(Asyncget_num_vertexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>> PrepareAsyncget_num_vertex(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>>(PrepareAsyncget_num_vertexRaw(context, request, cq));
    }
    ::grpc::Status get_num_edges(::grpc::ClientContext* context, const ::dan::Str& request, ::dan::Long* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>> Asyncget_num_edges(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>>(Asyncget_num_edgesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>> PrepareAsyncget_num_edges(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Long>>(PrepareAsyncget_num_edgesRaw(context, request, cq));
    }
    ::grpc::Status adjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::dan::AdjacentListResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::AdjacentListResult>> Asyncadjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::AdjacentListResult>>(Asyncadjacent_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::AdjacentListResult>> PrepareAsyncadjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::AdjacentListResult>>(PrepareAsyncadjacent_listRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::dan::EdgeList>> get_edge_list(::grpc::ClientContext* context, const ::dan::Str& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::dan::EdgeList>>(get_edge_listRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::dan::EdgeList>> Asyncget_edge_list(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::dan::EdgeList>>(Asyncget_edge_listRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::dan::EdgeList>> PrepareAsyncget_edge_list(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::dan::EdgeList>>(PrepareAsyncget_edge_listRaw(context, request, cq));
    }
    ::grpc::Status get_vertex(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::dan::Record* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Record>> Asyncget_vertex(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Record>>(Asyncget_vertexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Record>> PrepareAsyncget_vertex(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Record>>(PrepareAsyncget_vertexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::dan::VertexList>> get_vertex_list(::grpc::ClientContext* context, const ::dan::Str& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::dan::VertexList>>(get_vertex_listRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::dan::VertexList>> Asyncget_vertex_list(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::dan::VertexList>>(Asyncget_vertex_listRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::dan::VertexList>> PrepareAsyncget_vertex_list(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::dan::VertexList>>(PrepareAsyncget_vertex_listRaw(context, request, cq));
    }
    ::grpc::Status vertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncvertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncvertex_existsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncvertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncvertex_existsRaw(context, request, cq));
    }
    ::grpc::Status remote_task(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::dan::RemoteResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>> Asyncremote_task(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>>(Asyncremote_taskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>> PrepareAsyncremote_task(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>>(PrepareAsyncremote_taskRaw(context, request, cq));
    }
    ::grpc::Status remote_object(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::dan::RemoteResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>> Asyncremote_object(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>>(Asyncremote_objectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>> PrepareAsyncremote_object(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>>(PrepareAsyncremote_objectRaw(context, request, cq));
    }
    ::grpc::Status remove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncremove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncremove_remote_objectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncremove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncremove_remote_objectRaw(context, request, cq));
    }
    ::grpc::Status remote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::dan::RemoteResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>> Asyncremote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>>(Asyncremote_object_taskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>> PrepareAsyncremote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>>(PrepareAsyncremote_object_taskRaw(context, request, cq));
    }
    ::grpc::Status remote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::dan::RemoteResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>> Asyncremote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>>(Asyncremote_task_resultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>> PrepareAsyncremote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>>(PrepareAsyncremote_task_resultRaw(context, request, cq));
    }
    ::grpc::Status remove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncremove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncremove_task_resultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncremove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncremove_task_resultRaw(context, request, cq));
    }
    ::grpc::Status load_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asyncload_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asyncload_graph_from_folderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsyncload_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsyncload_graph_from_folderRaw(context, request, cq));
    }
    ::grpc::Status train_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::dan::Code* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> Asynctrain_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(Asynctrain_node_classifierRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>> PrepareAsynctrain_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dan::Code>>(PrepareAsynctrain_node_classifierRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void ping(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void ping(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void ping(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ping(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void test_stream(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::experimental::ClientWriteReactor< ::dan::TestStream>* reactor) override;
      void test_multiunary(::grpc::ClientContext* context, const ::dan::TestStream* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void test_multiunary(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void test_multiunary(::grpc::ClientContext* context, const ::dan::TestStream* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void test_multiunary(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void test_size(::grpc::ClientContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response, std::function<void(::grpc::Status)>) override;
      void test_size(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::DoubleVec* response, std::function<void(::grpc::Status)>) override;
      void test_size(::grpc::ClientContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void test_size(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::DoubleVec* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void archive(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void archive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void archive(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void archive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void recover(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void recover(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void recover(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void request_node_list(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response, std::function<void(::grpc::Status)>) override;
      void request_node_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::NodeInfoVec* response, std::function<void(::grpc::Status)>) override;
      void request_node_list(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void request_node_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::NodeInfoVec* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void request_register_node(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void request_register_node(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void request_register_node(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void request_register_node(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void request_socket(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::HostInfo* response, std::function<void(::grpc::Status)>) override;
      void request_socket(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::HostInfo* response, std::function<void(::grpc::Status)>) override;
      void request_socket(::grpc::ClientContext* context, const ::dan::Void* request, ::dan::HostInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void request_socket(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::HostInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void memory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void memory_statistics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void memory_statistics(::grpc::ClientContext* context, const ::dan::MemoryStat* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void memory_statistics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void create_table(::grpc::ClientContext* context, const ::dan::CreateTable* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void create_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void create_table(::grpc::ClientContext* context, const ::dan::CreateTable* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void create_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void drop_table(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void drop_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void drop_table(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void drop_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void drop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void drop_table_if_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void drop_table_if_exists(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void drop_table_if_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void load_table(::grpc::ClientContext* context, const ::dan::StrVec* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void load_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void load_table(::grpc::ClientContext* context, const ::dan::StrVec* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void load_table(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void create_index(::grpc::ClientContext* context, const ::dan::CreateIndex* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void create_index(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void create_index(::grpc::ClientContext* context, const ::dan::CreateIndex* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void create_index(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void table_partition(::grpc::ClientContext* context, const ::dan::TablePartition* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void table_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void table_partition(::grpc::ClientContext* context, const ::dan::TablePartition* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void table_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void set_partition(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void set_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void set_partition(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void set_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void create_graph(::grpc::ClientContext* context, const ::dan::CreateGraph* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void create_graph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void create_graph(::grpc::ClientContext* context, const ::dan::CreateGraph* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void create_graph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void drop_graph(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void drop_graph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void drop_graph(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void drop_graph(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void drop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void drop_graph_if_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void drop_graph_if_exists(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void drop_graph_if_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void define_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void define_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void define_vertex(::grpc::ClientContext* context, const ::dan::DefineVertex* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void define_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void graph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void graph_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void graph_partition(::grpc::ClientContext* context, const ::dan::GraphPartition* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void graph_partition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void graph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void graph_merge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void graph_merge(::grpc::ClientContext* context, const ::dan::MergeInfo* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void graph_merge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void transfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void transfer_data(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void transfer_data(::grpc::ClientContext* context, const ::dan::TransferBinary* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void transfer_data(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_record(::grpc::ClientContext* context, const ::dan::InsertRecord* request, ::dan::Str* response, std::function<void(::grpc::Status)>) override;
      void insert_record(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Str* response, std::function<void(::grpc::Status)>) override;
      void insert_record(::grpc::ClientContext* context, const ::dan::InsertRecord* request, ::dan::Str* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_record(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Str* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_record_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_record_batch(::grpc::ClientContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_record_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void import_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void import_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void import_vertex(::grpc::ClientContext* context, const ::dan::ImportVertex* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void import_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex* request, ::dan::Long* response, std::function<void(::grpc::Status)>) override;
      void insert_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, std::function<void(::grpc::Status)>) override;
      void insert_vertex(::grpc::ClientContext* context, const ::dan::InsertVertex* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_vertex_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_vertex_batch(::grpc::ClientContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_vertex_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void import_edge(::grpc::ClientContext* context, const ::dan::ImportEdge* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void import_edge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void import_edge(::grpc::ClientContext* context, const ::dan::ImportEdge* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void import_edge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_edge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_edge(::grpc::ClientContext* context, const ::dan::InsertEdge* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_edge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_edge_vp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_edge_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_edge_vp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_edge_naive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_edge_naive(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_edge_naive(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_edge_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_edge_batch(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_edge_batch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_edge_batch_vp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void insert_edge_batch_vp(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void insert_edge_batch_vp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_table_info(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::TableInfo* response, std::function<void(::grpc::Status)>) override;
      void get_table_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::TableInfo* response, std::function<void(::grpc::Status)>) override;
      void get_table_info(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::TableInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_table_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::TableInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_num_records(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, std::function<void(::grpc::Status)>) override;
      void get_num_records(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, std::function<void(::grpc::Status)>) override;
      void get_num_records(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_num_records(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void table_scan(::grpc::ClientContext* context, const ::dan::TableScan* request, ::dan::Table* response, std::function<void(::grpc::Status)>) override;
      void table_scan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Table* response, std::function<void(::grpc::Status)>) override;
      void table_scan(::grpc::ClientContext* context, const ::dan::TableScan* request, ::dan::Table* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void table_scan(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Table* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void index_search(::grpc::ClientContext* context, const ::dan::IndexSearch* request, ::dan::Table* response, std::function<void(::grpc::Status)>) override;
      void index_search(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Table* response, std::function<void(::grpc::Status)>) override;
      void index_search(::grpc::ClientContext* context, const ::dan::IndexSearch* request, ::dan::Table* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void index_search(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Table* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_graph_info(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::GraphInfo* response, std::function<void(::grpc::Status)>) override;
      void get_graph_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::GraphInfo* response, std::function<void(::grpc::Status)>) override;
      void get_graph_info(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::GraphInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_graph_info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::GraphInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_num_vertex(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, std::function<void(::grpc::Status)>) override;
      void get_num_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, std::function<void(::grpc::Status)>) override;
      void get_num_vertex(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_num_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_num_edges(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, std::function<void(::grpc::Status)>) override;
      void get_num_edges(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, std::function<void(::grpc::Status)>) override;
      void get_num_edges(::grpc::ClientContext* context, const ::dan::Str* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_num_edges(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Long* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void adjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response, std::function<void(::grpc::Status)>) override;
      void adjacent_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::AdjacentListResult* response, std::function<void(::grpc::Status)>) override;
      void adjacent_list(::grpc::ClientContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void adjacent_list(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::AdjacentListResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_edge_list(::grpc::ClientContext* context, ::dan::Str* request, ::grpc::experimental::ClientReadReactor< ::dan::EdgeList>* reactor) override;
      void get_vertex(::grpc::ClientContext* context, const ::dan::GetVertex* request, ::dan::Record* response, std::function<void(::grpc::Status)>) override;
      void get_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Record* response, std::function<void(::grpc::Status)>) override;
      void get_vertex(::grpc::ClientContext* context, const ::dan::GetVertex* request, ::dan::Record* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_vertex(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Record* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void get_vertex_list(::grpc::ClientContext* context, ::dan::Str* request, ::grpc::experimental::ClientReadReactor< ::dan::VertexList>* reactor) override;
      void vertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void vertex_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void vertex_exists(::grpc::ClientContext* context, const ::dan::VertexExists* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void vertex_exists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void remote_task(::grpc::ClientContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) override;
      void remote_task(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) override;
      void remote_task(::grpc::ClientContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void remote_task(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void remote_object(::grpc::ClientContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) override;
      void remote_object(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) override;
      void remote_object(::grpc::ClientContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void remote_object(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void remove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void remove_remote_object(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void remove_remote_object(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void remove_remote_object(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void remote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) override;
      void remote_object_task(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) override;
      void remote_object_task(::grpc::ClientContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void remote_object_task(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void remote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) override;
      void remote_task_result(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, std::function<void(::grpc::Status)>) override;
      void remote_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void remote_task_result(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::RemoteResult* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void remove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void remove_task_result(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void remove_task_result(::grpc::ClientContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void remove_task_result(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void load_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void load_graph_from_folder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void load_graph_from_folder(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void load_graph_from_folder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void train_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void train_node_classifier(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, std::function<void(::grpc::Status)>) override;
      void train_node_classifier(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void train_node_classifier(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dan::Code* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* AsyncpingRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncpingRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::dan::TestStream>* test_streamRaw(::grpc::ClientContext* context, ::dan::Code* response) override;
    ::grpc::ClientAsyncWriter< ::dan::TestStream>* Asynctest_streamRaw(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::dan::TestStream>* PrepareAsynctest_streamRaw(::grpc::ClientContext* context, ::dan::Code* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asynctest_multiunaryRaw(::grpc::ClientContext* context, const ::dan::TestStream& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsynctest_multiunaryRaw(::grpc::ClientContext* context, const ::dan::TestStream& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::DoubleVec>* Asynctest_sizeRaw(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::DoubleVec>* PrepareAsynctest_sizeRaw(::grpc::ClientContext* context, const ::dan::DoubleVec& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* AsyncarchiveRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncarchiveRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* AsyncrecoverRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncrecoverRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::NodeInfoVec>* Asyncrequest_node_listRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::NodeInfoVec>* PrepareAsyncrequest_node_listRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncrequest_register_nodeRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncrequest_register_nodeRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::HostInfo>* Asyncrequest_socketRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::HostInfo>* PrepareAsyncrequest_socketRaw(::grpc::ClientContext* context, const ::dan::Void& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncmemory_statisticsRaw(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncmemory_statisticsRaw(::grpc::ClientContext* context, const ::dan::MemoryStat& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asynccreate_tableRaw(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsynccreate_tableRaw(::grpc::ClientContext* context, const ::dan::CreateTable& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncdrop_tableRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncdrop_tableRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncdrop_table_if_existsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncdrop_table_if_existsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncload_tableRaw(::grpc::ClientContext* context, const ::dan::StrVec& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncload_tableRaw(::grpc::ClientContext* context, const ::dan::StrVec& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asynccreate_indexRaw(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsynccreate_indexRaw(::grpc::ClientContext* context, const ::dan::CreateIndex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asynctable_partitionRaw(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsynctable_partitionRaw(::grpc::ClientContext* context, const ::dan::TablePartition& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncset_partitionRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncset_partitionRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asynccreate_graphRaw(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsynccreate_graphRaw(::grpc::ClientContext* context, const ::dan::CreateGraph& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncdrop_graphRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncdrop_graphRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncdrop_graph_if_existsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncdrop_graph_if_existsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncdefine_vertexRaw(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncdefine_vertexRaw(::grpc::ClientContext* context, const ::dan::DefineVertex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncgraph_partitionRaw(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncgraph_partitionRaw(::grpc::ClientContext* context, const ::dan::GraphPartition& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncgraph_mergeRaw(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncgraph_mergeRaw(::grpc::ClientContext* context, const ::dan::MergeInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asynctransfer_dataRaw(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsynctransfer_dataRaw(::grpc::ClientContext* context, const ::dan::TransferBinary& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Str>* Asyncinsert_recordRaw(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Str>* PrepareAsyncinsert_recordRaw(::grpc::ClientContext* context, const ::dan::InsertRecord& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncinsert_record_batchRaw(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncinsert_record_batchRaw(::grpc::ClientContext* context, const ::dan::InsertRecordBatch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncimport_vertexRaw(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncimport_vertexRaw(::grpc::ClientContext* context, const ::dan::ImportVertex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Long>* Asyncinsert_vertexRaw(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Long>* PrepareAsyncinsert_vertexRaw(::grpc::ClientContext* context, const ::dan::InsertVertex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncinsert_vertex_batchRaw(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncinsert_vertex_batchRaw(::grpc::ClientContext* context, const ::dan::InsertVertexBatch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncimport_edgeRaw(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncimport_edgeRaw(::grpc::ClientContext* context, const ::dan::ImportEdge& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncinsert_edgeRaw(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncinsert_edgeRaw(::grpc::ClientContext* context, const ::dan::InsertEdge& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncinsert_edge_vpRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncinsert_edge_vpRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeVP& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncinsert_edge_naiveRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncinsert_edge_naiveRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeNaive& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncinsert_edge_batchRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncinsert_edge_batchRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeBatch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncinsert_edge_batch_vpRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncinsert_edge_batch_vpRaw(::grpc::ClientContext* context, const ::dan::InsertEdgeBatchVP& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::TableInfo>* Asyncget_table_infoRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::TableInfo>* PrepareAsyncget_table_infoRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Long>* Asyncget_num_recordsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Long>* PrepareAsyncget_num_recordsRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Table>* Asynctable_scanRaw(::grpc::ClientContext* context, const ::dan::TableScan& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Table>* PrepareAsynctable_scanRaw(::grpc::ClientContext* context, const ::dan::TableScan& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Table>* Asyncindex_searchRaw(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Table>* PrepareAsyncindex_searchRaw(::grpc::ClientContext* context, const ::dan::IndexSearch& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::GraphInfo>* Asyncget_graph_infoRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::GraphInfo>* PrepareAsyncget_graph_infoRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Long>* Asyncget_num_vertexRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Long>* PrepareAsyncget_num_vertexRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Long>* Asyncget_num_edgesRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Long>* PrepareAsyncget_num_edgesRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::AdjacentListResult>* Asyncadjacent_listRaw(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::AdjacentListResult>* PrepareAsyncadjacent_listRaw(::grpc::ClientContext* context, const ::dan::AdjacentList& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::dan::EdgeList>* get_edge_listRaw(::grpc::ClientContext* context, const ::dan::Str& request) override;
    ::grpc::ClientAsyncReader< ::dan::EdgeList>* Asyncget_edge_listRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::dan::EdgeList>* PrepareAsyncget_edge_listRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Record>* Asyncget_vertexRaw(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Record>* PrepareAsyncget_vertexRaw(::grpc::ClientContext* context, const ::dan::GetVertex& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::dan::VertexList>* get_vertex_listRaw(::grpc::ClientContext* context, const ::dan::Str& request) override;
    ::grpc::ClientAsyncReader< ::dan::VertexList>* Asyncget_vertex_listRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::dan::VertexList>* PrepareAsyncget_vertex_listRaw(::grpc::ClientContext* context, const ::dan::Str& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncvertex_existsRaw(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncvertex_existsRaw(::grpc::ClientContext* context, const ::dan::VertexExists& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* Asyncremote_taskRaw(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* PrepareAsyncremote_taskRaw(::grpc::ClientContext* context, const ::dan::RemoteTask& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* Asyncremote_objectRaw(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* PrepareAsyncremote_objectRaw(::grpc::ClientContext* context, const ::dan::RemoteObject& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncremove_remote_objectRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncremove_remote_objectRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* Asyncremote_object_taskRaw(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* PrepareAsyncremote_object_taskRaw(::grpc::ClientContext* context, const ::dan::RemoteObjectTask& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* Asyncremote_task_resultRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::RemoteResult>* PrepareAsyncremote_task_resultRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncremove_task_resultRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncremove_task_resultRaw(::grpc::ClientContext* context, const ::dan::RemoteTaskResult& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asyncload_graph_from_folderRaw(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsyncload_graph_from_folderRaw(::grpc::ClientContext* context, const ::dan::LoadGraphFromFolder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* Asynctrain_node_classifierRaw(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dan::Code>* PrepareAsynctrain_node_classifierRaw(::grpc::ClientContext* context, const ::dan::NodeClassifierInfo& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ping_;
    const ::grpc::internal::RpcMethod rpcmethod_test_stream_;
    const ::grpc::internal::RpcMethod rpcmethod_test_multiunary_;
    const ::grpc::internal::RpcMethod rpcmethod_test_size_;
    const ::grpc::internal::RpcMethod rpcmethod_archive_;
    const ::grpc::internal::RpcMethod rpcmethod_recover_;
    const ::grpc::internal::RpcMethod rpcmethod_request_node_list_;
    const ::grpc::internal::RpcMethod rpcmethod_request_register_node_;
    const ::grpc::internal::RpcMethod rpcmethod_request_socket_;
    const ::grpc::internal::RpcMethod rpcmethod_memory_statistics_;
    const ::grpc::internal::RpcMethod rpcmethod_create_table_;
    const ::grpc::internal::RpcMethod rpcmethod_drop_table_;
    const ::grpc::internal::RpcMethod rpcmethod_drop_table_if_exists_;
    const ::grpc::internal::RpcMethod rpcmethod_load_table_;
    const ::grpc::internal::RpcMethod rpcmethod_create_index_;
    const ::grpc::internal::RpcMethod rpcmethod_table_partition_;
    const ::grpc::internal::RpcMethod rpcmethod_set_partition_;
    const ::grpc::internal::RpcMethod rpcmethod_create_graph_;
    const ::grpc::internal::RpcMethod rpcmethod_drop_graph_;
    const ::grpc::internal::RpcMethod rpcmethod_drop_graph_if_exists_;
    const ::grpc::internal::RpcMethod rpcmethod_define_vertex_;
    const ::grpc::internal::RpcMethod rpcmethod_graph_partition_;
    const ::grpc::internal::RpcMethod rpcmethod_graph_merge_;
    const ::grpc::internal::RpcMethod rpcmethod_transfer_data_;
    const ::grpc::internal::RpcMethod rpcmethod_insert_record_;
    const ::grpc::internal::RpcMethod rpcmethod_insert_record_batch_;
    const ::grpc::internal::RpcMethod rpcmethod_import_vertex_;
    const ::grpc::internal::RpcMethod rpcmethod_insert_vertex_;
    const ::grpc::internal::RpcMethod rpcmethod_insert_vertex_batch_;
    const ::grpc::internal::RpcMethod rpcmethod_import_edge_;
    const ::grpc::internal::RpcMethod rpcmethod_insert_edge_;
    const ::grpc::internal::RpcMethod rpcmethod_insert_edge_vp_;
    const ::grpc::internal::RpcMethod rpcmethod_insert_edge_naive_;
    const ::grpc::internal::RpcMethod rpcmethod_insert_edge_batch_;
    const ::grpc::internal::RpcMethod rpcmethod_insert_edge_batch_vp_;
    const ::grpc::internal::RpcMethod rpcmethod_get_table_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_num_records_;
    const ::grpc::internal::RpcMethod rpcmethod_table_scan_;
    const ::grpc::internal::RpcMethod rpcmethod_index_search_;
    const ::grpc::internal::RpcMethod rpcmethod_get_graph_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_num_vertex_;
    const ::grpc::internal::RpcMethod rpcmethod_get_num_edges_;
    const ::grpc::internal::RpcMethod rpcmethod_adjacent_list_;
    const ::grpc::internal::RpcMethod rpcmethod_get_edge_list_;
    const ::grpc::internal::RpcMethod rpcmethod_get_vertex_;
    const ::grpc::internal::RpcMethod rpcmethod_get_vertex_list_;
    const ::grpc::internal::RpcMethod rpcmethod_vertex_exists_;
    const ::grpc::internal::RpcMethod rpcmethod_remote_task_;
    const ::grpc::internal::RpcMethod rpcmethod_remote_object_;
    const ::grpc::internal::RpcMethod rpcmethod_remove_remote_object_;
    const ::grpc::internal::RpcMethod rpcmethod_remote_object_task_;
    const ::grpc::internal::RpcMethod rpcmethod_remote_task_result_;
    const ::grpc::internal::RpcMethod rpcmethod_remove_task_result_;
    const ::grpc::internal::RpcMethod rpcmethod_load_graph_from_folder_;
    const ::grpc::internal::RpcMethod rpcmethod_train_node_classifier_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // system API
    virtual ::grpc::Status ping(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::Code* response);
    virtual ::grpc::Status test_stream(::grpc::ServerContext* context, ::grpc::ServerReader< ::dan::TestStream>* reader, ::dan::Code* response);
    virtual ::grpc::Status test_multiunary(::grpc::ServerContext* context, const ::dan::TestStream* request, ::dan::Code* response);
    virtual ::grpc::Status test_size(::grpc::ServerContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response);
    virtual ::grpc::Status archive(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response);
    virtual ::grpc::Status recover(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response);
    virtual ::grpc::Status request_node_list(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response);
    virtual ::grpc::Status request_register_node(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response);
    virtual ::grpc::Status request_socket(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::HostInfo* response);
    virtual ::grpc::Status memory_statistics(::grpc::ServerContext* context, const ::dan::MemoryStat* request, ::dan::Code* response);
    // ddl API
    virtual ::grpc::Status create_table(::grpc::ServerContext* context, const ::dan::CreateTable* request, ::dan::Code* response);
    virtual ::grpc::Status drop_table(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response);
    virtual ::grpc::Status drop_table_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response);
    virtual ::grpc::Status load_table(::grpc::ServerContext* context, const ::dan::StrVec* request, ::dan::Code* response);
    virtual ::grpc::Status create_index(::grpc::ServerContext* context, const ::dan::CreateIndex* request, ::dan::Code* response);
    virtual ::grpc::Status table_partition(::grpc::ServerContext* context, const ::dan::TablePartition* request, ::dan::Code* response);
    virtual ::grpc::Status set_partition(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response);
    virtual ::grpc::Status create_graph(::grpc::ServerContext* context, const ::dan::CreateGraph* request, ::dan::Code* response);
    virtual ::grpc::Status drop_graph(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response);
    virtual ::grpc::Status drop_graph_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response);
    virtual ::grpc::Status define_vertex(::grpc::ServerContext* context, const ::dan::DefineVertex* request, ::dan::Code* response);
    virtual ::grpc::Status graph_partition(::grpc::ServerContext* context, const ::dan::GraphPartition* request, ::dan::Code* response);
    virtual ::grpc::Status graph_merge(::grpc::ServerContext* context, const ::dan::MergeInfo* request, ::dan::Code* response);
    virtual ::grpc::Status transfer_data(::grpc::ServerContext* context, const ::dan::TransferBinary* request, ::dan::Code* response);
    // dml API
    virtual ::grpc::Status insert_record(::grpc::ServerContext* context, const ::dan::InsertRecord* request, ::dan::Str* response);
    virtual ::grpc::Status insert_record_batch(::grpc::ServerContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response);
    virtual ::grpc::Status import_vertex(::grpc::ServerContext* context, const ::dan::ImportVertex* request, ::dan::Code* response);
    virtual ::grpc::Status insert_vertex(::grpc::ServerContext* context, const ::dan::InsertVertex* request, ::dan::Long* response);
    virtual ::grpc::Status insert_vertex_batch(::grpc::ServerContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response);
    virtual ::grpc::Status import_edge(::grpc::ServerContext* context, const ::dan::ImportEdge* request, ::dan::Code* response);
    virtual ::grpc::Status insert_edge(::grpc::ServerContext* context, const ::dan::InsertEdge* request, ::dan::Code* response);
    virtual ::grpc::Status insert_edge_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response);
    virtual ::grpc::Status insert_edge_naive(::grpc::ServerContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response);
    virtual ::grpc::Status insert_edge_batch(::grpc::ServerContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response);
    virtual ::grpc::Status insert_edge_batch_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response);
    virtual ::grpc::Status get_table_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::TableInfo* response);
    virtual ::grpc::Status get_num_records(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response);
    virtual ::grpc::Status table_scan(::grpc::ServerContext* context, const ::dan::TableScan* request, ::dan::Table* response);
    virtual ::grpc::Status index_search(::grpc::ServerContext* context, const ::dan::IndexSearch* request, ::dan::Table* response);
    virtual ::grpc::Status get_graph_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::GraphInfo* response);
    virtual ::grpc::Status get_num_vertex(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response);
    virtual ::grpc::Status get_num_edges(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response);
    virtual ::grpc::Status adjacent_list(::grpc::ServerContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response);
    virtual ::grpc::Status get_edge_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::EdgeList>* writer);
    virtual ::grpc::Status get_vertex(::grpc::ServerContext* context, const ::dan::GetVertex* request, ::dan::Record* response);
    virtual ::grpc::Status get_vertex_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::VertexList>* writer);
    virtual ::grpc::Status vertex_exists(::grpc::ServerContext* context, const ::dan::VertexExists* request, ::dan::Code* response);
    // remote execution
    virtual ::grpc::Status remote_task(::grpc::ServerContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response);
    virtual ::grpc::Status remote_object(::grpc::ServerContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response);
    virtual ::grpc::Status remove_remote_object(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response);
    virtual ::grpc::Status remote_object_task(::grpc::ServerContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response);
    virtual ::grpc::Status remote_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response);
    virtual ::grpc::Status remove_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response);
    virtual ::grpc::Status load_graph_from_folder(::grpc::ServerContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response);
    virtual ::grpc::Status train_node_classifier(::grpc::ServerContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ping() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ping(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestping(::grpc::ServerContext* context, ::dan::Void* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_test_stream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_test_stream() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_test_stream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_stream(::grpc::ServerContext* context, ::grpc::ServerReader< ::dan::TestStream>* reader, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttest_stream(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::dan::Code, ::dan::TestStream>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(1, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_test_multiunary : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_test_multiunary() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_test_multiunary() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_multiunary(::grpc::ServerContext* context, const ::dan::TestStream* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttest_multiunary(::grpc::ServerContext* context, ::dan::TestStream* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_test_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_test_size() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_test_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_size(::grpc::ServerContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttest_size(::grpc::ServerContext* context, ::dan::DoubleVec* request, ::grpc::ServerAsyncResponseWriter< ::dan::DoubleVec>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_archive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_archive() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_archive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status archive(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestarchive(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_recover() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status recover(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrecover(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_request_node_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_request_node_list() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_request_node_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_node_list(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrequest_node_list(::grpc::ServerContext* context, ::dan::Void* request, ::grpc::ServerAsyncResponseWriter< ::dan::NodeInfoVec>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_request_register_node : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_request_register_node() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_request_register_node() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_register_node(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrequest_register_node(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_request_socket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_request_socket() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_request_socket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_socket(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::HostInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrequest_socket(::grpc::ServerContext* context, ::dan::Void* request, ::grpc::ServerAsyncResponseWriter< ::dan::HostInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_memory_statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_memory_statistics() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_memory_statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status memory_statistics(::grpc::ServerContext* context, const ::dan::MemoryStat* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestmemory_statistics(::grpc::ServerContext* context, ::dan::MemoryStat* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_create_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_create_table() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_create_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_table(::grpc::ServerContext* context, const ::dan::CreateTable* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate_table(::grpc::ServerContext* context, ::dan::CreateTable* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_drop_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_drop_table() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_drop_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_table(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdrop_table(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_drop_table_if_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_drop_table_if_exists() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_drop_table_if_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_table_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdrop_table_if_exists(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_load_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_load_table() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_load_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load_table(::grpc::ServerContext* context, const ::dan::StrVec* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestload_table(::grpc::ServerContext* context, ::dan::StrVec* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_create_index : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_create_index() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_create_index() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_index(::grpc::ServerContext* context, const ::dan::CreateIndex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate_index(::grpc::ServerContext* context, ::dan::CreateIndex* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_table_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_table_partition() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_table_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status table_partition(::grpc::ServerContext* context, const ::dan::TablePartition* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttable_partition(::grpc::ServerContext* context, ::dan::TablePartition* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_set_partition() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_set_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_partition(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_partition(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_create_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_create_graph() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_create_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_graph(::grpc::ServerContext* context, const ::dan::CreateGraph* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate_graph(::grpc::ServerContext* context, ::dan::CreateGraph* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_drop_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_drop_graph() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_drop_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_graph(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdrop_graph(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_drop_graph_if_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_drop_graph_if_exists() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_drop_graph_if_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_graph_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdrop_graph_if_exists(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_define_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_define_vertex() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_define_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status define_vertex(::grpc::ServerContext* context, const ::dan::DefineVertex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdefine_vertex(::grpc::ServerContext* context, ::dan::DefineVertex* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_graph_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_graph_partition() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_graph_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph_partition(::grpc::ServerContext* context, const ::dan::GraphPartition* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestgraph_partition(::grpc::ServerContext* context, ::dan::GraphPartition* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_graph_merge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_graph_merge() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_graph_merge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph_merge(::grpc::ServerContext* context, const ::dan::MergeInfo* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestgraph_merge(::grpc::ServerContext* context, ::dan::MergeInfo* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_transfer_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_transfer_data() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_transfer_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status transfer_data(::grpc::ServerContext* context, const ::dan::TransferBinary* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttransfer_data(::grpc::ServerContext* context, ::dan::TransferBinary* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insert_record : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_insert_record() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_insert_record() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_record(::grpc::ServerContext* context, const ::dan::InsertRecord* request, ::dan::Str* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_record(::grpc::ServerContext* context, ::dan::InsertRecord* request, ::grpc::ServerAsyncResponseWriter< ::dan::Str>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insert_record_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_insert_record_batch() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_insert_record_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_record_batch(::grpc::ServerContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_record_batch(::grpc::ServerContext* context, ::dan::InsertRecordBatch* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_import_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_import_vertex() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_import_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status import_vertex(::grpc::ServerContext* context, const ::dan::ImportVertex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestimport_vertex(::grpc::ServerContext* context, ::dan::ImportVertex* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insert_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_insert_vertex() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_insert_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_vertex(::grpc::ServerContext* context, const ::dan::InsertVertex* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_vertex(::grpc::ServerContext* context, ::dan::InsertVertex* request, ::grpc::ServerAsyncResponseWriter< ::dan::Long>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insert_vertex_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_insert_vertex_batch() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_insert_vertex_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_vertex_batch(::grpc::ServerContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_vertex_batch(::grpc::ServerContext* context, ::dan::InsertVertexBatch* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_import_edge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_import_edge() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_import_edge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status import_edge(::grpc::ServerContext* context, const ::dan::ImportEdge* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestimport_edge(::grpc::ServerContext* context, ::dan::ImportEdge* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insert_edge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_insert_edge() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_insert_edge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge(::grpc::ServerContext* context, const ::dan::InsertEdge* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_edge(::grpc::ServerContext* context, ::dan::InsertEdge* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insert_edge_vp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_insert_edge_vp() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_insert_edge_vp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_edge_vp(::grpc::ServerContext* context, ::dan::InsertEdgeVP* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insert_edge_naive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_insert_edge_naive() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_insert_edge_naive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_naive(::grpc::ServerContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_edge_naive(::grpc::ServerContext* context, ::dan::InsertEdgeNaive* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insert_edge_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_insert_edge_batch() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_insert_edge_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_batch(::grpc::ServerContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_edge_batch(::grpc::ServerContext* context, ::dan::InsertEdgeBatch* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insert_edge_batch_vp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_insert_edge_batch_vp() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_insert_edge_batch_vp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_batch_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_edge_batch_vp(::grpc::ServerContext* context, ::dan::InsertEdgeBatchVP* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_table_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_get_table_info() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_get_table_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_table_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::TableInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_table_info(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::TableInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_num_records : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_get_num_records() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_get_num_records() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_records(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_num_records(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::Long>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_table_scan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_table_scan() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_table_scan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status table_scan(::grpc::ServerContext* context, const ::dan::TableScan* request, ::dan::Table* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttable_scan(::grpc::ServerContext* context, ::dan::TableScan* request, ::grpc::ServerAsyncResponseWriter< ::dan::Table>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_index_search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_index_search() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_index_search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status index_search(::grpc::ServerContext* context, const ::dan::IndexSearch* request, ::dan::Table* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestindex_search(::grpc::ServerContext* context, ::dan::IndexSearch* request, ::grpc::ServerAsyncResponseWriter< ::dan::Table>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_graph_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_get_graph_info() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_get_graph_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_graph_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::GraphInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_graph_info(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::GraphInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_num_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_get_num_vertex() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_get_num_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_vertex(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_num_vertex(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::Long>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_num_edges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_get_num_edges() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_get_num_edges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_edges(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_num_edges(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncResponseWriter< ::dan::Long>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_adjacent_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_adjacent_list() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_adjacent_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status adjacent_list(::grpc::ServerContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestadjacent_list(::grpc::ServerContext* context, ::dan::AdjacentList* request, ::grpc::ServerAsyncResponseWriter< ::dan::AdjacentListResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_edge_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_get_edge_list() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_get_edge_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_edge_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::EdgeList>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_edge_list(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncWriter< ::dan::EdgeList>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(43, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_get_vertex() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_get_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vertex(::grpc::ServerContext* context, const ::dan::GetVertex* request, ::dan::Record* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_vertex(::grpc::ServerContext* context, ::dan::GetVertex* request, ::grpc::ServerAsyncResponseWriter< ::dan::Record>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_vertex_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_get_vertex_list() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_get_vertex_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vertex_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::VertexList>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_vertex_list(::grpc::ServerContext* context, ::dan::Str* request, ::grpc::ServerAsyncWriter< ::dan::VertexList>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(45, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_vertex_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_vertex_exists() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_vertex_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status vertex_exists(::grpc::ServerContext* context, const ::dan::VertexExists* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestvertex_exists(::grpc::ServerContext* context, ::dan::VertexExists* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_remote_task : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_remote_task() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_remote_task() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_task(::grpc::ServerContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremote_task(::grpc::ServerContext* context, ::dan::RemoteTask* request, ::grpc::ServerAsyncResponseWriter< ::dan::RemoteResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_remote_object : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_remote_object() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_remote_object() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_object(::grpc::ServerContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremote_object(::grpc::ServerContext* context, ::dan::RemoteObject* request, ::grpc::ServerAsyncResponseWriter< ::dan::RemoteResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_remove_remote_object : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_remove_remote_object() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_remove_remote_object() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_remote_object(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremove_remote_object(::grpc::ServerContext* context, ::dan::RemoteTaskResult* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_remote_object_task : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_remote_object_task() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_remote_object_task() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_object_task(::grpc::ServerContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremote_object_task(::grpc::ServerContext* context, ::dan::RemoteObjectTask* request, ::grpc::ServerAsyncResponseWriter< ::dan::RemoteResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_remote_task_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_remote_task_result() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_remote_task_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremote_task_result(::grpc::ServerContext* context, ::dan::RemoteTaskResult* request, ::grpc::ServerAsyncResponseWriter< ::dan::RemoteResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_remove_task_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_remove_task_result() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_remove_task_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremove_task_result(::grpc::ServerContext* context, ::dan::RemoteTaskResult* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_load_graph_from_folder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_load_graph_from_folder() {
      ::grpc::Service::MarkMethodAsync(53);
    }
    ~WithAsyncMethod_load_graph_from_folder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load_graph_from_folder(::grpc::ServerContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestload_graph_from_folder(::grpc::ServerContext* context, ::dan::LoadGraphFromFolder* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_train_node_classifier : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_train_node_classifier() {
      ::grpc::Service::MarkMethodAsync(54);
    }
    ~WithAsyncMethod_train_node_classifier() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status train_node_classifier(::grpc::ServerContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttrain_node_classifier(::grpc::ServerContext* context, ::dan::NodeClassifierInfo* request, ::grpc::ServerAsyncResponseWriter< ::dan::Code>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ping<WithAsyncMethod_test_stream<WithAsyncMethod_test_multiunary<WithAsyncMethod_test_size<WithAsyncMethod_archive<WithAsyncMethod_recover<WithAsyncMethod_request_node_list<WithAsyncMethod_request_register_node<WithAsyncMethod_request_socket<WithAsyncMethod_memory_statistics<WithAsyncMethod_create_table<WithAsyncMethod_drop_table<WithAsyncMethod_drop_table_if_exists<WithAsyncMethod_load_table<WithAsyncMethod_create_index<WithAsyncMethod_table_partition<WithAsyncMethod_set_partition<WithAsyncMethod_create_graph<WithAsyncMethod_drop_graph<WithAsyncMethod_drop_graph_if_exists<WithAsyncMethod_define_vertex<WithAsyncMethod_graph_partition<WithAsyncMethod_graph_merge<WithAsyncMethod_transfer_data<WithAsyncMethod_insert_record<WithAsyncMethod_insert_record_batch<WithAsyncMethod_import_vertex<WithAsyncMethod_insert_vertex<WithAsyncMethod_insert_vertex_batch<WithAsyncMethod_import_edge<WithAsyncMethod_insert_edge<WithAsyncMethod_insert_edge_vp<WithAsyncMethod_insert_edge_naive<WithAsyncMethod_insert_edge_batch<WithAsyncMethod_insert_edge_batch_vp<WithAsyncMethod_get_table_info<WithAsyncMethod_get_num_records<WithAsyncMethod_table_scan<WithAsyncMethod_index_search<WithAsyncMethod_get_graph_info<WithAsyncMethod_get_num_vertex<WithAsyncMethod_get_num_edges<WithAsyncMethod_adjacent_list<WithAsyncMethod_get_edge_list<WithAsyncMethod_get_vertex<WithAsyncMethod_get_vertex_list<WithAsyncMethod_vertex_exists<WithAsyncMethod_remote_task<WithAsyncMethod_remote_object<WithAsyncMethod_remove_remote_object<WithAsyncMethod_remote_object_task<WithAsyncMethod_remote_task_result<WithAsyncMethod_remove_task_result<WithAsyncMethod_load_graph_from_folder<WithAsyncMethod_train_node_classifier<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ping() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Void, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Void* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ping(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ping(
        ::grpc::experimental::MessageAllocator< ::dan::Void, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Void, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ping(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ping(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_test_stream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_test_stream() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackClientStreamingHandler< ::dan::TestStream, ::dan::Code>(
          [this] { return this->test_stream(); }));
    }
    ~ExperimentalWithCallbackMethod_test_stream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_stream(::grpc::ServerContext* context, ::grpc::ServerReader< ::dan::TestStream>* reader, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerReadReactor< ::dan::TestStream, ::dan::Code>* test_stream() {
      return new ::grpc::internal::UnimplementedReadReactor<
        ::dan::TestStream, ::dan::Code>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_test_multiunary : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_test_multiunary() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::TestStream, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::TestStream* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->test_multiunary(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_test_multiunary(
        ::grpc::experimental::MessageAllocator< ::dan::TestStream, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::TestStream, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_test_multiunary() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_multiunary(::grpc::ServerContext* context, const ::dan::TestStream* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void test_multiunary(::grpc::ServerContext* context, const ::dan::TestStream* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_test_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_test_size() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::DoubleVec, ::dan::DoubleVec>(
          [this](::grpc::ServerContext* context,
                 const ::dan::DoubleVec* request,
                 ::dan::DoubleVec* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->test_size(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_test_size(
        ::grpc::experimental::MessageAllocator< ::dan::DoubleVec, ::dan::DoubleVec>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::DoubleVec, ::dan::DoubleVec>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_test_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_size(::grpc::ServerContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void test_size(::grpc::ServerContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_archive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_archive() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->archive(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_archive(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_archive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status archive(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void archive(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_recover() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->recover(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_recover(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status recover(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void recover(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_request_node_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_request_node_list() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Void, ::dan::NodeInfoVec>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Void* request,
                 ::dan::NodeInfoVec* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->request_node_list(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_request_node_list(
        ::grpc::experimental::MessageAllocator< ::dan::Void, ::dan::NodeInfoVec>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Void, ::dan::NodeInfoVec>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_request_node_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_node_list(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void request_node_list(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_request_register_node : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_request_register_node() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->request_register_node(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_request_register_node(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_request_register_node() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_register_node(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void request_register_node(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_request_socket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_request_socket() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Void, ::dan::HostInfo>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Void* request,
                 ::dan::HostInfo* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->request_socket(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_request_socket(
        ::grpc::experimental::MessageAllocator< ::dan::Void, ::dan::HostInfo>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Void, ::dan::HostInfo>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_request_socket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_socket(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::HostInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void request_socket(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::HostInfo* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_memory_statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_memory_statistics() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::MemoryStat, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::MemoryStat* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->memory_statistics(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_memory_statistics(
        ::grpc::experimental::MessageAllocator< ::dan::MemoryStat, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::MemoryStat, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_memory_statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status memory_statistics(::grpc::ServerContext* context, const ::dan::MemoryStat* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void memory_statistics(::grpc::ServerContext* context, const ::dan::MemoryStat* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_create_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_create_table() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::CreateTable, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::CreateTable* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->create_table(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_create_table(
        ::grpc::experimental::MessageAllocator< ::dan::CreateTable, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::CreateTable, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_create_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_table(::grpc::ServerContext* context, const ::dan::CreateTable* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void create_table(::grpc::ServerContext* context, const ::dan::CreateTable* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_drop_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_drop_table() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->drop_table(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_drop_table(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_drop_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_table(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void drop_table(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_drop_table_if_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_drop_table_if_exists() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->drop_table_if_exists(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_drop_table_if_exists(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_drop_table_if_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_table_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void drop_table_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_load_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_load_table() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::StrVec, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::StrVec* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->load_table(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_load_table(
        ::grpc::experimental::MessageAllocator< ::dan::StrVec, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::StrVec, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_load_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load_table(::grpc::ServerContext* context, const ::dan::StrVec* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void load_table(::grpc::ServerContext* context, const ::dan::StrVec* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_create_index : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_create_index() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::CreateIndex, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::CreateIndex* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->create_index(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_create_index(
        ::grpc::experimental::MessageAllocator< ::dan::CreateIndex, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::CreateIndex, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_create_index() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_index(::grpc::ServerContext* context, const ::dan::CreateIndex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void create_index(::grpc::ServerContext* context, const ::dan::CreateIndex* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_table_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_table_partition() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::TablePartition, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::TablePartition* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->table_partition(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_table_partition(
        ::grpc::experimental::MessageAllocator< ::dan::TablePartition, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::TablePartition, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_table_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status table_partition(::grpc::ServerContext* context, const ::dan::TablePartition* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void table_partition(::grpc::ServerContext* context, const ::dan::TablePartition* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_set_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_set_partition() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->set_partition(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_set_partition(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_set_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_partition(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void set_partition(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_create_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_create_graph() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::CreateGraph, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::CreateGraph* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->create_graph(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_create_graph(
        ::grpc::experimental::MessageAllocator< ::dan::CreateGraph, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::CreateGraph, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(17))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_create_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_graph(::grpc::ServerContext* context, const ::dan::CreateGraph* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void create_graph(::grpc::ServerContext* context, const ::dan::CreateGraph* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_drop_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_drop_graph() {
      ::grpc::Service::experimental().MarkMethodCallback(18,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->drop_graph(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_drop_graph(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(18))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_drop_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_graph(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void drop_graph(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_drop_graph_if_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_drop_graph_if_exists() {
      ::grpc::Service::experimental().MarkMethodCallback(19,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->drop_graph_if_exists(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_drop_graph_if_exists(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(19))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_drop_graph_if_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_graph_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void drop_graph_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_define_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_define_vertex() {
      ::grpc::Service::experimental().MarkMethodCallback(20,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::DefineVertex, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::DefineVertex* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->define_vertex(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_define_vertex(
        ::grpc::experimental::MessageAllocator< ::dan::DefineVertex, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::DefineVertex, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(20))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_define_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status define_vertex(::grpc::ServerContext* context, const ::dan::DefineVertex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void define_vertex(::grpc::ServerContext* context, const ::dan::DefineVertex* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_graph_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_graph_partition() {
      ::grpc::Service::experimental().MarkMethodCallback(21,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::GraphPartition, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::GraphPartition* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->graph_partition(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_graph_partition(
        ::grpc::experimental::MessageAllocator< ::dan::GraphPartition, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::GraphPartition, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(21))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_graph_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph_partition(::grpc::ServerContext* context, const ::dan::GraphPartition* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void graph_partition(::grpc::ServerContext* context, const ::dan::GraphPartition* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_graph_merge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_graph_merge() {
      ::grpc::Service::experimental().MarkMethodCallback(22,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::MergeInfo, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::MergeInfo* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->graph_merge(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_graph_merge(
        ::grpc::experimental::MessageAllocator< ::dan::MergeInfo, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::MergeInfo, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(22))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_graph_merge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph_merge(::grpc::ServerContext* context, const ::dan::MergeInfo* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void graph_merge(::grpc::ServerContext* context, const ::dan::MergeInfo* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_transfer_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_transfer_data() {
      ::grpc::Service::experimental().MarkMethodCallback(23,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::TransferBinary, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::TransferBinary* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->transfer_data(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_transfer_data(
        ::grpc::experimental::MessageAllocator< ::dan::TransferBinary, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::TransferBinary, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(23))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_transfer_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status transfer_data(::grpc::ServerContext* context, const ::dan::TransferBinary* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void transfer_data(::grpc::ServerContext* context, const ::dan::TransferBinary* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_insert_record : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_insert_record() {
      ::grpc::Service::experimental().MarkMethodCallback(24,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::InsertRecord, ::dan::Str>(
          [this](::grpc::ServerContext* context,
                 const ::dan::InsertRecord* request,
                 ::dan::Str* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->insert_record(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_insert_record(
        ::grpc::experimental::MessageAllocator< ::dan::InsertRecord, ::dan::Str>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::InsertRecord, ::dan::Str>*>(
          ::grpc::Service::experimental().GetHandler(24))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_insert_record() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_record(::grpc::ServerContext* context, const ::dan::InsertRecord* request, ::dan::Str* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_record(::grpc::ServerContext* context, const ::dan::InsertRecord* request, ::dan::Str* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_insert_record_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_insert_record_batch() {
      ::grpc::Service::experimental().MarkMethodCallback(25,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::InsertRecordBatch, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::InsertRecordBatch* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->insert_record_batch(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_insert_record_batch(
        ::grpc::experimental::MessageAllocator< ::dan::InsertRecordBatch, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::InsertRecordBatch, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(25))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_insert_record_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_record_batch(::grpc::ServerContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_record_batch(::grpc::ServerContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_import_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_import_vertex() {
      ::grpc::Service::experimental().MarkMethodCallback(26,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::ImportVertex, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::ImportVertex* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->import_vertex(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_import_vertex(
        ::grpc::experimental::MessageAllocator< ::dan::ImportVertex, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::ImportVertex, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(26))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_import_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status import_vertex(::grpc::ServerContext* context, const ::dan::ImportVertex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void import_vertex(::grpc::ServerContext* context, const ::dan::ImportVertex* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_insert_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_insert_vertex() {
      ::grpc::Service::experimental().MarkMethodCallback(27,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::InsertVertex, ::dan::Long>(
          [this](::grpc::ServerContext* context,
                 const ::dan::InsertVertex* request,
                 ::dan::Long* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->insert_vertex(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_insert_vertex(
        ::grpc::experimental::MessageAllocator< ::dan::InsertVertex, ::dan::Long>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::InsertVertex, ::dan::Long>*>(
          ::grpc::Service::experimental().GetHandler(27))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_insert_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_vertex(::grpc::ServerContext* context, const ::dan::InsertVertex* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_vertex(::grpc::ServerContext* context, const ::dan::InsertVertex* request, ::dan::Long* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_insert_vertex_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_insert_vertex_batch() {
      ::grpc::Service::experimental().MarkMethodCallback(28,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::InsertVertexBatch, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::InsertVertexBatch* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->insert_vertex_batch(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_insert_vertex_batch(
        ::grpc::experimental::MessageAllocator< ::dan::InsertVertexBatch, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::InsertVertexBatch, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(28))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_insert_vertex_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_vertex_batch(::grpc::ServerContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_vertex_batch(::grpc::ServerContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_import_edge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_import_edge() {
      ::grpc::Service::experimental().MarkMethodCallback(29,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::ImportEdge, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::ImportEdge* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->import_edge(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_import_edge(
        ::grpc::experimental::MessageAllocator< ::dan::ImportEdge, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::ImportEdge, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(29))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_import_edge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status import_edge(::grpc::ServerContext* context, const ::dan::ImportEdge* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void import_edge(::grpc::ServerContext* context, const ::dan::ImportEdge* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_insert_edge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_insert_edge() {
      ::grpc::Service::experimental().MarkMethodCallback(30,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::InsertEdge, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::InsertEdge* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->insert_edge(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_insert_edge(
        ::grpc::experimental::MessageAllocator< ::dan::InsertEdge, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::InsertEdge, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(30))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_insert_edge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge(::grpc::ServerContext* context, const ::dan::InsertEdge* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_edge(::grpc::ServerContext* context, const ::dan::InsertEdge* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_insert_edge_vp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_insert_edge_vp() {
      ::grpc::Service::experimental().MarkMethodCallback(31,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::InsertEdgeVP, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::InsertEdgeVP* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->insert_edge_vp(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_insert_edge_vp(
        ::grpc::experimental::MessageAllocator< ::dan::InsertEdgeVP, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::InsertEdgeVP, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(31))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_insert_edge_vp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_edge_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_insert_edge_naive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_insert_edge_naive() {
      ::grpc::Service::experimental().MarkMethodCallback(32,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::InsertEdgeNaive, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::InsertEdgeNaive* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->insert_edge_naive(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_insert_edge_naive(
        ::grpc::experimental::MessageAllocator< ::dan::InsertEdgeNaive, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::InsertEdgeNaive, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(32))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_insert_edge_naive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_naive(::grpc::ServerContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_edge_naive(::grpc::ServerContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_insert_edge_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_insert_edge_batch() {
      ::grpc::Service::experimental().MarkMethodCallback(33,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::InsertEdgeBatch, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::InsertEdgeBatch* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->insert_edge_batch(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_insert_edge_batch(
        ::grpc::experimental::MessageAllocator< ::dan::InsertEdgeBatch, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::InsertEdgeBatch, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(33))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_insert_edge_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_batch(::grpc::ServerContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_edge_batch(::grpc::ServerContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_insert_edge_batch_vp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_insert_edge_batch_vp() {
      ::grpc::Service::experimental().MarkMethodCallback(34,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::InsertEdgeBatchVP, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::InsertEdgeBatchVP* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->insert_edge_batch_vp(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_insert_edge_batch_vp(
        ::grpc::experimental::MessageAllocator< ::dan::InsertEdgeBatchVP, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::InsertEdgeBatchVP, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(34))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_insert_edge_batch_vp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_batch_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_edge_batch_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_table_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_get_table_info() {
      ::grpc::Service::experimental().MarkMethodCallback(35,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::TableInfo>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::TableInfo* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->get_table_info(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_get_table_info(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::TableInfo>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::TableInfo>*>(
          ::grpc::Service::experimental().GetHandler(35))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_table_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_table_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::TableInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_table_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::TableInfo* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_num_records : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_get_num_records() {
      ::grpc::Service::experimental().MarkMethodCallback(36,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Long>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::Long* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->get_num_records(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_get_num_records(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::Long>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Long>*>(
          ::grpc::Service::experimental().GetHandler(36))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_num_records() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_records(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_num_records(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_table_scan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_table_scan() {
      ::grpc::Service::experimental().MarkMethodCallback(37,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::TableScan, ::dan::Table>(
          [this](::grpc::ServerContext* context,
                 const ::dan::TableScan* request,
                 ::dan::Table* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->table_scan(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_table_scan(
        ::grpc::experimental::MessageAllocator< ::dan::TableScan, ::dan::Table>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::TableScan, ::dan::Table>*>(
          ::grpc::Service::experimental().GetHandler(37))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_table_scan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status table_scan(::grpc::ServerContext* context, const ::dan::TableScan* request, ::dan::Table* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void table_scan(::grpc::ServerContext* context, const ::dan::TableScan* request, ::dan::Table* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_index_search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_index_search() {
      ::grpc::Service::experimental().MarkMethodCallback(38,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::IndexSearch, ::dan::Table>(
          [this](::grpc::ServerContext* context,
                 const ::dan::IndexSearch* request,
                 ::dan::Table* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->index_search(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_index_search(
        ::grpc::experimental::MessageAllocator< ::dan::IndexSearch, ::dan::Table>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::IndexSearch, ::dan::Table>*>(
          ::grpc::Service::experimental().GetHandler(38))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_index_search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status index_search(::grpc::ServerContext* context, const ::dan::IndexSearch* request, ::dan::Table* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void index_search(::grpc::ServerContext* context, const ::dan::IndexSearch* request, ::dan::Table* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_graph_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_get_graph_info() {
      ::grpc::Service::experimental().MarkMethodCallback(39,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::GraphInfo>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::GraphInfo* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->get_graph_info(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_get_graph_info(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::GraphInfo>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::GraphInfo>*>(
          ::grpc::Service::experimental().GetHandler(39))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_graph_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_graph_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::GraphInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_graph_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::GraphInfo* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_num_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_get_num_vertex() {
      ::grpc::Service::experimental().MarkMethodCallback(40,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Long>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::Long* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->get_num_vertex(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_get_num_vertex(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::Long>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Long>*>(
          ::grpc::Service::experimental().GetHandler(40))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_num_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_vertex(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_num_vertex(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_num_edges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_get_num_edges() {
      ::grpc::Service::experimental().MarkMethodCallback(41,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Long>(
          [this](::grpc::ServerContext* context,
                 const ::dan::Str* request,
                 ::dan::Long* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->get_num_edges(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_get_num_edges(
        ::grpc::experimental::MessageAllocator< ::dan::Str, ::dan::Long>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::Str, ::dan::Long>*>(
          ::grpc::Service::experimental().GetHandler(41))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_num_edges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_edges(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_num_edges(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_adjacent_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_adjacent_list() {
      ::grpc::Service::experimental().MarkMethodCallback(42,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::AdjacentList, ::dan::AdjacentListResult>(
          [this](::grpc::ServerContext* context,
                 const ::dan::AdjacentList* request,
                 ::dan::AdjacentListResult* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->adjacent_list(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_adjacent_list(
        ::grpc::experimental::MessageAllocator< ::dan::AdjacentList, ::dan::AdjacentListResult>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::AdjacentList, ::dan::AdjacentListResult>*>(
          ::grpc::Service::experimental().GetHandler(42))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_adjacent_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status adjacent_list(::grpc::ServerContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void adjacent_list(::grpc::ServerContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_edge_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_get_edge_list() {
      ::grpc::Service::experimental().MarkMethodCallback(43,
        new ::grpc::internal::CallbackServerStreamingHandler< ::dan::Str, ::dan::EdgeList>(
          [this] { return this->get_edge_list(); }));
    }
    ~ExperimentalWithCallbackMethod_get_edge_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_edge_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::EdgeList>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::dan::Str, ::dan::EdgeList>* get_edge_list() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::dan::Str, ::dan::EdgeList>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_get_vertex() {
      ::grpc::Service::experimental().MarkMethodCallback(44,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::GetVertex, ::dan::Record>(
          [this](::grpc::ServerContext* context,
                 const ::dan::GetVertex* request,
                 ::dan::Record* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->get_vertex(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_get_vertex(
        ::grpc::experimental::MessageAllocator< ::dan::GetVertex, ::dan::Record>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::GetVertex, ::dan::Record>*>(
          ::grpc::Service::experimental().GetHandler(44))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vertex(::grpc::ServerContext* context, const ::dan::GetVertex* request, ::dan::Record* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_vertex(::grpc::ServerContext* context, const ::dan::GetVertex* request, ::dan::Record* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_vertex_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_get_vertex_list() {
      ::grpc::Service::experimental().MarkMethodCallback(45,
        new ::grpc::internal::CallbackServerStreamingHandler< ::dan::Str, ::dan::VertexList>(
          [this] { return this->get_vertex_list(); }));
    }
    ~ExperimentalWithCallbackMethod_get_vertex_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vertex_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::VertexList>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::dan::Str, ::dan::VertexList>* get_vertex_list() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::dan::Str, ::dan::VertexList>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_vertex_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_vertex_exists() {
      ::grpc::Service::experimental().MarkMethodCallback(46,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::VertexExists, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::VertexExists* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->vertex_exists(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_vertex_exists(
        ::grpc::experimental::MessageAllocator< ::dan::VertexExists, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::VertexExists, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(46))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_vertex_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status vertex_exists(::grpc::ServerContext* context, const ::dan::VertexExists* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void vertex_exists(::grpc::ServerContext* context, const ::dan::VertexExists* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_remote_task : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_remote_task() {
      ::grpc::Service::experimental().MarkMethodCallback(47,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::RemoteTask, ::dan::RemoteResult>(
          [this](::grpc::ServerContext* context,
                 const ::dan::RemoteTask* request,
                 ::dan::RemoteResult* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->remote_task(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_remote_task(
        ::grpc::experimental::MessageAllocator< ::dan::RemoteTask, ::dan::RemoteResult>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::RemoteTask, ::dan::RemoteResult>*>(
          ::grpc::Service::experimental().GetHandler(47))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_remote_task() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_task(::grpc::ServerContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void remote_task(::grpc::ServerContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_remote_object : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_remote_object() {
      ::grpc::Service::experimental().MarkMethodCallback(48,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::RemoteObject, ::dan::RemoteResult>(
          [this](::grpc::ServerContext* context,
                 const ::dan::RemoteObject* request,
                 ::dan::RemoteResult* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->remote_object(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_remote_object(
        ::grpc::experimental::MessageAllocator< ::dan::RemoteObject, ::dan::RemoteResult>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::RemoteObject, ::dan::RemoteResult>*>(
          ::grpc::Service::experimental().GetHandler(48))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_remote_object() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_object(::grpc::ServerContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void remote_object(::grpc::ServerContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_remove_remote_object : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_remove_remote_object() {
      ::grpc::Service::experimental().MarkMethodCallback(49,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::RemoteTaskResult, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::RemoteTaskResult* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->remove_remote_object(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_remove_remote_object(
        ::grpc::experimental::MessageAllocator< ::dan::RemoteTaskResult, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::RemoteTaskResult, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(49))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_remove_remote_object() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_remote_object(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void remove_remote_object(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_remote_object_task : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_remote_object_task() {
      ::grpc::Service::experimental().MarkMethodCallback(50,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::RemoteObjectTask, ::dan::RemoteResult>(
          [this](::grpc::ServerContext* context,
                 const ::dan::RemoteObjectTask* request,
                 ::dan::RemoteResult* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->remote_object_task(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_remote_object_task(
        ::grpc::experimental::MessageAllocator< ::dan::RemoteObjectTask, ::dan::RemoteResult>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::RemoteObjectTask, ::dan::RemoteResult>*>(
          ::grpc::Service::experimental().GetHandler(50))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_remote_object_task() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_object_task(::grpc::ServerContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void remote_object_task(::grpc::ServerContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_remote_task_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_remote_task_result() {
      ::grpc::Service::experimental().MarkMethodCallback(51,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::RemoteTaskResult, ::dan::RemoteResult>(
          [this](::grpc::ServerContext* context,
                 const ::dan::RemoteTaskResult* request,
                 ::dan::RemoteResult* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->remote_task_result(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_remote_task_result(
        ::grpc::experimental::MessageAllocator< ::dan::RemoteTaskResult, ::dan::RemoteResult>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::RemoteTaskResult, ::dan::RemoteResult>*>(
          ::grpc::Service::experimental().GetHandler(51))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_remote_task_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void remote_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_remove_task_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_remove_task_result() {
      ::grpc::Service::experimental().MarkMethodCallback(52,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::RemoteTaskResult, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::RemoteTaskResult* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->remove_task_result(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_remove_task_result(
        ::grpc::experimental::MessageAllocator< ::dan::RemoteTaskResult, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::RemoteTaskResult, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(52))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_remove_task_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void remove_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_load_graph_from_folder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_load_graph_from_folder() {
      ::grpc::Service::experimental().MarkMethodCallback(53,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::LoadGraphFromFolder, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::LoadGraphFromFolder* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->load_graph_from_folder(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_load_graph_from_folder(
        ::grpc::experimental::MessageAllocator< ::dan::LoadGraphFromFolder, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::LoadGraphFromFolder, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(53))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_load_graph_from_folder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load_graph_from_folder(::grpc::ServerContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void load_graph_from_folder(::grpc::ServerContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_train_node_classifier : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_train_node_classifier() {
      ::grpc::Service::experimental().MarkMethodCallback(54,
        new ::grpc::internal::CallbackUnaryHandler< ::dan::NodeClassifierInfo, ::dan::Code>(
          [this](::grpc::ServerContext* context,
                 const ::dan::NodeClassifierInfo* request,
                 ::dan::Code* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->train_node_classifier(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_train_node_classifier(
        ::grpc::experimental::MessageAllocator< ::dan::NodeClassifierInfo, ::dan::Code>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dan::NodeClassifierInfo, ::dan::Code>*>(
          ::grpc::Service::experimental().GetHandler(54))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_train_node_classifier() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status train_node_classifier(::grpc::ServerContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void train_node_classifier(::grpc::ServerContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_ping<ExperimentalWithCallbackMethod_test_stream<ExperimentalWithCallbackMethod_test_multiunary<ExperimentalWithCallbackMethod_test_size<ExperimentalWithCallbackMethod_archive<ExperimentalWithCallbackMethod_recover<ExperimentalWithCallbackMethod_request_node_list<ExperimentalWithCallbackMethod_request_register_node<ExperimentalWithCallbackMethod_request_socket<ExperimentalWithCallbackMethod_memory_statistics<ExperimentalWithCallbackMethod_create_table<ExperimentalWithCallbackMethod_drop_table<ExperimentalWithCallbackMethod_drop_table_if_exists<ExperimentalWithCallbackMethod_load_table<ExperimentalWithCallbackMethod_create_index<ExperimentalWithCallbackMethod_table_partition<ExperimentalWithCallbackMethod_set_partition<ExperimentalWithCallbackMethod_create_graph<ExperimentalWithCallbackMethod_drop_graph<ExperimentalWithCallbackMethod_drop_graph_if_exists<ExperimentalWithCallbackMethod_define_vertex<ExperimentalWithCallbackMethod_graph_partition<ExperimentalWithCallbackMethod_graph_merge<ExperimentalWithCallbackMethod_transfer_data<ExperimentalWithCallbackMethod_insert_record<ExperimentalWithCallbackMethod_insert_record_batch<ExperimentalWithCallbackMethod_import_vertex<ExperimentalWithCallbackMethod_insert_vertex<ExperimentalWithCallbackMethod_insert_vertex_batch<ExperimentalWithCallbackMethod_import_edge<ExperimentalWithCallbackMethod_insert_edge<ExperimentalWithCallbackMethod_insert_edge_vp<ExperimentalWithCallbackMethod_insert_edge_naive<ExperimentalWithCallbackMethod_insert_edge_batch<ExperimentalWithCallbackMethod_insert_edge_batch_vp<ExperimentalWithCallbackMethod_get_table_info<ExperimentalWithCallbackMethod_get_num_records<ExperimentalWithCallbackMethod_table_scan<ExperimentalWithCallbackMethod_index_search<ExperimentalWithCallbackMethod_get_graph_info<ExperimentalWithCallbackMethod_get_num_vertex<ExperimentalWithCallbackMethod_get_num_edges<ExperimentalWithCallbackMethod_adjacent_list<ExperimentalWithCallbackMethod_get_edge_list<ExperimentalWithCallbackMethod_get_vertex<ExperimentalWithCallbackMethod_get_vertex_list<ExperimentalWithCallbackMethod_vertex_exists<ExperimentalWithCallbackMethod_remote_task<ExperimentalWithCallbackMethod_remote_object<ExperimentalWithCallbackMethod_remove_remote_object<ExperimentalWithCallbackMethod_remote_object_task<ExperimentalWithCallbackMethod_remote_task_result<ExperimentalWithCallbackMethod_remove_task_result<ExperimentalWithCallbackMethod_load_graph_from_folder<ExperimentalWithCallbackMethod_train_node_classifier<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ping() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ping(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_test_stream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_test_stream() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_test_stream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_stream(::grpc::ServerContext* context, ::grpc::ServerReader< ::dan::TestStream>* reader, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_test_multiunary : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_test_multiunary() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_test_multiunary() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_multiunary(::grpc::ServerContext* context, const ::dan::TestStream* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_test_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_test_size() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_test_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_size(::grpc::ServerContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_archive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_archive() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_archive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status archive(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_recover() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status recover(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_request_node_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_request_node_list() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_request_node_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_node_list(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_request_register_node : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_request_register_node() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_request_register_node() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_register_node(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_request_socket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_request_socket() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_request_socket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_socket(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::HostInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_memory_statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_memory_statistics() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_memory_statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status memory_statistics(::grpc::ServerContext* context, const ::dan::MemoryStat* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_create_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_create_table() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_create_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_table(::grpc::ServerContext* context, const ::dan::CreateTable* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_drop_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_drop_table() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_drop_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_table(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_drop_table_if_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_drop_table_if_exists() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_drop_table_if_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_table_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_load_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_load_table() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_load_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load_table(::grpc::ServerContext* context, const ::dan::StrVec* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_create_index : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_create_index() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_create_index() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_index(::grpc::ServerContext* context, const ::dan::CreateIndex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_table_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_table_partition() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_table_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status table_partition(::grpc::ServerContext* context, const ::dan::TablePartition* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_set_partition() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_set_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_partition(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_create_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_create_graph() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_create_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_graph(::grpc::ServerContext* context, const ::dan::CreateGraph* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_drop_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_drop_graph() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_drop_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_graph(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_drop_graph_if_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_drop_graph_if_exists() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_drop_graph_if_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_graph_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_define_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_define_vertex() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_define_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status define_vertex(::grpc::ServerContext* context, const ::dan::DefineVertex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_graph_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_graph_partition() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_graph_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph_partition(::grpc::ServerContext* context, const ::dan::GraphPartition* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_graph_merge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_graph_merge() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_graph_merge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph_merge(::grpc::ServerContext* context, const ::dan::MergeInfo* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_transfer_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_transfer_data() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_transfer_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status transfer_data(::grpc::ServerContext* context, const ::dan::TransferBinary* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insert_record : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_insert_record() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_insert_record() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_record(::grpc::ServerContext* context, const ::dan::InsertRecord* request, ::dan::Str* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insert_record_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_insert_record_batch() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_insert_record_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_record_batch(::grpc::ServerContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_import_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_import_vertex() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_import_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status import_vertex(::grpc::ServerContext* context, const ::dan::ImportVertex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insert_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_insert_vertex() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_insert_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_vertex(::grpc::ServerContext* context, const ::dan::InsertVertex* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insert_vertex_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_insert_vertex_batch() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_insert_vertex_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_vertex_batch(::grpc::ServerContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_import_edge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_import_edge() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_import_edge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status import_edge(::grpc::ServerContext* context, const ::dan::ImportEdge* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insert_edge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_insert_edge() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_insert_edge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge(::grpc::ServerContext* context, const ::dan::InsertEdge* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insert_edge_vp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_insert_edge_vp() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_insert_edge_vp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insert_edge_naive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_insert_edge_naive() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_insert_edge_naive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_naive(::grpc::ServerContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insert_edge_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_insert_edge_batch() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_insert_edge_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_batch(::grpc::ServerContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insert_edge_batch_vp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_insert_edge_batch_vp() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_insert_edge_batch_vp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_batch_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_table_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_get_table_info() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_get_table_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_table_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::TableInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_num_records : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_get_num_records() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_get_num_records() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_records(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_table_scan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_table_scan() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_table_scan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status table_scan(::grpc::ServerContext* context, const ::dan::TableScan* request, ::dan::Table* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_index_search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_index_search() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_index_search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status index_search(::grpc::ServerContext* context, const ::dan::IndexSearch* request, ::dan::Table* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_graph_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_get_graph_info() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_get_graph_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_graph_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::GraphInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_num_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_get_num_vertex() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_get_num_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_vertex(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_num_edges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_get_num_edges() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_get_num_edges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_edges(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_adjacent_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_adjacent_list() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_adjacent_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status adjacent_list(::grpc::ServerContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_edge_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_get_edge_list() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_get_edge_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_edge_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::EdgeList>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_get_vertex() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_get_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vertex(::grpc::ServerContext* context, const ::dan::GetVertex* request, ::dan::Record* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_vertex_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_get_vertex_list() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_get_vertex_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vertex_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::VertexList>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_vertex_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_vertex_exists() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_vertex_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status vertex_exists(::grpc::ServerContext* context, const ::dan::VertexExists* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_remote_task : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_remote_task() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_remote_task() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_task(::grpc::ServerContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_remote_object : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_remote_object() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_remote_object() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_object(::grpc::ServerContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_remove_remote_object : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_remove_remote_object() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_remove_remote_object() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_remote_object(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_remote_object_task : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_remote_object_task() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_remote_object_task() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_object_task(::grpc::ServerContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_remote_task_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_remote_task_result() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_remote_task_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_remove_task_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_remove_task_result() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_remove_task_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_load_graph_from_folder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_load_graph_from_folder() {
      ::grpc::Service::MarkMethodGeneric(53);
    }
    ~WithGenericMethod_load_graph_from_folder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load_graph_from_folder(::grpc::ServerContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_train_node_classifier : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_train_node_classifier() {
      ::grpc::Service::MarkMethodGeneric(54);
    }
    ~WithGenericMethod_train_node_classifier() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status train_node_classifier(::grpc::ServerContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ping() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ping(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestping(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_test_stream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_test_stream() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_test_stream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_stream(::grpc::ServerContext* context, ::grpc::ServerReader< ::dan::TestStream>* reader, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttest_stream(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(1, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_test_multiunary : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_test_multiunary() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_test_multiunary() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_multiunary(::grpc::ServerContext* context, const ::dan::TestStream* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttest_multiunary(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_test_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_test_size() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_test_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_size(::grpc::ServerContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttest_size(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_archive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_archive() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_archive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status archive(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestarchive(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_recover() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status recover(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrecover(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_request_node_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_request_node_list() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_request_node_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_node_list(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrequest_node_list(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_request_register_node : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_request_register_node() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_request_register_node() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_register_node(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrequest_register_node(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_request_socket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_request_socket() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_request_socket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_socket(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::HostInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrequest_socket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_memory_statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_memory_statistics() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_memory_statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status memory_statistics(::grpc::ServerContext* context, const ::dan::MemoryStat* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestmemory_statistics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_create_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_create_table() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_create_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_table(::grpc::ServerContext* context, const ::dan::CreateTable* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate_table(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_drop_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_drop_table() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_drop_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_table(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdrop_table(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_drop_table_if_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_drop_table_if_exists() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_drop_table_if_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_table_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdrop_table_if_exists(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_load_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_load_table() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_load_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load_table(::grpc::ServerContext* context, const ::dan::StrVec* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestload_table(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_create_index : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_create_index() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_create_index() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_index(::grpc::ServerContext* context, const ::dan::CreateIndex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate_index(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_table_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_table_partition() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_table_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status table_partition(::grpc::ServerContext* context, const ::dan::TablePartition* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttable_partition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_set_partition() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_set_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_partition(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_partition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_create_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_create_graph() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_create_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_graph(::grpc::ServerContext* context, const ::dan::CreateGraph* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate_graph(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_drop_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_drop_graph() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_drop_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_graph(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdrop_graph(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_drop_graph_if_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_drop_graph_if_exists() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_drop_graph_if_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_graph_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdrop_graph_if_exists(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_define_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_define_vertex() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_define_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status define_vertex(::grpc::ServerContext* context, const ::dan::DefineVertex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdefine_vertex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_graph_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_graph_partition() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_graph_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph_partition(::grpc::ServerContext* context, const ::dan::GraphPartition* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestgraph_partition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_graph_merge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_graph_merge() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_graph_merge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph_merge(::grpc::ServerContext* context, const ::dan::MergeInfo* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestgraph_merge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_transfer_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_transfer_data() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_transfer_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status transfer_data(::grpc::ServerContext* context, const ::dan::TransferBinary* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttransfer_data(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insert_record : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_insert_record() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_insert_record() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_record(::grpc::ServerContext* context, const ::dan::InsertRecord* request, ::dan::Str* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_record(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insert_record_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_insert_record_batch() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_insert_record_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_record_batch(::grpc::ServerContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_record_batch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_import_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_import_vertex() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_import_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status import_vertex(::grpc::ServerContext* context, const ::dan::ImportVertex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestimport_vertex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insert_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_insert_vertex() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_insert_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_vertex(::grpc::ServerContext* context, const ::dan::InsertVertex* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_vertex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insert_vertex_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_insert_vertex_batch() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_insert_vertex_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_vertex_batch(::grpc::ServerContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_vertex_batch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_import_edge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_import_edge() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_import_edge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status import_edge(::grpc::ServerContext* context, const ::dan::ImportEdge* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestimport_edge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insert_edge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_insert_edge() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_insert_edge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge(::grpc::ServerContext* context, const ::dan::InsertEdge* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_edge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insert_edge_vp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_insert_edge_vp() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_insert_edge_vp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_edge_vp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insert_edge_naive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_insert_edge_naive() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_insert_edge_naive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_naive(::grpc::ServerContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_edge_naive(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insert_edge_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_insert_edge_batch() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_insert_edge_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_batch(::grpc::ServerContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_edge_batch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insert_edge_batch_vp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_insert_edge_batch_vp() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_insert_edge_batch_vp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_batch_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinsert_edge_batch_vp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_table_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_get_table_info() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_get_table_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_table_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::TableInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_table_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_num_records : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_get_num_records() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_get_num_records() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_records(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_num_records(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_table_scan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_table_scan() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_table_scan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status table_scan(::grpc::ServerContext* context, const ::dan::TableScan* request, ::dan::Table* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttable_scan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_index_search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_index_search() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_index_search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status index_search(::grpc::ServerContext* context, const ::dan::IndexSearch* request, ::dan::Table* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestindex_search(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_graph_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_get_graph_info() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_get_graph_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_graph_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::GraphInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_graph_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_num_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_get_num_vertex() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_get_num_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_vertex(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_num_vertex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_num_edges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_get_num_edges() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_get_num_edges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_edges(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_num_edges(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_adjacent_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_adjacent_list() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_adjacent_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status adjacent_list(::grpc::ServerContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestadjacent_list(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_edge_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_get_edge_list() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_get_edge_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_edge_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::EdgeList>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_edge_list(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(43, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_get_vertex() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_get_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vertex(::grpc::ServerContext* context, const ::dan::GetVertex* request, ::dan::Record* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_vertex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_vertex_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_get_vertex_list() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_get_vertex_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vertex_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::VertexList>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_vertex_list(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(45, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_vertex_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_vertex_exists() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_vertex_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status vertex_exists(::grpc::ServerContext* context, const ::dan::VertexExists* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestvertex_exists(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_remote_task : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_remote_task() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_remote_task() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_task(::grpc::ServerContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremote_task(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_remote_object : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_remote_object() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_remote_object() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_object(::grpc::ServerContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremote_object(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_remove_remote_object : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_remove_remote_object() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_remove_remote_object() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_remote_object(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremove_remote_object(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_remote_object_task : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_remote_object_task() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_remote_object_task() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_object_task(::grpc::ServerContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremote_object_task(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_remote_task_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_remote_task_result() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_remote_task_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremote_task_result(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_remove_task_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_remove_task_result() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_remove_task_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremove_task_result(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_load_graph_from_folder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_load_graph_from_folder() {
      ::grpc::Service::MarkMethodRaw(53);
    }
    ~WithRawMethod_load_graph_from_folder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load_graph_from_folder(::grpc::ServerContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestload_graph_from_folder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_train_node_classifier : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_train_node_classifier() {
      ::grpc::Service::MarkMethodRaw(54);
    }
    ~WithRawMethod_train_node_classifier() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status train_node_classifier(::grpc::ServerContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttrain_node_classifier(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ping() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ping(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ping(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ping(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_test_stream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_test_stream() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->test_stream(); }));
    }
    ~ExperimentalWithRawCallbackMethod_test_stream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_stream(::grpc::ServerContext* context, ::grpc::ServerReader< ::dan::TestStream>* reader, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerReadReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* test_stream() {
      return new ::grpc::internal::UnimplementedReadReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_test_multiunary : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_test_multiunary() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->test_multiunary(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_test_multiunary() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_multiunary(::grpc::ServerContext* context, const ::dan::TestStream* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void test_multiunary(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_test_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_test_size() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->test_size(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_test_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status test_size(::grpc::ServerContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void test_size(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_archive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_archive() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->archive(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_archive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status archive(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void archive(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_recover() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->recover(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status recover(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void recover(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_request_node_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_request_node_list() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->request_node_list(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_request_node_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_node_list(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void request_node_list(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_request_register_node : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_request_register_node() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->request_register_node(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_request_register_node() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_register_node(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void request_register_node(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_request_socket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_request_socket() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->request_socket(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_request_socket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status request_socket(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::HostInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void request_socket(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_memory_statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_memory_statistics() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->memory_statistics(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_memory_statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status memory_statistics(::grpc::ServerContext* context, const ::dan::MemoryStat* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void memory_statistics(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_create_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_create_table() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->create_table(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_create_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_table(::grpc::ServerContext* context, const ::dan::CreateTable* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void create_table(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_drop_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_drop_table() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->drop_table(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_drop_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_table(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void drop_table(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_drop_table_if_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_drop_table_if_exists() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->drop_table_if_exists(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_drop_table_if_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_table_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void drop_table_if_exists(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_load_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_load_table() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->load_table(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_load_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load_table(::grpc::ServerContext* context, const ::dan::StrVec* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void load_table(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_create_index : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_create_index() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->create_index(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_create_index() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_index(::grpc::ServerContext* context, const ::dan::CreateIndex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void create_index(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_table_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_table_partition() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->table_partition(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_table_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status table_partition(::grpc::ServerContext* context, const ::dan::TablePartition* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void table_partition(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_set_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_set_partition() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->set_partition(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_set_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_partition(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void set_partition(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_create_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_create_graph() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->create_graph(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_create_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_graph(::grpc::ServerContext* context, const ::dan::CreateGraph* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void create_graph(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_drop_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_drop_graph() {
      ::grpc::Service::experimental().MarkMethodRawCallback(18,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->drop_graph(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_drop_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_graph(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void drop_graph(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_drop_graph_if_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_drop_graph_if_exists() {
      ::grpc::Service::experimental().MarkMethodRawCallback(19,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->drop_graph_if_exists(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_drop_graph_if_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status drop_graph_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void drop_graph_if_exists(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_define_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_define_vertex() {
      ::grpc::Service::experimental().MarkMethodRawCallback(20,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->define_vertex(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_define_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status define_vertex(::grpc::ServerContext* context, const ::dan::DefineVertex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void define_vertex(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_graph_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_graph_partition() {
      ::grpc::Service::experimental().MarkMethodRawCallback(21,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->graph_partition(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_graph_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph_partition(::grpc::ServerContext* context, const ::dan::GraphPartition* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void graph_partition(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_graph_merge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_graph_merge() {
      ::grpc::Service::experimental().MarkMethodRawCallback(22,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->graph_merge(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_graph_merge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph_merge(::grpc::ServerContext* context, const ::dan::MergeInfo* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void graph_merge(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_transfer_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_transfer_data() {
      ::grpc::Service::experimental().MarkMethodRawCallback(23,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->transfer_data(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_transfer_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status transfer_data(::grpc::ServerContext* context, const ::dan::TransferBinary* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void transfer_data(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_insert_record : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_insert_record() {
      ::grpc::Service::experimental().MarkMethodRawCallback(24,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->insert_record(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_insert_record() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_record(::grpc::ServerContext* context, const ::dan::InsertRecord* request, ::dan::Str* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_record(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_insert_record_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_insert_record_batch() {
      ::grpc::Service::experimental().MarkMethodRawCallback(25,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->insert_record_batch(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_insert_record_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_record_batch(::grpc::ServerContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_record_batch(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_import_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_import_vertex() {
      ::grpc::Service::experimental().MarkMethodRawCallback(26,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->import_vertex(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_import_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status import_vertex(::grpc::ServerContext* context, const ::dan::ImportVertex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void import_vertex(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_insert_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_insert_vertex() {
      ::grpc::Service::experimental().MarkMethodRawCallback(27,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->insert_vertex(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_insert_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_vertex(::grpc::ServerContext* context, const ::dan::InsertVertex* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_vertex(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_insert_vertex_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_insert_vertex_batch() {
      ::grpc::Service::experimental().MarkMethodRawCallback(28,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->insert_vertex_batch(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_insert_vertex_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_vertex_batch(::grpc::ServerContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_vertex_batch(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_import_edge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_import_edge() {
      ::grpc::Service::experimental().MarkMethodRawCallback(29,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->import_edge(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_import_edge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status import_edge(::grpc::ServerContext* context, const ::dan::ImportEdge* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void import_edge(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_insert_edge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_insert_edge() {
      ::grpc::Service::experimental().MarkMethodRawCallback(30,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->insert_edge(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_insert_edge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge(::grpc::ServerContext* context, const ::dan::InsertEdge* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_edge(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_insert_edge_vp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_insert_edge_vp() {
      ::grpc::Service::experimental().MarkMethodRawCallback(31,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->insert_edge_vp(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_insert_edge_vp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_edge_vp(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_insert_edge_naive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_insert_edge_naive() {
      ::grpc::Service::experimental().MarkMethodRawCallback(32,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->insert_edge_naive(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_insert_edge_naive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_naive(::grpc::ServerContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_edge_naive(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_insert_edge_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_insert_edge_batch() {
      ::grpc::Service::experimental().MarkMethodRawCallback(33,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->insert_edge_batch(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_insert_edge_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_batch(::grpc::ServerContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_edge_batch(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_insert_edge_batch_vp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_insert_edge_batch_vp() {
      ::grpc::Service::experimental().MarkMethodRawCallback(34,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->insert_edge_batch_vp(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_insert_edge_batch_vp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insert_edge_batch_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void insert_edge_batch_vp(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_table_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_get_table_info() {
      ::grpc::Service::experimental().MarkMethodRawCallback(35,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->get_table_info(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_get_table_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_table_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::TableInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_table_info(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_num_records : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_get_num_records() {
      ::grpc::Service::experimental().MarkMethodRawCallback(36,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->get_num_records(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_get_num_records() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_records(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_num_records(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_table_scan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_table_scan() {
      ::grpc::Service::experimental().MarkMethodRawCallback(37,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->table_scan(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_table_scan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status table_scan(::grpc::ServerContext* context, const ::dan::TableScan* request, ::dan::Table* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void table_scan(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_index_search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_index_search() {
      ::grpc::Service::experimental().MarkMethodRawCallback(38,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->index_search(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_index_search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status index_search(::grpc::ServerContext* context, const ::dan::IndexSearch* request, ::dan::Table* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void index_search(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_graph_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_get_graph_info() {
      ::grpc::Service::experimental().MarkMethodRawCallback(39,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->get_graph_info(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_get_graph_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_graph_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::GraphInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_graph_info(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_num_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_get_num_vertex() {
      ::grpc::Service::experimental().MarkMethodRawCallback(40,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->get_num_vertex(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_get_num_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_vertex(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_num_vertex(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_num_edges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_get_num_edges() {
      ::grpc::Service::experimental().MarkMethodRawCallback(41,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->get_num_edges(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_get_num_edges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_num_edges(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_num_edges(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_adjacent_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_adjacent_list() {
      ::grpc::Service::experimental().MarkMethodRawCallback(42,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->adjacent_list(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_adjacent_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status adjacent_list(::grpc::ServerContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void adjacent_list(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_edge_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_get_edge_list() {
      ::grpc::Service::experimental().MarkMethodRawCallback(43,
        new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->get_edge_list(); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_edge_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_edge_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::EdgeList>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* get_edge_list() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_get_vertex() {
      ::grpc::Service::experimental().MarkMethodRawCallback(44,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->get_vertex(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_get_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vertex(::grpc::ServerContext* context, const ::dan::GetVertex* request, ::dan::Record* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void get_vertex(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_vertex_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_get_vertex_list() {
      ::grpc::Service::experimental().MarkMethodRawCallback(45,
        new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->get_vertex_list(); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_vertex_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vertex_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::VertexList>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* get_vertex_list() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_vertex_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_vertex_exists() {
      ::grpc::Service::experimental().MarkMethodRawCallback(46,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->vertex_exists(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_vertex_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status vertex_exists(::grpc::ServerContext* context, const ::dan::VertexExists* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void vertex_exists(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_remote_task : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_remote_task() {
      ::grpc::Service::experimental().MarkMethodRawCallback(47,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->remote_task(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_remote_task() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_task(::grpc::ServerContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void remote_task(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_remote_object : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_remote_object() {
      ::grpc::Service::experimental().MarkMethodRawCallback(48,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->remote_object(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_remote_object() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_object(::grpc::ServerContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void remote_object(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_remove_remote_object : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_remove_remote_object() {
      ::grpc::Service::experimental().MarkMethodRawCallback(49,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->remove_remote_object(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_remove_remote_object() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_remote_object(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void remove_remote_object(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_remote_object_task : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_remote_object_task() {
      ::grpc::Service::experimental().MarkMethodRawCallback(50,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->remote_object_task(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_remote_object_task() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_object_task(::grpc::ServerContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void remote_object_task(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_remote_task_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_remote_task_result() {
      ::grpc::Service::experimental().MarkMethodRawCallback(51,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->remote_task_result(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_remote_task_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void remote_task_result(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_remove_task_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_remove_task_result() {
      ::grpc::Service::experimental().MarkMethodRawCallback(52,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->remove_task_result(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_remove_task_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void remove_task_result(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_load_graph_from_folder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_load_graph_from_folder() {
      ::grpc::Service::experimental().MarkMethodRawCallback(53,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->load_graph_from_folder(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_load_graph_from_folder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status load_graph_from_folder(::grpc::ServerContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void load_graph_from_folder(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_train_node_classifier : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_train_node_classifier() {
      ::grpc::Service::experimental().MarkMethodRawCallback(54,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->train_node_classifier(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_train_node_classifier() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status train_node_classifier(::grpc::ServerContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void train_node_classifier(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ping() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Void, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_ping<BaseClass>::Streamedping, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ping(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedping(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Void,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_test_multiunary : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_test_multiunary() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::TestStream, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_test_multiunary<BaseClass>::Streamedtest_multiunary, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_test_multiunary() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status test_multiunary(::grpc::ServerContext* context, const ::dan::TestStream* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtest_multiunary(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::TestStream,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_test_size : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_test_size() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::DoubleVec, ::dan::DoubleVec>(std::bind(&WithStreamedUnaryMethod_test_size<BaseClass>::Streamedtest_size, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_test_size() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status test_size(::grpc::ServerContext* context, const ::dan::DoubleVec* request, ::dan::DoubleVec* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtest_size(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::DoubleVec,::dan::DoubleVec>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_archive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_archive() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_archive<BaseClass>::Streamedarchive, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_archive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status archive(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedarchive(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_recover : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_recover() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_recover<BaseClass>::Streamedrecover, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_recover() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status recover(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedrecover(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_request_node_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_request_node_list() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Void, ::dan::NodeInfoVec>(std::bind(&WithStreamedUnaryMethod_request_node_list<BaseClass>::Streamedrequest_node_list, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_request_node_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status request_node_list(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::NodeInfoVec* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedrequest_node_list(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Void,::dan::NodeInfoVec>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_request_register_node : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_request_register_node() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_request_register_node<BaseClass>::Streamedrequest_register_node, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_request_register_node() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status request_register_node(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedrequest_register_node(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_request_socket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_request_socket() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Void, ::dan::HostInfo>(std::bind(&WithStreamedUnaryMethod_request_socket<BaseClass>::Streamedrequest_socket, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_request_socket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status request_socket(::grpc::ServerContext* context, const ::dan::Void* request, ::dan::HostInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedrequest_socket(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Void,::dan::HostInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_memory_statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_memory_statistics() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::MemoryStat, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_memory_statistics<BaseClass>::Streamedmemory_statistics, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_memory_statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status memory_statistics(::grpc::ServerContext* context, const ::dan::MemoryStat* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedmemory_statistics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::MemoryStat,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_create_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_create_table() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::CreateTable, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_create_table<BaseClass>::Streamedcreate_table, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_create_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status create_table(::grpc::ServerContext* context, const ::dan::CreateTable* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcreate_table(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::CreateTable,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_drop_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_drop_table() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_drop_table<BaseClass>::Streameddrop_table, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_drop_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status drop_table(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddrop_table(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_drop_table_if_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_drop_table_if_exists() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_drop_table_if_exists<BaseClass>::Streameddrop_table_if_exists, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_drop_table_if_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status drop_table_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddrop_table_if_exists(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_load_table : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_load_table() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::StrVec, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_load_table<BaseClass>::Streamedload_table, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_load_table() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status load_table(::grpc::ServerContext* context, const ::dan::StrVec* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedload_table(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::StrVec,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_create_index : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_create_index() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::CreateIndex, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_create_index<BaseClass>::Streamedcreate_index, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_create_index() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status create_index(::grpc::ServerContext* context, const ::dan::CreateIndex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcreate_index(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::CreateIndex,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_table_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_table_partition() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::TablePartition, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_table_partition<BaseClass>::Streamedtable_partition, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_table_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status table_partition(::grpc::ServerContext* context, const ::dan::TablePartition* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtable_partition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::TablePartition,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_set_partition() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_set_partition<BaseClass>::Streamedset_partition, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_set_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_partition(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_partition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_create_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_create_graph() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::CreateGraph, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_create_graph<BaseClass>::Streamedcreate_graph, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_create_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status create_graph(::grpc::ServerContext* context, const ::dan::CreateGraph* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcreate_graph(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::CreateGraph,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_drop_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_drop_graph() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_drop_graph<BaseClass>::Streameddrop_graph, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_drop_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status drop_graph(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddrop_graph(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_drop_graph_if_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_drop_graph_if_exists() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_drop_graph_if_exists<BaseClass>::Streameddrop_graph_if_exists, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_drop_graph_if_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status drop_graph_if_exists(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddrop_graph_if_exists(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_define_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_define_vertex() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::DefineVertex, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_define_vertex<BaseClass>::Streameddefine_vertex, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_define_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status define_vertex(::grpc::ServerContext* context, const ::dan::DefineVertex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddefine_vertex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::DefineVertex,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_graph_partition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_graph_partition() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::GraphPartition, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_graph_partition<BaseClass>::Streamedgraph_partition, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_graph_partition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status graph_partition(::grpc::ServerContext* context, const ::dan::GraphPartition* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedgraph_partition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::GraphPartition,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_graph_merge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_graph_merge() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::MergeInfo, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_graph_merge<BaseClass>::Streamedgraph_merge, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_graph_merge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status graph_merge(::grpc::ServerContext* context, const ::dan::MergeInfo* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedgraph_merge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::MergeInfo,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_transfer_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_transfer_data() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::TransferBinary, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_transfer_data<BaseClass>::Streamedtransfer_data, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_transfer_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status transfer_data(::grpc::ServerContext* context, const ::dan::TransferBinary* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtransfer_data(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::TransferBinary,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insert_record : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_insert_record() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::InsertRecord, ::dan::Str>(std::bind(&WithStreamedUnaryMethod_insert_record<BaseClass>::Streamedinsert_record, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_insert_record() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insert_record(::grpc::ServerContext* context, const ::dan::InsertRecord* request, ::dan::Str* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinsert_record(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::InsertRecord,::dan::Str>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insert_record_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_insert_record_batch() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::InsertRecordBatch, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_insert_record_batch<BaseClass>::Streamedinsert_record_batch, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_insert_record_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insert_record_batch(::grpc::ServerContext* context, const ::dan::InsertRecordBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinsert_record_batch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::InsertRecordBatch,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_import_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_import_vertex() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::ImportVertex, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_import_vertex<BaseClass>::Streamedimport_vertex, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_import_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status import_vertex(::grpc::ServerContext* context, const ::dan::ImportVertex* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedimport_vertex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::ImportVertex,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insert_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_insert_vertex() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::InsertVertex, ::dan::Long>(std::bind(&WithStreamedUnaryMethod_insert_vertex<BaseClass>::Streamedinsert_vertex, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_insert_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insert_vertex(::grpc::ServerContext* context, const ::dan::InsertVertex* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinsert_vertex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::InsertVertex,::dan::Long>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insert_vertex_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_insert_vertex_batch() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::InsertVertexBatch, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_insert_vertex_batch<BaseClass>::Streamedinsert_vertex_batch, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_insert_vertex_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insert_vertex_batch(::grpc::ServerContext* context, const ::dan::InsertVertexBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinsert_vertex_batch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::InsertVertexBatch,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_import_edge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_import_edge() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::ImportEdge, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_import_edge<BaseClass>::Streamedimport_edge, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_import_edge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status import_edge(::grpc::ServerContext* context, const ::dan::ImportEdge* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedimport_edge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::ImportEdge,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insert_edge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_insert_edge() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::InsertEdge, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_insert_edge<BaseClass>::Streamedinsert_edge, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_insert_edge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insert_edge(::grpc::ServerContext* context, const ::dan::InsertEdge* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinsert_edge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::InsertEdge,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insert_edge_vp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_insert_edge_vp() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::InsertEdgeVP, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_insert_edge_vp<BaseClass>::Streamedinsert_edge_vp, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_insert_edge_vp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insert_edge_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeVP* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinsert_edge_vp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::InsertEdgeVP,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insert_edge_naive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_insert_edge_naive() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::InsertEdgeNaive, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_insert_edge_naive<BaseClass>::Streamedinsert_edge_naive, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_insert_edge_naive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insert_edge_naive(::grpc::ServerContext* context, const ::dan::InsertEdgeNaive* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinsert_edge_naive(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::InsertEdgeNaive,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insert_edge_batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_insert_edge_batch() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::InsertEdgeBatch, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_insert_edge_batch<BaseClass>::Streamedinsert_edge_batch, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_insert_edge_batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insert_edge_batch(::grpc::ServerContext* context, const ::dan::InsertEdgeBatch* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinsert_edge_batch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::InsertEdgeBatch,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insert_edge_batch_vp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_insert_edge_batch_vp() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::InsertEdgeBatchVP, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_insert_edge_batch_vp<BaseClass>::Streamedinsert_edge_batch_vp, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_insert_edge_batch_vp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insert_edge_batch_vp(::grpc::ServerContext* context, const ::dan::InsertEdgeBatchVP* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinsert_edge_batch_vp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::InsertEdgeBatchVP,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_table_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_get_table_info() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::TableInfo>(std::bind(&WithStreamedUnaryMethod_get_table_info<BaseClass>::Streamedget_table_info, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_get_table_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_table_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::TableInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_table_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::TableInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_num_records : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_get_num_records() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::Long>(std::bind(&WithStreamedUnaryMethod_get_num_records<BaseClass>::Streamedget_num_records, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_get_num_records() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_num_records(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_num_records(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::Long>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_table_scan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_table_scan() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::TableScan, ::dan::Table>(std::bind(&WithStreamedUnaryMethod_table_scan<BaseClass>::Streamedtable_scan, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_table_scan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status table_scan(::grpc::ServerContext* context, const ::dan::TableScan* request, ::dan::Table* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtable_scan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::TableScan,::dan::Table>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_index_search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_index_search() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::IndexSearch, ::dan::Table>(std::bind(&WithStreamedUnaryMethod_index_search<BaseClass>::Streamedindex_search, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_index_search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status index_search(::grpc::ServerContext* context, const ::dan::IndexSearch* request, ::dan::Table* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedindex_search(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::IndexSearch,::dan::Table>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_graph_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_get_graph_info() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::GraphInfo>(std::bind(&WithStreamedUnaryMethod_get_graph_info<BaseClass>::Streamedget_graph_info, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_get_graph_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_graph_info(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::GraphInfo* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_graph_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::GraphInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_num_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_get_num_vertex() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::Long>(std::bind(&WithStreamedUnaryMethod_get_num_vertex<BaseClass>::Streamedget_num_vertex, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_get_num_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_num_vertex(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_num_vertex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::Long>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_num_edges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_get_num_edges() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::Str, ::dan::Long>(std::bind(&WithStreamedUnaryMethod_get_num_edges<BaseClass>::Streamedget_num_edges, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_get_num_edges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_num_edges(::grpc::ServerContext* context, const ::dan::Str* request, ::dan::Long* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_num_edges(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::Str,::dan::Long>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_adjacent_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_adjacent_list() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::AdjacentList, ::dan::AdjacentListResult>(std::bind(&WithStreamedUnaryMethod_adjacent_list<BaseClass>::Streamedadjacent_list, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_adjacent_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status adjacent_list(::grpc::ServerContext* context, const ::dan::AdjacentList* request, ::dan::AdjacentListResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedadjacent_list(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::AdjacentList,::dan::AdjacentListResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_vertex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_get_vertex() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::GetVertex, ::dan::Record>(std::bind(&WithStreamedUnaryMethod_get_vertex<BaseClass>::Streamedget_vertex, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_get_vertex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_vertex(::grpc::ServerContext* context, const ::dan::GetVertex* request, ::dan::Record* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_vertex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::GetVertex,::dan::Record>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_vertex_exists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_vertex_exists() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::VertexExists, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_vertex_exists<BaseClass>::Streamedvertex_exists, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_vertex_exists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status vertex_exists(::grpc::ServerContext* context, const ::dan::VertexExists* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedvertex_exists(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::VertexExists,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_remote_task : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_remote_task() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::RemoteTask, ::dan::RemoteResult>(std::bind(&WithStreamedUnaryMethod_remote_task<BaseClass>::Streamedremote_task, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_remote_task() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status remote_task(::grpc::ServerContext* context, const ::dan::RemoteTask* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedremote_task(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::RemoteTask,::dan::RemoteResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_remote_object : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_remote_object() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::RemoteObject, ::dan::RemoteResult>(std::bind(&WithStreamedUnaryMethod_remote_object<BaseClass>::Streamedremote_object, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_remote_object() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status remote_object(::grpc::ServerContext* context, const ::dan::RemoteObject* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedremote_object(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::RemoteObject,::dan::RemoteResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_remove_remote_object : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_remove_remote_object() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::RemoteTaskResult, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_remove_remote_object<BaseClass>::Streamedremove_remote_object, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_remove_remote_object() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status remove_remote_object(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedremove_remote_object(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::RemoteTaskResult,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_remote_object_task : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_remote_object_task() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::RemoteObjectTask, ::dan::RemoteResult>(std::bind(&WithStreamedUnaryMethod_remote_object_task<BaseClass>::Streamedremote_object_task, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_remote_object_task() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status remote_object_task(::grpc::ServerContext* context, const ::dan::RemoteObjectTask* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedremote_object_task(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::RemoteObjectTask,::dan::RemoteResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_remote_task_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_remote_task_result() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::RemoteTaskResult, ::dan::RemoteResult>(std::bind(&WithStreamedUnaryMethod_remote_task_result<BaseClass>::Streamedremote_task_result, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_remote_task_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status remote_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::RemoteResult* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedremote_task_result(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::RemoteTaskResult,::dan::RemoteResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_remove_task_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_remove_task_result() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::RemoteTaskResult, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_remove_task_result<BaseClass>::Streamedremove_task_result, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_remove_task_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status remove_task_result(::grpc::ServerContext* context, const ::dan::RemoteTaskResult* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedremove_task_result(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::RemoteTaskResult,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_load_graph_from_folder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_load_graph_from_folder() {
      ::grpc::Service::MarkMethodStreamed(53,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::LoadGraphFromFolder, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_load_graph_from_folder<BaseClass>::Streamedload_graph_from_folder, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_load_graph_from_folder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status load_graph_from_folder(::grpc::ServerContext* context, const ::dan::LoadGraphFromFolder* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedload_graph_from_folder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::LoadGraphFromFolder,::dan::Code>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_train_node_classifier : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_train_node_classifier() {
      ::grpc::Service::MarkMethodStreamed(54,
        new ::grpc::internal::StreamedUnaryHandler< ::dan::NodeClassifierInfo, ::dan::Code>(std::bind(&WithStreamedUnaryMethod_train_node_classifier<BaseClass>::Streamedtrain_node_classifier, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_train_node_classifier() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status train_node_classifier(::grpc::ServerContext* context, const ::dan::NodeClassifierInfo* request, ::dan::Code* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtrain_node_classifier(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dan::NodeClassifierInfo,::dan::Code>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ping<WithStreamedUnaryMethod_test_multiunary<WithStreamedUnaryMethod_test_size<WithStreamedUnaryMethod_archive<WithStreamedUnaryMethod_recover<WithStreamedUnaryMethod_request_node_list<WithStreamedUnaryMethod_request_register_node<WithStreamedUnaryMethod_request_socket<WithStreamedUnaryMethod_memory_statistics<WithStreamedUnaryMethod_create_table<WithStreamedUnaryMethod_drop_table<WithStreamedUnaryMethod_drop_table_if_exists<WithStreamedUnaryMethod_load_table<WithStreamedUnaryMethod_create_index<WithStreamedUnaryMethod_table_partition<WithStreamedUnaryMethod_set_partition<WithStreamedUnaryMethod_create_graph<WithStreamedUnaryMethod_drop_graph<WithStreamedUnaryMethod_drop_graph_if_exists<WithStreamedUnaryMethod_define_vertex<WithStreamedUnaryMethod_graph_partition<WithStreamedUnaryMethod_graph_merge<WithStreamedUnaryMethod_transfer_data<WithStreamedUnaryMethod_insert_record<WithStreamedUnaryMethod_insert_record_batch<WithStreamedUnaryMethod_import_vertex<WithStreamedUnaryMethod_insert_vertex<WithStreamedUnaryMethod_insert_vertex_batch<WithStreamedUnaryMethod_import_edge<WithStreamedUnaryMethod_insert_edge<WithStreamedUnaryMethod_insert_edge_vp<WithStreamedUnaryMethod_insert_edge_naive<WithStreamedUnaryMethod_insert_edge_batch<WithStreamedUnaryMethod_insert_edge_batch_vp<WithStreamedUnaryMethod_get_table_info<WithStreamedUnaryMethod_get_num_records<WithStreamedUnaryMethod_table_scan<WithStreamedUnaryMethod_index_search<WithStreamedUnaryMethod_get_graph_info<WithStreamedUnaryMethod_get_num_vertex<WithStreamedUnaryMethod_get_num_edges<WithStreamedUnaryMethod_adjacent_list<WithStreamedUnaryMethod_get_vertex<WithStreamedUnaryMethod_vertex_exists<WithStreamedUnaryMethod_remote_task<WithStreamedUnaryMethod_remote_object<WithStreamedUnaryMethod_remove_remote_object<WithStreamedUnaryMethod_remote_object_task<WithStreamedUnaryMethod_remote_task_result<WithStreamedUnaryMethod_remove_task_result<WithStreamedUnaryMethod_load_graph_from_folder<WithStreamedUnaryMethod_train_node_classifier<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_get_edge_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_get_edge_list() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::SplitServerStreamingHandler< ::dan::Str, ::dan::EdgeList>(std::bind(&WithSplitStreamingMethod_get_edge_list<BaseClass>::Streamedget_edge_list, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_get_edge_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_edge_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::EdgeList>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedget_edge_list(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::dan::Str,::dan::EdgeList>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_get_vertex_list : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_get_vertex_list() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::SplitServerStreamingHandler< ::dan::Str, ::dan::VertexList>(std::bind(&WithSplitStreamingMethod_get_vertex_list<BaseClass>::Streamedget_vertex_list, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_get_vertex_list() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_vertex_list(::grpc::ServerContext* context, const ::dan::Str* request, ::grpc::ServerWriter< ::dan::VertexList>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedget_vertex_list(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::dan::Str,::dan::VertexList>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_get_edge_list<WithSplitStreamingMethod_get_vertex_list<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_ping<WithStreamedUnaryMethod_test_multiunary<WithStreamedUnaryMethod_test_size<WithStreamedUnaryMethod_archive<WithStreamedUnaryMethod_recover<WithStreamedUnaryMethod_request_node_list<WithStreamedUnaryMethod_request_register_node<WithStreamedUnaryMethod_request_socket<WithStreamedUnaryMethod_memory_statistics<WithStreamedUnaryMethod_create_table<WithStreamedUnaryMethod_drop_table<WithStreamedUnaryMethod_drop_table_if_exists<WithStreamedUnaryMethod_load_table<WithStreamedUnaryMethod_create_index<WithStreamedUnaryMethod_table_partition<WithStreamedUnaryMethod_set_partition<WithStreamedUnaryMethod_create_graph<WithStreamedUnaryMethod_drop_graph<WithStreamedUnaryMethod_drop_graph_if_exists<WithStreamedUnaryMethod_define_vertex<WithStreamedUnaryMethod_graph_partition<WithStreamedUnaryMethod_graph_merge<WithStreamedUnaryMethod_transfer_data<WithStreamedUnaryMethod_insert_record<WithStreamedUnaryMethod_insert_record_batch<WithStreamedUnaryMethod_import_vertex<WithStreamedUnaryMethod_insert_vertex<WithStreamedUnaryMethod_insert_vertex_batch<WithStreamedUnaryMethod_import_edge<WithStreamedUnaryMethod_insert_edge<WithStreamedUnaryMethod_insert_edge_vp<WithStreamedUnaryMethod_insert_edge_naive<WithStreamedUnaryMethod_insert_edge_batch<WithStreamedUnaryMethod_insert_edge_batch_vp<WithStreamedUnaryMethod_get_table_info<WithStreamedUnaryMethod_get_num_records<WithStreamedUnaryMethod_table_scan<WithStreamedUnaryMethod_index_search<WithStreamedUnaryMethod_get_graph_info<WithStreamedUnaryMethod_get_num_vertex<WithStreamedUnaryMethod_get_num_edges<WithStreamedUnaryMethod_adjacent_list<WithSplitStreamingMethod_get_edge_list<WithStreamedUnaryMethod_get_vertex<WithSplitStreamingMethod_get_vertex_list<WithStreamedUnaryMethod_vertex_exists<WithStreamedUnaryMethod_remote_task<WithStreamedUnaryMethod_remote_object<WithStreamedUnaryMethod_remove_remote_object<WithStreamedUnaryMethod_remote_object_task<WithStreamedUnaryMethod_remote_task_result<WithStreamedUnaryMethod_remove_task_result<WithStreamedUnaryMethod_load_graph_from_folder<WithStreamedUnaryMethod_train_node_classifier<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace dan


#endif  // GRPC_interface_2eproto__INCLUDED
